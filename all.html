<!doctype html>
<html class="no-js" lang="en">
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?fdc936c9f5a3b72177541183cdeb8cb3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  techlarry
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="techlarry" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:larryim.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        <li id=""><a target="_self" href="category.html">Category</a></li>
        
        <li id=""><a target="_self" href="notebook.html">NoteBook</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="http://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; techlarry</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        
        <li><a target="_self" href="category.html">Category</a></li>
        
        <li><a target="_self" href="notebook.html">NoteBook</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Leetcode.html">Leetcode</a></li>
        
            <li><a href="C/C++.html">C/C++</a></li>
        
            <li><a href="Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html">Python数据结构与算法</a></li>
        
            <li><a href="Python%E7%89%B9%E6%80%A7.html">Python特性</a></li>
        
            <li><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html">机器学习</a></li>
        
            <li><a href="Python%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96.html">Python科学计算三维可视化</a></li>
        
            <li><a href="English.html">English</a></li>
        
            <li><a href="Computer%20System.html">Computer System</a></li>
        
            <li><a href="Deep%20Learning.html">Deep Learning</a></li>
        
            <li><a href="Latex.html">Latex</a></li>
        
            <li><a href="Linux%20%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html">Linux 系统编程</a></li>
        
            <li><a href="%E6%95%B0%E6%8D%AE%E5%BA%93.html">数据库</a></li>
        
            <li><a href="Tensorflow.html">Tensorflow</a></li>
        
            <li><a href="Big%20Data.html">Big Data</a></li>
        
            <li><a href="%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB.html">文献阅读</a></li>
        
            <li><a href="Tools.html">Tools</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="develop_tools.html">
                
                  <h1>Develop tools</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">gdb</h2>

<p>GDB（GNU Debugger）作为一个调试工具，其功能强大。</p>

<h3 id="toc_1">调试信息</h3>

<p>要调试C/C++的程序，首先在编译时，我们必须要把调试信息(symbol table)加到可执行文件中。使用编译器（cc/gcc/g++）的 <code>-g</code> 参数(Generate source-level debug information)可以做到这一点。</p>

<pre><code>g++ -g HelloWorld.cpp -o HelloWorld
</code></pre>

<h3 id="toc_2">常用命令</h3>

<ul>
<li><code>break &lt;location&gt;</code>

<ul>
<li>Stop execution at function name or address </li>
<li>Reset breakpoints when restarting gdb </li>
</ul></li>
<li><code>run &lt;args&gt;</code> 

<ul>
<li>Run program with args <args> </li>
<li>Convenient for specifying text file with answers</li>
</ul></li>
<li><code>disas &lt;fun&gt;</code>, but not dis </li>
<li><p><code>stepi</code> / <code>nexti</code> </p>

<ul>
<li>Steps / does not step through function calls</li>
</ul></li>
<li><p><code>info registers</code> </p>

<ul>
<li>Print hex values in every register </li>
</ul></li>
<li><p><code>print (/x or /d) $eax</code> - Yes, use $ </p>

<ul>
<li>Print hex or decimal contents of %eax </li>
</ul></li>
<li><p><code>x $register</code>, <code>x 0xaddress</code> </p>

<ul>
<li>Prints what’s in the register / at the given address</li>
<li>By default, prints one word (4 bytes) </li>
<li>Specify format: /s, /[num][size][format] *

<ul>
<li> x/8a 0x15213 *</li>
<li> x/4wd 0xdeadbeef</li>
</ul></li>
</ul></li>
<li><p><code>list</code>: view source code</p></li>
</ul>

<h3 id="toc_3">远程调试</h3>

<p>有时候需要调试的程序并不在本机上，<code>gdb</code>是支持远程调试的，具体命令如下：</p>

<pre><code>(gdb) target remote IP:PORT
</code></pre>

<p>这时，本机的GDB客户端可以远程连接到被调试机器上，对程序进行调试。当然，前提是在远端的机器上，必须要启动好GDB服务端程序。</p>

<h2 id="toc_4">Objdump</h2>

<h3 id="toc_5">disassemble</h3>

<p><code>objdump -d</code> display the assembler mnemonics for the machine instructions from obj-file.</p>

<p>There are <em>3 columns</em> in the output:</p>

<ul>
<li>memory addresses</li>
<li>machine language instructions</li>
<li>assembly language</li>
</ul>

<h3 id="toc_6">examine the symbol table</h3>

<p><code>objdump -t</code> prints the symbol table entries of the file.</p>

<p>There are <em>7 columns</em> in the output:</p>

<ul>
<li>value</li>
<li>class</li>
<li>type</li>
<li>size</li>
<li>line</li>
<li>section</li>
<li>symbol-name</li>
</ul>

<h2 id="toc_7">tmux</h2>

<p><code>tmux</code>有两个主要功能：</p>

<ul>
<li>Split窗口。可以在一个terminal下打开多个会话</li>
<li>避免网络不稳定。由于网络不稳定导致的SSH断开，在重新连接后，可以直接回到原来的工作环境。</li>
</ul>

<p>常用按键：</p>

<h1 id="toc_8">常用按键</h1>

<p>这里需要说明一点的是，tmux的任何指令，都包含一个前缀，也就是说，你按了前缀(一组按键， 默认是Ctrl+b)以后，系统才知道你接下来的指令是发送给tmux的。</p>

<ul>
<li>C-b ? 显示快捷键帮助</li>
<li>C-b C-o 调换窗口位置，类似与vim 里的C-w</li>
<li>C-b 空格键 采用下一个内置布局</li>
<li>C-b ! 把当前窗口变为新窗口</li>
<li>C-b “ 横向分隔窗口</li>
<li>C-b % 纵向分隔窗口</li>
<li>C-b q 显示分隔窗口的编号</li>
<li>C-b o 跳到下一个分隔窗口</li>
<li>C-b 上下键 上一个及下一个分隔窗口</li>
<li>C-b C-方向键 调整分隔窗口大小</li>
<li>C-b c 创建新窗口</li>
<li>C-b 0~9 选择几号窗口</li>
<li>C-b c 创建新窗口</li>
<li>C-b n 选择下一个窗口</li>
<li>C-b l 切换到最后使用的窗口</li>
<li>C-b p 选择前一个窗口</li>
<li>C-b w 以菜单方式显示及选择窗口</li>
<li>C-b t 显示时钟</li>
<li>C-b ; 切换到最后一个使用的面板</li>
<li>C-b x 关闭面板</li>
<li>C-b &amp; 关闭窗口</li>
<li>C-b s 以菜单方式显示和选择会话</li>
<li>C-b d 退出tumx，并保存当前会话，这时，tmux仍在后台运行，可以通过tmux attach进入 到指定的会话 </li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/12/25</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Tools.html'>Tools</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="C_plus_plus_ostream.html">
                
                  <h1>C++ Ostream</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>设定输出域宽度: <code>setw</code></li>
</ul>

<pre><code class="language-C++">// 设定域的输出长度为8，而实际字符串长度为4，所有前面补四个空格。
cout &lt;&lt; &quot;[&quot; &lt;&lt; setw(8) &lt;&lt; &quot;AAAA&quot; &lt;&lt; &quot;]&quot;;        // [    AAAA]
</code></pre>

<p>如果<code>setw</code>的数值小于实际数据长度，<code>setw</code>的值无效，比如上述例子：</p>

<pre><code class="language-C++">//因为3小于实际字符串长度4，最终输出整个字符串。
cout &lt;&lt; &quot;[&quot; &lt;&lt; setw(3) &lt;&lt; &quot;AAAA&quot; &lt;&lt; &quot;]&quot;         // [AAAA]
</code></pre>

<ul>
<li>对齐方式：<code>left</code>/<code>right</code>/<code>internal</code></li>
</ul>

<p>在设定了输出域的宽度<code>setw</code>后，如果设置对齐方式，左对齐还是右对齐(缺省是右对齐(<code>right</code>))</p>

<pre><code class="language-C++"> cout &lt;&lt; &quot;[&quot; &lt;&lt; setw(8) &lt;&lt; left &lt;&lt; &quot;AAAA&quot; &lt;&lt; &quot;]&quot;;       // [AAAA    ]
 cout &lt;&lt; &quot;[&quot; &lt;&lt; setw(8) &lt;&lt; right &lt;&lt; &quot;AAAA&quot; &lt;&lt; &quot;]&quot;;      // [    AAAA]
 cout &lt;&lt; &quot;[&quot; &lt;&lt; setw(8) &lt;&lt; &quot;AAAA&quot; &lt;&lt; &quot;]&quot;;                    // [    AAAA]
</code></pre>

<ul>
<li>填充字符: <code>setfill</code></li>
</ul>

<p>域宽度不够时，还可以指定，用来代替缺省的空格</p>

<pre><code class="language-C++">//使用字符&#39;0&#39;作为填充
 cout &lt;&lt; &quot;[&quot; &lt;&lt; setw(8) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; &quot;AAAA&quot; &lt;&lt; &quot;]&quot;; // [0000AAAA]
 cout &lt;&lt; &quot;[&quot; &lt;&lt; setw(8) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; left &lt;&lt; &quot;AAAA&quot; &lt;&lt; &quot;]&quot;;    // [AAAA0000]
</code></pre>

<ul>
<li>输出正负号: <code>showpos</code></li>
</ul>

<pre><code class="language-C++"> cout &lt;&lt; &quot;[&quot; &lt;&lt; showpos &lt;&lt; 123 &lt;&lt; &quot;]&quot;;   // [+123]
 cout &lt;&lt; &quot;[&quot; &lt;&lt; showpos &lt;&lt; -456 &lt;&lt; &quot;]&quot;;  // [-456]
 cout &lt;&lt; &quot;[&quot; &lt;&lt; showpos &lt;&lt; 0 &lt;&lt; &quot;]&quot;;     // [+0]
</code></pre>

<ul>
<li>输出16进制数字值: <code>hex</code></li>
</ul>

<pre><code class="language-C++">cout &lt;&lt; &quot;[&quot; &lt;&lt; hex &lt;&lt; 20  &lt;&lt; &quot;]&quot;;   //  [14]
</code></pre>

<ul>
<li>可以加前缀<code>0x</code>: <code>showbase</code></li>
</ul>

<pre><code class="language-C++">cout &lt;&lt; &quot;[&quot; &lt;&lt; showbase &lt;&lt; hex &lt;&lt; setw(2) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; 5  &lt;&lt; &quot;]&quot;;  // [0x5]
</code></pre>

<ul>
<li>16进制值(A-F)大写: <code>uppercase</code></li>
</ul>

<pre><code class="language-C++">cout &lt;&lt; &quot;[&quot; &lt;&lt; hex &lt;&lt; uppercase &lt;&lt; setw(2) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; 10  &lt;&lt; &quot;]&quot;;  // [0A]
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/12/16</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='C/C++.html'>C/C++</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="introduction_to_computer_system_CMU.html">
                
                  <h1>CMU 213 Introduction to Computer Systems</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>CMU 213 <code>Introduction to Computer Systems</code>可能是世界上最受欢迎的一门课。与这门课对应的课本CSAPP在全球被广泛采用，也被无数学生拜读。课程内容涉及广泛、由浅入深，是进入计算机科学的最佳课程，也是各种击破BAT笔试题的必备良药(<a href="https://book.douban.com/review/5627139/">这篇帖子描述了笔试题所对应的章节</a>)。</p>

<p>非常幸运的是，CMU(Carnegie Mellon University)在网上分享了上课视频和其他所有资料，点击<a href="https://scs.hosted.panopto.com/Panopto/Pages/Sessions/List.aspx#folderID=%22b96d90ae-9871-4fae-91e2-b1627b43e25e%22&amp;sortColumn=0&amp;sortAscending=true">这里</a>观看。</p>

<p>课程资料：</p>

<ul>
<li><a href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/schedule.html">课程主页</a>，包括了PPT，代码</li>
<li><a href="http://csapp.cs.cmu.edu">课本CSAPP主页</a>，包括了Lab资源。</li>
</ul>

<p>下面是课程笔记：</p>

<p>待续。。。。。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/12/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Computer%20System.html'>Computer System</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="nand2tetris.html">
                
                  <h1>Nand2Tetris: The elements of computing systems</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">1.布尔逻辑 Boolean Logic</a>
</li>
<li>
<a href="#toc_1">2.布尔运算 Boolean Arithmetic</a>
</li>
<li>
<a href="#toc_2">3.时序逻辑 Sequential Logic</a>
</li>
<li>
<a href="#toc_3">4.机器语言 Machine Language</a>
</li>
<li>
<a href="#toc_4">5.计算机体系结构 Computer Architecture</a>
</li>
</ul>


<p><code>Nand2Tetris 计算机系统要素</code>是一门教你从零开始构建现代计算机的课程。该课程已经在Coursera上开设(分为上下两门课程)，有免费的课本和课程需要的代码，也有专门的论坛来交流学习，课程相关资源如下：</p>

<ul>
<li><a href="https://www.coursera.org/learn/build-a-computer">Coursera Course Part1</a></li>
<li><a href="https://www.coursera.org/learn/nand2tetris2">Coursera Course Part2</a></li>
<li><a href="http://nand2tetris.org">Nand2Tetris Project Homepage</a></li>
<li><a href="http://nand2tetris-questions-and-answers-forum.32033.n3.nabble.com">Nand2Tetris Questions and Answer Forum</a></li>
<li><a href="https://book.douban.com/subject/1998645/">Textbook: The elements of computing system</a></li>
</ul>

<p>该课程适合学生掌握了计算机入门课程和数据结构以后学习，课程涉及布尔逻辑及运算、机器语言、计算机体系结构、汇编、虚拟机、编译器、操作系统。课程内容与CMU的深入理解计算机系统不一样，个人感觉涉及面更广、更加注重实战。</p>

<p>下面是课程的简单总结：</p>

<h2 id="toc_0">1.布尔逻辑 Boolean Logic</h2>

<p><strong>多通道/多位Multiplexor</strong>: 一个拥有m个通道、每个通道数据宽度为n位的multiplexor选择器，将m个n位输入变量中选择一个并从其单一的n位输出总线上输出。可以用k个控制位来指定这个选择(\(k=\log_2 m\))。</p>

<p><strong>例</strong>：4通道16位的multiplexor(4-way Multiplexor):</p>

<p><img src="media/15128019428341/4-way%20multiplexor.png" alt="4-way multiplexo"/></p>

<p><strong>多通道/多位Demultiplexor</strong>: m通道、n位的demult<br/>
iplexor从m个可能的n位输出通道中选择一个n位的输入变量。可以用k个控制位来指定这个选择(\(k=\log_2 m\))。</p>

<p><strong>例</strong>：4-way Demultiplexor:</p>

<p><img src="media/15128019428341/4-way%20demultiplexor.png" alt="4-way demultiplexo"/></p>

<pre><code>/**
 * 4-way demultiplexor:
 * {a, b, c, d} = {in, 0, 0, 0} if sel == 00
 *                {0, in, 0, 0} if sel == 01
 *                {0, 0, in, 0} if sel == 10
 *                {0, 0, 0, in} if sel == 11
 */

CHIP DMux4Way {
    IN in, sel[2];
    OUT a, b, c, d;

    PARTS:
    DMux(in=in, sel=sel[1], a=c1, b=c2);
    DMux(in=c1, sel=sel[0], a=a, b=b);
    DMux(in=c2, sel=sel[0], a=c, b=d);

}
</code></pre>

<h2 id="toc_1">2.布尔运算 Boolean Arithmetic</h2>

<p>半加器(Half Adder): 进行二进制数加法的第一步就是要能够对两个二进制位进行相加。我们把结果的LSB(Least Significant Bit)称为sum，MSB(Most Significant Bit)称为carry。</p>

<p><img src="media/15128019428341/Half%20Adder.png" alt="Half Adde"/></p>

<p>HDL语言：</p>

<pre><code>CHIP HalfAdder {
    IN a, b;    // 1-bit inputs
    OUT sum,    // Right bit of a + b 
        carry;  // Left bit of a + b

    PARTS:
    And(a=a, b=b, out=carry);
    Xor(a=a, b=b, out=sum);
}
</code></pre>

<p>全加器：用来对三个位相加。</p>

<p><img src="media/15128019428341/Full%20Adder.png" alt="Full Adde"/></p>

<p>HDL 语言：</p>

<pre><code>CHIP FullAdder {
    IN a, b, c;  // 1-bit inputs
    OUT sum,     // Right bit of a + b + c
        carry;   // Left bit of a + b + c

    PARTS:
    HalfAdder(a=a, b=b, sum=sum1, carry=carry1);
    HalfAdder(a=c, b=sum1, sum=sum, carry=carry2);
    Or(a=carry1, b=carry2, out=carry);
}
</code></pre>

<p>加法器(Adder): 存储器和寄存器电路用n位的形式来表示整数，n可以是16、32、64等等, 这依赖于所在的计算机平台。进行n位加法的芯片称为多位加法器(multi-bit adder),或者简称为加法器。下图为16位加法器</p>

<p><img src="media/15128019428341/16-bits%20Adder.png" alt="16-bits Adde"/></p>

<p>HDL:</p>

<pre><code>CHIP Add16 {
    IN a[16], b[16];
    OUT out[16];

    PARTS:
   HalfAdder(a=a[0], b=b[0], carry=carry1, sum=out[0]);
   FullAdder(a=a[1], b=b[1], c=carry1, carry=carry2, sum=out[1]);
   FullAdder(a=a[2], b=b[2], c=carry2, carry=carry3, sum=out[2]);
   FullAdder(a=a[3], b=b[3], c=carry3, carry=carry4, sum=out[3]);
   FullAdder(a=a[4], b=b[4], c=carry4, carry=carry5, sum=out[4]);
   FullAdder(a=a[5], b=b[5], c=carry5, carry=carry6, sum=out[5]);
   FullAdder(a=a[6], b=b[6], c=carry6, carry=carry7, sum=out[6]);
   FullAdder(a=a[7], b=b[7], c=carry7, carry=carry8, sum=out[7]);
   FullAdder(a=a[8], b=b[8], c=carry8, carry=carry9, sum=out[8]);
   FullAdder(a=a[9], b=b[9], c=carry9, carry=carry10, sum=out[9]);
   FullAdder(a=a[10], b=b[10], c=carry10, carry=carry11, sum=out[10]);
   FullAdder(a=a[11], b=b[11], c=carry11, carry=carry12, sum=out[11]);
   FullAdder(a=a[12], b=b[12], c=carry12, carry=carry13, sum=out[12]);
   FullAdder(a=a[13], b=b[13], c=carry13, carry=carry14, sum=out[13]);
   FullAdder(a=a[14], b=b[14], c=carry14, carry=carry15, sum=out[14]);
   FullAdder(a=a[15], b=b[15], c=carry15, carry=carry, sum=out[15]);

}
</code></pre>

<p>算数逻辑单元(Arithmetic Logic Unit, ALU): 计算一组固定的函数\(out=f_i(x,y)\),这里\(x\)和\(y\)是芯片的两个16位输入，\(out\)是芯片的16位输出, \(f_i\)是位于一个函数表中的函数，该函数表通过6个控制位(control bit)的输入位(zx, nx, zy, ny, f, no)来告诉ALU用哪一个函数来进行何种计算。</p>

<p><img src="media/15128019428341/ALU.png" alt="ALU"/></p>

<p>HDL:</p>

<pre><code>*
 * The ALU (Arithmetic Logic Unit).
 * Computes one of the following functions:
 * x+y, x-y, y-x, 0, 1, -1, x, y, -x, -y, !x, !y,
 * x+1, y+1, x-1, y-1, x&amp;y, x|y on two 16-bit inputs, 
 * according to 6 input bits denoted zx,nx,zy,ny,f,no.
 * In addition, the ALU computes two 1-bit outputs:
 * if the ALU output == 0, zr is set to 1; otherwise zr is set to 0;
 * if the ALU output &lt; 0, ng is set to 1; otherwise ng is set to 0.
 */

// Implementation: the ALU logic manipulates the x and y inputs
// and operates on the resulting values, as follows:
// if (zx == 1) set x = 0        // 16-bit constant
// if (nx == 1) set x = !x       // bitwise not
// if (zy == 1) set y = 0        // 16-bit constant
// if (ny == 1) set y = !y       // bitwise not
// if (f == 1)  set out = x + y  // integer 2&#39;s complement addition
// if (f == 0)  set out = x &amp; y  // bitwise and
// if (no == 1) set out = !out   // bitwise not
// if (out == 0) set zr = 1
// if (out &lt; 0) set ng = 1

CHIP ALU {
    IN  
        x[16], y[16],  // 16-bit inputs        
        zx, // zero the x input?
        nx, // negate the x input?
        zy, // zero the y input?
        ny, // negate the y input?
        f,  // compute out = x + y (if 1) or x &amp; y (if 0)
        no; // negate the out output?

    OUT 
        out[16], // 16-bit output
        zr, // 1 if (out == 0), 0 otherwise
        ng; // 1 if (out &lt; 0),  0 otherwise

    PARTS:
    // if (zx==1) set x = 0
    Mux16(a=x,b=false,sel=zx,out=zxout);

    // if (zy==1) set y = 0
    Mux16(a=y,b=false,sel=zy,out=zyout); 

    // if (nx==1) set x = ~x
    // if (ny==1) set y = ~y  
    Not16(in=zxout,out=notx);
    Not16(in=zyout,out=noty);
    Mux16(a=zxout,b=notx,sel=nx,out=nxout); 
    Mux16(a=zyout,b=noty,sel=ny,out=nyout);

    // if (f==1)  set out = x + y 
    // if (f==0)  set out = x &amp; y
    Add16(a=nxout,b=nyout,out=addout);
    And16(a=nxout,b=nyout,out=andout);
    Mux16(a=andout,b=addout,sel=f,out=fout);
    
    // if (no==1) set out = ~out
    // 1 if (out&lt;0),  0 otherwise
    Not16(in=fout,out=nfout);
    Mux16(a=fout,b=nfout,sel=no,out=out,out[0..7]=zr1,out[8..15]=zr2,out[15]=ng);
    
    //if (out==0), zr=1
    Or8Way(in=zr1,out=or1);
    Or8Way(in=zr2,out=or2);
    Or(a=or1,b=or2,out=or3);
    Not(in=or3,out=zr);

}
</code></pre>

<h2 id="toc_2">3.时序逻辑 Sequential Logic</h2>

<p>时钟(Clock)：在大多数计算机里，时间的流逝是用主时钟(master clock)来表示的，它提供连续的交变信号序列。其精确的硬件实现通常基于振荡器(oscillator),其在两个信号值0-1之间交替变化。两个响铃的时间间隔称为时钟的周期。</p>

<p>触发器(Flip-Flop): 计算机里最基本的时序单元，有多个变种。数据触发器(Data Flip-Flop, <code>DFF</code>)，其接口包含1比特位输入和1比特位输出。 <u>DFF简单地将前一个时间周期的输入值作为当前周期的输出</u> 。</p>

<p><img src="media/15128019428341/flip-flop.png" alt="flip-flop"/></p>

<p>寄存器(Registers): 具有记忆功能的设备，能“存储”某一时刻的值，实现经典的存储行为<code>out(t)=out(t-1)</code>。从另一个方面来说，DFF仅能够输出它前一时钟周期的输入，也就是<code>out(t)=in(t-1)</code>。寄存器分为地址寄存器(address register), 数据寄存器(data register), 程序计数器(program counter).</p>

<p><img src="media/15128019428341/registers.png" alt="registers"/></p>

<p>1-位寄存器:</p>

<pre><code class="language-hdl">/**
 * 1-bit register:
 * If load[t] == 1 then out[t+1] = in[t]
 *                 else out does not change (out[t+1] = out[t])
 */

CHIP Bit {
    IN in, load;
    OUT out;

    PARTS:
    Mux(a= out1, b=in,  sel=load, out=out2);
    DFF(in=out2, out=out1, out=out);
}
</code></pre>

<p><strong>寄存器</strong>：由1-位寄存器来构建w-位寄存器是非常简单的。所需要做的就是构建一组w比特门，然后将寄存器的load输入赋予每个门。</p>

<pre><code>CHIP Register {
    IN in[16], load;
    OUT out[16];

    PARTS:
    Bit(in=in[0], load=load, out=out[0]);
    Bit(in=in[1], load=load, out=out[1]);
    Bit(in=in[2], load=load, out=out[2]);
    Bit(in=in[3], load=load, out=out[3]);
    Bit(in=in[4], load=load, out=out[4]);
    Bit(in=in[5], load=load, out=out[5]);
    Bit(in=in[6], load=load, out=out[6]);
    Bit(in=in[7], load=load, out=out[7]);
    Bit(in=in[8], load=load, out=out[8]);
    Bit(in=in[9], load=load, out=out[9]);
    Bit(in=in[10], load=load, out=out[10]);
    Bit(in=in[11], load=load, out=out[11]);
    Bit(in=in[12], load=load, out=out[12]);
    Bit(in=in[13], load=load, out=out[13]);
    Bit(in=in[14], load=load, out=out[14]);
    Bit(in=in[15], load=load, out=out[15]);
}
</code></pre>

<p><strong>内存</strong>(Memories):可以通过将寄存器堆叠起来形成 <u>随机存取存储器</u> (random access memory, <code>RAM</code>)。在RAM上能够随机访问被选择的字而不会受限于访问顺序，即随机存取存储器中的任何字都能以相等的速度被直接访问。</p>

<p><img src="media/15128019428341/RAM.png" alt="RA"/></p>

<p>RAM8:</p>

<pre><code class="language-hdl">/**
 * Memory of 8 registers, each 16 bit-wide. Out holds the value
 * stored at the memory location specified by address. If load==1, then 
 * the in value is loaded into the memory location specified by address 
 * (the loaded value will be emitted to out from the next time step onward).
 */

CHIP RAM8 {
    IN in[16], load, address[3];
    OUT out[16];

    PARTS:
    // Put your code here:
    DMux8Way(in=load, sel=address, a=loada, b=loadb, c=loadc, d=loadd, e=loade, f=loadf, g=loadg, h=loadh);
    Register(in=in, load=loada, out=outa);
    Register(in=in, load=loadb, out=outb);
    Register(in=in, load=loadc, out=outc);
    Register(in=in, load=loadd, out=outd);
    Register(in=in, load=loade, out=oute);
    Register(in=in, load=loadf, out=outf);
    Register(in=in, load=loadg, out=outg);
    Register(in=in, load=loadh, out=outh);
    Mux8Way16(a=outa, b=outb, c=outc, d=outd, e=oute, f=outf, g=outg, h=outh, sel=address, out=out);
}
</code></pre>

<p>RAM64:</p>

<pre><code>/**
 * Memory of 64 registers, each 16 bit-wide. Out holds the value
 * stored at the memory location specified by address. If load==1, then 
 * the in value is loaded into the memory location specified by address 
 * (the loaded value will be emitted to out from the next time step onward).
 */

CHIP RAM64 {
    IN in[16], load, address[6];
    OUT out[16];

    PARTS:
    DMux8Way(in=load, sel=address[3..5], a=loada, b=loadb, c=loadc, d=loadd, e=loade, f=loadf, g=loadg, h=loadh);
    RAM8(in=in, load=loada, address=address[0..2], out=outa);
    RAM8(in=in, load=loadb, address=address[0..2], out=outb);
    RAM8(in=in, load=loadc, address=address[0..2], out=outc);
    RAM8(in=in, load=loadd, address=address[0..2], out=outd);
    RAM8(in=in, load=loade, address=address[0..2], out=oute);
    RAM8(in=in, load=loadf, address=address[0..2], out=outf);
    RAM8(in=in, load=loadg, address=address[0..2], out=outg);
    RAM8(in=in, load=loadh, address=address[0..2], out=outh);
    Mux8Way16(a=outa, b=outb, c=outc, d=outd, e=oute, f=outf, g=outg, h=outh, sel=address[3..5], out=out);  
}
</code></pre>

<p>计算机芯片分为两种：组合芯片(<code>combinational chip</code>)和时序芯片(<code>sequential chip</code> or <code>clocked chip</code>时钟芯片)。组合芯片的操作具有即时性(<code>instantaneous</code>)。时序芯片的操作受时钟控制，输入的改变只有在下一个时钟周期才反应到芯片的输出管脚上: <code>out(t)=out(t-1)</code>。</p>

<p><img src="media/15128019428341/combintional%20chip%20and%20sequential%20chip.png" alt="combintional chip and sequential chip"/></p>

<p>计数器(Counter): 计数器是一种时序芯片，它的状态是证书，每经过一个时间周期，该整数就增加1个单位，执行函数<code>out(t)=out(t-1)+c</code>，这里就是1。典型的CPU包括一个程序计数器(program couter, <code>PC</code>)，它的输出是当前程序中下一步将要执行的指令地址。</p>

<p>w-位计数器包含两个主要部分：一个常规的w-位寄存器和组合逻辑。组合逻辑用来：(a)执行计数功能；(b)根据控制位的3种不同的命令值，将计数器置于正确的操作模式。</p>

<p><img src="media/15128019428341/PC.png" alt="PC"/></p>

<pre><code>/**
 * A 16-bit counter with load and reset control bits.
 * if      (reset[t] == 1) out[t+1] = 0
 * else if (load[t] == 1)  out[t+1] = in[t]
 * else if (inc[t] == 1)   out[t+1] = out[t] + 1  (integer addition)
 * else                    out[t+1] = out[t]
 */
 
CHIP PC {
    IN in[16],load,inc,reset;
    OUT out[16];

    PARTS:
    Inc16(in=regout, out=plusone);
    Mux16(a=false, b=plusone, sel=inc, out=incout);
    Mux16(a=incout, b=in, sel=load, out=loadout);
    Mux16(a=loadout, b=false, sel=reset, out=toload);
    Or(a=load, b=reset, out=loadorreset);
    Or(a=loadorreset, b=inc, out=loadflag);
    Register(in=toload, load=loadflag, out=regout);
    Or16(a=regout, b=regout, out=out);
}
</code></pre>

<p>存储器层次结构(<a href="https://en.wikipedia.org/wiki/Memory_hierarchy">memory hierarchy</a>):</p>

<p><img src="media/15128019428341/memory%20hierarchy.png" alt="memory hierarchy"/></p>

<p><img src="media/15128019428341/15128077150126.png" alt=""/></p>

<h2 id="toc_3">4.机器语言 Machine Language</h2>

<p>机器语言用来对底层程序进行编码，从而形成一系列机器指令。应用这些指令，程序员可以命令处理器执行算数和逻辑餐座，在内存中进行存取操作，让数据在寄存器之间传递，验证布尔表达式的值，等等。机器语言的设计目标是直接运行在指定的硬件平台上，能够对这个平台进行全面操控；与机器语言相反，高级语言具有通用性和较强的表达能力。</p>

<p>机器语言是整个计算机题系统意义最深奥的接口 -- 它也是硬件和软件相接的中间线。因此，既可以将机器语言看作编程工作，也可以将其看作硬件平台内部不可分割的一部分。</p>

<h2 id="toc_4">5.计算机体系结构 Computer Architecture</h2>

<p>存储程序的概念：指令没有被嵌入到硬件中，而是被存储在计算机的存储设备(memory)里，当计算机载入不同的程序指令时，同样的硬件平台可以实现不同的功能。</p>

<p>冯·诺伊曼体系结构(概念上的):冯·诺伊曼体系结构的基础是一个中央处理单元(CPU),它与内存进行交互，负责从输入设备接收数据，向输出设备发送数据。</p>

<p><img src="media/15128019428341/%E5%86%AF%E8%AF%BA%E4%BC%8A%E6%9B%BC.png" alt="冯诺伊曼"/></p>

<p>RAM: RAM不光存储数据和指令，还可以通过 <u>内存映像</u> (Memory Maps) 在CPU和计算机输入/输出设备之间充当借口。下图中屏幕和键盘都通过内存映像与计算机平台进行接口。</p>

<p><img src="media/15128019428341/memory.png" alt="memory"/></p>

<pre><code>CHIP Memory {
    IN in[16], load, address[15];
    OUT out[16];

    PARTS:

    DMux4Way(in=load, sel=address[13..14], a=ram1, b=ram2, c=screen, d=kbd);
    Or(a=ram1, b=ram2, out=ram);
    RAM16K(in=in, load=ram, address=address[0..13], out=ramout);
    Screen(in=in, load=screen, address=address[0..12], out=scrout);
    Keyboard(out=kbout);
    Mux4Way16(a=ramout, b=ramout, c=scrout, d=kbout, sel=address[13..14], out=out);
}
</code></pre>

<p>CPU包括执行指令的ALU、一组寄存器和一些用于取指令和对指令解码的控制逻辑(上上图)。用来执行下面的任务：</p>

<ul>
<li>指令解码(Instruction decoding):解析出指令所代表意思(指令的功能)。</li>
<li>指令执行(Instruction execution):发信号指示计算机的各个部分应该做什么工作来执行指令（指令的功能）。</li>
<li>读取下一条指令(Next instruction fetching):指出下一步执行哪一条指令（指令的功能以及ALU的输出）。</li>
</ul>

<p><img src="media/15128019428341/CPU_in_out.png" alt="CPU_in_out"/></p>

<pre><code>
CHIP CPU {

    IN  inM[16],         // M value input  (M = contents of RAM[A])
        instruction[16], // Instruction for execution
        reset;           // Signals whether to re-start the current program
                         // (reset == 1) or continue executing the current
                         // program (reset == 0).

    OUT outM[16],        // M value output
        writeM,          // Write into M? 
        addressM[15],    // RAM address (of M)
        pc[15];          // ROM address (of next instruction)

    PARTS:
    // get type of instruction
    Not(in=instruction[15], out=Ainstruction);
    Not(in=Ainstruction, out=Cinstruction);
    
    And(a=Cinstruction, b=instruction[5], out=ALUtoA);    // C-inst and dest to A-reg?
    Mux16(a=instruction, b=ALUout, sel=ALUtoA, out=Aregin);
    
    Or(a=Ainstruction, b=ALUtoA, out=loadA);    // load A if A-inst or C-inst&amp;dest to A-reg
    ARegister(in=Aregin, load=loadA, out=Aout);
    
    Mux16(a=Aout, b=inM, sel=instruction[12], out=AMout);   // select A or M based on a-bit

    And(a=Cinstruction, b=instruction[4], out=loadD);
    DRegister(in=ALUout, load=loadD, out=Dout);    // load the D register from ALU
    
    ALU(x=Dout, y=AMout, zx=instruction[11], nx=instruction[10], 
        zy=instruction[9], ny=instruction[8], f=instruction[7],
        no=instruction[6], out=ALUout, zr=ZRout, ng=NGout); // calculate
        
    // Set outputs for writing memory
    Or16(a=false, b=Aout, out[0..14]=addressM);
    Or16(a=false, b=ALUout, out=outM);
    And(a=Cinstruction, b=instruction[3], out=writeM);
    
    // calc PCload &amp; PCinc - whether to load PC with A reg
    And(a=ZRout, b=instruction[1], out=jeq);    // is zero and jump if zero
    And(a=NGout, b=instruction[2], out=jlt);    // is neg and jump if neg
    Or(a=ZRout, b=NGout, out=zeroOrNeg);
    Not(in=zeroOrNeg, out=positive);            // is positive (not zero and not neg)
    And(a=positive, b=instruction[0], out=jgt); // is pos and jump if pos
    Or(a=jeq, b=jlt, out=jle);
    Or(a=jle, b=jgt, out=jumpToA);              // load PC if cond met and jump if cond
    And(a=Cinstruction, b=jumpToA, out=PCload); // Only jump if C instruction
    Not(in=PCload, out=PCinc);                  // only inc if not load
    PC(in=Aout, inc=PCinc, load=PCload, reset=reset, out[0..14]=pc);
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/12/9</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Computer%20System.html'>Computer System</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="PCA.html">
                
                  <h1>PCA基础及在Spark中的应用</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>主成分分析(Principal Component Analysis, PCA)主要是用来可视化数据和数据压缩。</p>

<p>PCA的目的是找到一组可以代表原始数据的低维数据。设原始数据为\(X\in \mathbf{R}^{n\times d}\)，有\(d\)个特征。压缩后的数据为\(\mathbf{Z=XP} \in \mathbf{R}^{n\times k}\), 有\(k\)个特征(feature)。</p>

<p>那么找到的这\(k\)个特征，有什么好的约束呢？<br/>
（Variance/Covariance constraints）</p>

<ul>
<li>这k个特征无关，也就是说协相关矩阵除对角线以外的元素全部为0</li>
<li>应该根据特征的方差(variance)选择，越大越好。因为variance越大，越能代表feature。也就是说应该选择协相关矩阵对角元素大的feature。</li>
</ul>

<p>所以 \(\mathbf{P}\)应该等于X的协方差矩阵的最大\(k\)个特征向量。</p>

<p>协方差矩阵的分布式求解方法见本博客<a href="http://larryim.cc/covariance_spark.html">Covariance Matrix and its solution in Spark</a></p>

<p>下面是特征分解的基础知识，可以在线性代数课本上找到：</p>

<p>特征分解(Eigendecomposition)是将矩阵分解为由特征值和特征向量表示矩阵之积的方法。</p>

<p>令 \(A\)是一个\(N\times N\)的方阵，且有\(N\)个线性无关的特征向量\(q_i(i=1,...,N)\)。这样，A可以被分解为<br/>
\[\mathbf{A=Q\Lambda Q}^{-1}\]<br/>
其中\(\mathbf{Q}\)是\(N\times N\)的方阵，且其第\(i\)列为\(A\)的特征向量\(q_i\)。\(\mathbf{\Lambda}\)是对角矩阵，其对角线上的元素为对应的特征值，也即\(\Lambda_{ii}=\lambda_i\).</p>

<p>那么，怎么样选择\(k\)的大小呢？一般认为保留99%或95%的variance. 由于协方差矩阵的对角元素就是对应特征向量的特征值，又是variance，所以我们选择k个对角元素，保留所要求的variance:</p>

<p>\[\text{find} \min k \quad \text{s.t.} \frac{\sum^k_{i=1}\lambda_i}{\sum^k_{i=1}\lambda_i} &gt; 99\%\]</p>

<h2 id="toc_0">PCA in Spark</h2>

<p>在python 中使用 <code>numpy.linalg.eigh</code>计算特征值和特征向量.</p>

<p>基本步骤如下：</p>

<ul>
<li>计算协方差矩阵 <code>estimateCovariance()</code></li>
<li>计算主成分和对应方差 <code>pca()</code></li>
<li>计算保留的成分比例<code>varianceExplained()</code></li>
</ul>

<pre><code class="language-Python">def estimateCovariance(data):
    &quot;&quot;&quot;Compute the covariance matrix for a given rdd.

    Args:
        data (RDD of np.ndarray):  An `RDD` consisting of NumPy arrays.

    Returns:
        np.ndarray: A multi-dimensional array where the number of rows and columns both equal the
            length of the arrays in the input `RDD`.
    &quot;&quot;&quot;
    mean = data.mean()
    normalized = data.map(lambda x: x-mean)
    return normalized.map(lambda x: np.outer(x, x)).sum()/data.count()
    
def pca(data, k=2):
    &quot;&quot;&quot;Computes the top `k` principal components, corresponding scores, and all eigenvalues.


    Args:
        data (RDD of np.ndarray): An `RDD` consisting of NumPy arrays.
        k (int): The number of principal components to return.

    Returns:
        tuple of (np.ndarray, RDD of np.ndarray, np.ndarray): A tuple of (eigenvectors, `RDD` of
            scores, eigenvalues).  Eigenvectors is a multi-dimensional array where the number of
            rows equals the length of the arrays in the input `RDD` and the number of columns equals
            `k`.  The `RDD` of scores has the same number of rows as `data` and consists of arrays
            of length `k`.  Eigenvalues is an array of length d (the number of features).
    &quot;&quot;&quot;
    cov = estimateCovariance(data)
    eigVals, eigVecs = eigh(cov)
    inds = np.argsort(eigVals)[::-1]
    topkComponent = eigVecs[:,inds[0:k]]
    scores = data.map(lambda x: np.dot(x, topkComponent))
    # Return the `k` principal components, `k` scores, and all eigenvalues
    return (topkComponent, scores, eigVals[inds])
    
    
def varianceExplained(data, k=1):
    &quot;&quot;&quot;Calculate the fraction of variance explained by the top `k` eigenvectors.

    Args:
        data (RDD of np.ndarray): An RDD that contains NumPy arrays which store the
            features for an observation.
        k: The number of principal components to consider.

    Returns:
        float: A number between 0 and 1 representing the percentage of variance explained
            by the top `k` eigenvectors.
    &quot;&quot;&quot;
    components, scores, eigenvalues = pca(data)
    return sum(eigenvalues[0:k])/sum(eigenvalues)
</code></pre>

<h2 id="toc_1">应用</h2>

<p>斑马鱼(zebrafish)大脑的响应<a href="http://larryim.cc/ML_lab5_pca_student.html">可视化</a>。</p>

<h2 id="toc_2">Reference</h2>

<ol>
<li>Machine Learning Course from Coursera. Andrew Ng</li>
<li>CS190: Scalable Machine Learning</li>
</ol>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/11/28</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html'>机器学习</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_1.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="http://or9a8nskt.bkt.clouddn.com/figure.jpeg" /></div>
            
                <h1>techlarry</h1>
                <div class="site-des">他山之石，可以攻玉</div>
                <div class="social">









<a target="_blank" class="github" target="_blank" href="https://github.com/techlarry" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:wang.zhen.hua.larry@gmail.com" title="Email">Email</a>
  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Leetcode.html"><strong>Leetcode</strong></a>
        
            <a href="C/C++.html"><strong>C/C++</strong></a>
        
            <a href="Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html"><strong>Python数据结构与算法</strong></a>
        
            <a href="Python%E7%89%B9%E6%80%A7.html"><strong>Python特性</strong></a>
        
            <a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html"><strong>机器学习</strong></a>
        
            <a href="Python%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96.html"><strong>Python科学计算三维可视化</strong></a>
        
            <a href="English.html"><strong>English</strong></a>
        
            <a href="Computer%20System.html"><strong>Computer System</strong></a>
        
            <a href="Deep%20Learning.html"><strong>Deep Learning</strong></a>
        
            <a href="Latex.html"><strong>Latex</strong></a>
        
            <a href="Linux%20%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html"><strong>Linux 系统编程</strong></a>
        
            <a href="%E6%95%B0%E6%8D%AE%E5%BA%93.html"><strong>数据库</strong></a>
        
            <a href="Tensorflow.html"><strong>Tensorflow</strong></a>
        
            <a href="Big%20Data.html"><strong>Big Data</strong></a>
        
            <a href="%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB.html"><strong>文献阅读</strong></a>
        
            <a href="Tools.html"><strong>Tools</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="develop_tools.html">Develop tools</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="C_plus_plus_ostream.html">C++ Ostream</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="introduction_to_computer_system_CMU.html">CMU 213 Introduction to Computer Systems</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="nand2tetris.html">Nand2Tetris: The elements of computing systems</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="PCA.html">PCA基础及在Spark中的应用</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    <script src="asset/chart/all-min.js"></script><script type="text/javascript">$(function(){    var mwebii=0;    var mwebChartEleId = 'mweb-chart-ele-';    $('pre>code').each(function(){        mwebii++;        var eleiid = mwebChartEleId+mwebii;        if($(this).hasClass('language-sequence')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = Diagram.parse($(this).text());            diagram.drawSVG(eleiid,{theme: 'simple'});        }else if($(this).hasClass('language-flow')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = flowchart.parse($(this).text());            diagram.drawSVG(eleiid);        }    });});</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
