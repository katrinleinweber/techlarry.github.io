<!doctype html>
<html class="no-js" lang="en">
<script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?fdc936c9f5a3b72177541183cdeb8cb3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Python编程技巧 - techlarry
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="techlarry" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:larryim.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        <li id=""><a target="_self" href="about.html">About</a></li>
        
        <li id=""><a target="_self" href="category.html">Category</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="http://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; techlarry</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
       
       <li><a href="index.html">HOME</a></li>
    <li><a href="archives.html">Archives</a></li>
    <li><a href="about.html">ABOUT</a></li>

    <li><label>Categories</label></li>

        
            <li><a href="Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html">Python数据结构与算法</a></li>
        
            <li><a href="Python%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7.html">Python编程技巧</a></li>
        
            <li><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html">机器学习</a></li>
        
            <li><a href="Python%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96.html">Python科学计算三维可视化</a></li>
        
            <li><a href="Linux%20%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html">Linux 系统编程</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="14973620419454.html">
                
                  <h1>魔法方法(一)：自定义序列</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>Python中的魔法方法可以理解为对类中的内置方法的重载。</p>

<h2 id="toc_0">自定义序列</h2>

<p>有许多办法可以让Python类表现得像是内建序列类型(字典，元组，列表，字符串等)。</p>

<h3 id="toc_1">预备知识</h3>

<p>协议类似某些语言中的接口，里面包含的是一些必须实现的方法。在Python中，协议完全是非正式的，也不需要显式的声明，事实上，它们更像是一种参考标准。</p>

<p>在Python中实现自定义容器类型需要用到一些协议。首先，不可变容器类型有如下协议：想实现一个不可变容器，你需要定义 <code>__len__</code> 和 <code>__getitem__</code> (后面会具体说明）。可变容器的协议除了上面提到的两个方法之外，还需要定义 <code>__setitem__</code> 和 <code>__delitem__</code> 。最后，如果你想让你的对象可以迭代，你需要定义 <code>__iter__</code> ，这个方法返回一个迭代器。迭代器必须遵守迭代器协议，需要定义 <code>__iter__</code> （返回它自己）和 <code>next</code> 方法。</p>

<h3 id="toc_2">容器背后的魔法方法</h3>

<ul>
<li><p><code>__len__(self)</code><br/>
返回容器的长度，可变和不可变类型都需要实现。</p></li>
<li><p><code>__getitem__(self, key)</code><br/>
定义对容器中某一项使用 self[key] 的方式进行读取操作时的行为。这也是可变和不可变容器类型都需要实现的一个方法。它应该在键的类型错误式产生 <code>TypeError</code> 异常，同时在没有与键值相匹配的内容时产生 <code>KeyError</code> 异常。</p></li>
<li><p><code>__setitem__(self, key)</code><br/>
定义对容器中某一项使用 self[key] 的方式进行赋值操作时的行为。它是可变容器类型必须实现的一个方法，同样应该在合适的时候产生 <code>KeyError</code> 和 <code>TypeError</code> 异常。</p></li>
<li><p><code>__iter__(self, key)</code><br/>
它应该返回当前容器的一个迭代器。迭代器以一连串内容的形式返回，最常见的是使用<code>iter()</code>函数调用，以及在类似 for x in container: 的循环中被调用。迭代器是他们自己的对象，需要定义 <code>__iter__</code>方法并在其中返回自己。</p></li>
<li><p><code>__reversed__(self)</code><br/>
定义了对容器使用<code>reversed()</code>内建函数时的行为。它应该返回一个反转之后的序列。当你的序列类是有序时，类似列表和元组，再实现这个方法，</p></li>
<li><p><code>__contains__(self, item)</code><br/>
<code>__contains__</code>定义了使用<code>in</code>和<code>not in</code>进行成员测试时类的行为。你可能好奇为什么这个方法不是序列协议的一部分，原因是，如果<code>__contains__</code>没有定义，Python就会迭代整个序列，如果找到了需要的一项就返回<code>True</code>。</p></li>
<li><p><code>__missing__(self ,key)</code><br/>
<code>__missing__</code>在字典的子类中使用，它定义了当试图访问一个字典中不存在的键时的行为（目前为止是指字典的实例，例如我有一个字典 d ， “george” 不是字典中的一个键，当试图访问 d[“george’] 时就会调用 d.__missing__(“george”))。</p></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/13</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7.html'>Python编程技巧</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14973464173252.html">
                
                  <h1>Hash table and Python dictionary</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>One of the most useful Python collections is the dictionary, which is an associative data type where you can store key-data pairs. It is implemented using <strong>hash tables</strong>(哈希表).</p>

<p><strong>Hash table</strong> (哈希表) is a collection of items which are stored in such a way as to make it easy to find item. Each position of the hash table, often called a <strong>slot</strong>, can hold an item and is named by an integer value starting at 0. The mapping between an item and the slot where that item belongs in the hash table is called the <strong>hash function</strong>(哈希函数). A <strong>perfect hash function</strong> maps every items into a unique slot. When two items hash to the same slot, <strong>collision</strong> happens. And a systematic method, which called <strong>collision resolution</strong>, for placing the second item in the hash table must be put forward.</p>

<h2 id="toc_0">Direct-address tables</h2>

<p>If the number of possible keys is small and they are unique, direct-address tables (直接寻址表) can be used. Each slot corresponds to a unique key.</p>

<pre><code class="language-python">
Insert(T,x)
    T[key(x)] = x
    
Search(T,x)
    return(T[key(x)])
    
Delete(T,x)
    T[key(x)] = NIL
</code></pre>

<p><img src="media/14973464173252/14973484465039.gif" alt="nameasdfasfas"/></p>

<p>The range of the key determines the size of the direct address table and may be too large to be practical. For instance, it&#39;s not likely that you&#39;ll be able to use a direct address table to store elements which have arbitary 32-but integers as their keys for a few years yet.</p>

<h2 id="toc_1">Hash function</h2>

<p><code>Remainder method</code> simply takes an item and divides it by the table size, returning the remainder as its hash value, i.e. \(h(item)=item\%11\)</p>

<p><code>Folding method</code> begins by dividing the item into equal size pieces (the last piece may not be of equal size), and then added together to give the resulting hash value by extra step of dividing by the table size and keeping the remainder.</p>

<h2 id="toc_2">Collision Resolution</h2>

<p>Various techniques are used to manage collision:</p>

<ul>
<li>Chaining (链接法)</li>
<li>Open addressing (开放寻址法)

<ul>
<li>linear probing (线性探查)</li>
<li>quadratic probing (二次探查)</li>
</ul></li>
</ul>

<h3 id="toc_3">chaining</h3>

<p>Chaining(链接法) allows each slot to hold a reference to a collection of items. It allows many items to exist at the same location in the hash table.</p>

<p><img src="media/14973464173252/Screen%20Shot%202017-06-13%20at%206.16.40%20PM.png" alt="Screen Shot 2017-06-13 at 6.16.40 P"/></p>

<h3 id="toc_4">Open addressing</h3>

<p>In <strong>open addressing</strong>, all elements occupy the hash table itself. That is, each table entry contains either an element of the dynamic set or NIL. When searching for an element, we systematically examine table slots until either we find the desired element or we have ascertained that the element is not in the table. No lists and no elements are stored outside the table, unlike in chaining.</p>

<h4 id="toc_5">Linear probing</h4>

<p>One of the simplest re-hashing functions is +1(or -1) on a collision, i.e. look in the neighbouring slot in the table. It calculates new address extremely quickly.</p>

<p>A disadvantage to linear probing is the tendency for clustering: items become clustered in the table.</p>

<h4 id="toc_6">Quadratic probing</h4>

<p>Instead of using a constant &#39;skip&#39; value, quadratic probing using a rehash function that increments the hash value by 1,3,5,7,9 and so on. This means that if the first hash value is \(h\), the successive values are \(h+1\), \(h+4\),\(h+9\), \(h+16\) and so on.</p>

<h3 id="toc_7">Load factor</h3>

<p>Load factor (装载因子) is commonly denoted by \(\lambda = \frac{number\_of\_items}{table\_size}\).</p>

<p>The most important piece of information we need to analyze the use of a hash table is the load factor, \(\lambda\). Conceptually, if the load factor is small, then there is a lower chance of collisions.</p>

<p>For a successful search, using open addressing with linear probing, the average number of comparisons is approximately \(\frac{1}{2}(1+\frac{1}{1-\lambda})\) and an unsuccessful search gives \(\frac{1}{2}(1+(\frac{1}{1-\lambda})^2)\).</p>

<p>Using chaining, the average number of comparisons is \(1+\lambda/2\) for the successful case, and simply \(\lambda\) comparisons if the search is unsuccessful.</p>

<h2 id="toc_8"><code>Map</code> ADT</h2>

<p>Here, we try to define an abstract data type <code>map</code>, which is an unordered collections of associations between keys and values. The operation are given below:</p>

<ul>
<li><code>Map()</code> create a new, empty map. It returns an empty map collection.</li>
<li><code>put(key, val)</code> Add a new key-value pair to the map. If the key is already in the map then replace the old value with the new value.</li>
<li><code>get(key)</code> Given a key, return the values stored in the map or None otherwise.</li>
<li><code>del</code> Delete the key-value pair from the map using a statement of the form del map[key]</li>
<li><code>len()</code> Return the number of key-value pairs stored in the map</li>
<li><code>in</code> Return <code>True</code> for a statement of the form key in map, if the given key is in the map, <code>False</code> otherwise.</li>
</ul>

<p>Using two lists, <code>slots</code> which holds the key items, and <code>data</code> which holds the data values, we implements the <code>Map</code> ADT.</p>

<p><code>hash_function</code> implements the hash function by simple <code>remainder method</code>. The collision resolution is linear probing. The <code>put</code> function assumes that there will eventually be an empty slot unless the key is already present in the <code>self.slots</code></p>

<pre><code class="language-python">
class HashTable(object):
    &quot;&quot;&quot;
    Hash Table
    &quot;&quot;&quot;
    def __init__(self):
        self.size = 11
        self.slots = [None]*self.size
        self.data = [None]*self.size

    def hash_function(self, key, size):
        &quot;&quot;&quot;
        Hash function: simple remainder method
        &quot;&quot;&quot;
        return key%size

    def rehash(self, old_hash, size):
        &quot;&quot;&quot;
        Rehash function: linear probing, just add 1 every time
        &quot;&quot;&quot;
        return (old_hash+1)%size

    def put(self, key, data):
        &quot;&quot;&quot;
        Put data into table
        &quot;&quot;&quot;

        # generate a slot based on hash_function
        hash_value = self.hash_function(key, self.size)

        # check hash_value
        if self.slots[hash_value] is None:
            self.slots[hash_value] = key
            self.data[hash_value] = data
        else:
            
            # replace data
            if self.slots[hash_value] == key:
                self.data[hash_value] = data

            # re-hash until empty slots
            next_slot = self.rehash(hash_value, self.size)
            while self.slots[next_slot] is not None and self.slots[next_slot] != key:
                next_slot = self.rehash(next_slot, self.size)

            if self.slots[next_slot] is None:
                self.slots[next_slot] = key
                self.data[next_slot] = data
            else:
                self.data[next_slot] = data

    def get(self, key):
        start = self.hash_function(key, self.size)

        if self.slots[start] == key:
            return self.data[start]

        while self.slots[start] is not None:
            if self.slots[start] == key:
                return self.data[start]
            start = self.rehash(start, self.size)

        return False

    def __getitem__(self, key):
        return self.get(key)

    def __setitem__(self, key, data):
        self.put(key, data)

    def __len__(self):
        &quot;&quot;&quot;
        返回长度
        &quot;&quot;&quot;
        count = 0
        for item in self.slots:
            if item is not None:
                count +=1

        return count

    def __contains__(self, item):
        &quot;&quot;&quot;
        定义了使用in和not in进行成员测试时类的行为
        &quot;&quot;&quot;
        for key in self.slots:
            if key == item:
                return True

        return False




if __name__== &quot;__main__&quot;:
    h=HashTable()
    h.put(54, &quot;cat&quot;)
    print(len(h))
    h.put(26, &quot;dog&quot;)
    h.put(93, &quot;lion&quot;)
    h.put(17, &quot;tiger&quot;)
    h.put(77, &quot;bird&quot;)
    h.put(31, &quot;cow&quot;)
    h.put(44, &quot;goat&quot;)
    h.put(55, &quot;pig&quot;)
    h.put(20, &quot;chicken&quot;)
    print(h.slots)
    print(h.data)
    h[20] = &quot;duck&quot;  # replace
    print(h.data)
    print(len(h))
    print( 4 in h)
    print( 17 in h)
</code></pre>

<p>其中出现的魔法方法可以参见<a href="http://larryim.cc/14973620419454.html">Link</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/13</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7.html'>Python编程技巧</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14973218394741.html">
                
                  <h1>Python 导入模块</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/13</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7.html'>Python编程技巧</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14969929726510.html">
                
                  <h1>Python 类属性与实例属性</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>Python属于动态语言，类属性很好体现了python动态语言这一特性。<br/>
对于属性，通常可以通过类属性和实例属性的形式调用。<br/>
看一个例子：</p>

<pre><code class="language-python">class AAA():
    aaa = 10
    
obj1 = AAA()
obj2 = AAA()
print(obj1.aaa, obj2.aaa, AAA.aaa) # result: 10 10 10

obj1.aaa += 2
print(obj1.aaa, obj2.aaa, AAA.aaa) # result: 12 10 10

AAA.aaa += 4
print(obj1.aaa,obj2.aaa,AAA.aaa)  # result: 12 14 14
</code></pre>

<p>上例中，<code>AAA.aaa</code>就属于<strong>类属性</strong>形式，<code>obj1.aaa</code>属于<strong>实例属性</strong>的形式</p>

<h2 id="toc_0">属性查找机制</h2>

<p>Python中属性查找是一个向上查找的机制，具体可参考下图所示：<br/>
       <img src="media/14969929726510/Screen%20Shot%202017-06-09%20at%203.39.06%20PM.png" alt="Screen Shot 2017-06-09 at 3.39.06 P"/></p>

<p>所以<br/>
* 当调用类属性<code>AAA.aaa</code>时，直接从<code>AAA</code>获取其属性<code>aaa</code><br/>
* 当调用实例属性<code>obj1.aaa</code>时，python按照由下到上的顺序查找属性，当<code>job1</code>和<code>job2</code>没有时，到类<code>AAA</code>中去查找</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/9</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7.html'>Python编程技巧</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14969760398302.html">
                
                  <h1>迭代器与生成器</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">可迭代对象</a>
<ul>
<li>
<a href="#toc_1">判断是否可以迭代</a>
</li>
</ul>
</li>
<li>
<a href="#toc_2">迭代器</a>
<ul>
<li>
<a href="#toc_3">手动访问迭代器中的元素</a>
</li>
<li>
<a href="#toc_4">将可迭代对象转换成迭代器</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">生成器</a>
<ul>
<li>
<a href="#toc_6">生成器表达式</a>
</li>
<li>
<a href="#toc_7">生成器函数</a>
</li>
<li>
<a href="#toc_8">next()方法运行流程</a>
</li>
<li>
<a href="#toc_9">send()方法</a>
</li>
</ul>
</li>
</ul>


<p>迭代是Python中最强有力的特性之一。</p>

<h2 id="toc_0">可迭代对象</h2>

<p>迭代是访问集合元素的一种方式。迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p>

<p>以直接作用于for循环的数据类型有以下几种：</p>

<p>一类是集合数据类型，如list, tuple, dict, set, str等；<br/>
一类是generator,包括生成器和带yield的生成器函数(generator function).</p>

<p>这些可以直接作用于for循环的对象统称为可迭代对象：<code>Iterable</code></p>

<h3 id="toc_1">判断是否可以迭代</h3>

<p>可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterable</code>对象：</p>

<pre><code class="language-python">from collections import Iterable

isinstance([], Iterable)
</code></pre>

<h2 id="toc_2">迭代器</h2>

<p>可以被<code>next()</code>函数调用并不断返回下一个值的对象称为迭代器：Iterator。</p>

<h3 id="toc_3">手动访问迭代器中的元素</h3>

<p>要手动访问可迭代对象中的元素，可以使用<code>next()</code>函数，然后自己编写代码来捕获<code>StopIteration</code>异常。例如，下面这个例子采用手工方式从文件中读取文本行：</p>

<pre><code class="language-python"># 打印hosts文件
with open(&#39;/etc/hosts&#39;) as f:
    try:
        while True:
            line = next(f)
            print(line, end=&#39;&#39;)
    except: StopIteration:
        pass
</code></pre>

<p>可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterator</code>对象：</p>

<pre><code class="language-python">from collections import Iterator
isinstance((x for x in ragne(10)), Iterator)
</code></pre>

<h3 id="toc_4">将可迭代对象转换成迭代器</h3>

<p>把list, dict, str等可迭代对象变成迭代器，可以使用<code>iter()</code>函数</p>

<pre><code class="language-python">&gt;&gt;&gt; a = [11,22,33,44]
&gt;&gt;&gt; type(a)
&lt;class &#39;list&#39;&gt;
&gt;&gt;&gt; b=iter(a)
&gt;&gt;&gt; b
&lt;list_iterator object at 0x109ba3278&gt;
</code></pre>

<h2 id="toc_5">生成器</h2>

<p>如果列表元素可以按照某种算法推算出来，从而节省大量空间，即保存计算生成的方式，当需要时才生成。</p>

<p>生成器可以通过next()获得生成器的下一个返回值。</p>

<p>生成器的特点：<br/>
1. 节约内存<br/>
2. 迭代到下一次的调用时，所使用的参数都是第一次所保留下的</p>

<h3 id="toc_6">生成器表达式</h3>

<p><code>生成器表达式(generator expression)</code>: An expression that returns an iterator.</p>

<pre><code class="language-python">&gt;&gt;&gt;&gt; a = ( x for x in range(1,100))
&gt;&gt;&gt;&gt; a
&gt;&gt;&gt;&gt; &lt;generator object &lt;genexpr&gt; at 0x10ce60f10&gt; # 生成器表达式
</code></pre>

<h3 id="toc_7">生成器函数</h3>

<p>如果想实现一种新的迭代模式，可使用<code>生成器函数</code>来定义。函数中只要出现了<code>yield</code>语句就会讲其转变成一个生成器。一旦执行到<code>yield</code>语句，生成器函数返回，迭代停止。</p>

<pre><code class="language-python">def fib(times):
     &quot;&quot;&quot;
     斐波那契数列
     &quot;&quot;&quot;
     
     n =0
     a,b = 0,1
     while n&lt; times:
        yield b    #与函数的唯一区别是yield语句
        a,b = b, a+b
        n+=1
     return &#39;done&#39;

for n in fib(5):
    print(n)
</code></pre>

<h3 id="toc_8">next()方法运行流程</h3>

<p>当第一次调用生成器的<code>next</code>方法时，生成器开始执行生成器函数，从第一行代码开始执行，一直执行到<code>yield</code>语句后，生成器函数返回<code>yield</code>表达式的值。之后每一次调用生成器的<code>next</code>方法时，生成器从<code>yield</code>语句的下一句开始执行，直到再次遇到<code>yield</code>语句返回。</p>

<h3 id="toc_9">send()方法</h3>

<p>生成器对象首先是一个迭代器，但比一般迭代器对象多了一些方法，包括<code>send()</code>,<code>throw()</code>,<code>close()</code>方法；这些方法主要用与生成器对象的交互。</p>

<p>对于生成器，使用<code>send()</code>时，第一次需要<code>send(None)</code>，因为没有<code>yield</code>语句来接受参数。（<code>yield</code>执行完就跳出，对应变量没有赋值，看下面的例子）</p>

<p><code>send()</code>方法和<code>next()</code>方法类似，不同的是<code>send()</code>可以向生成器传参数。当<br/>
第一次调用生成器的<code>send()</code>方法时，从生成器函数的第一行代码开始执行，一直执行到yield语句后，生成器函数返回。注意这个过程中，变量一直没有赋值。当下一次运行时，变量才赋值，赋值的值来源于这一次的<code>send()</code>方法（不是上一次！而且第一次都是<code>None</code>），但并不执行yield部分，直到再次遇到<code>yield</code>语句返回。</p>

<pre><code class="language-python">&gt;&gt;&gt; def gen():
...     while True:
...         s = yield
...         print(s)
...
&gt;&gt;&gt; g = gen()
&gt;&gt;&gt; g.send()
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: send() takes exactly one argument (0 given)
&gt;&gt;&gt; g.send(None)  # 第一次需要传入参数None
&gt;&gt;&gt; g.send(&#39;Kiss&#39;) # 将参数赋值给变量s
Kiss
</code></pre>

<p><strong>注意： 不能将一个非None的值传给初始的生成器</strong></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/9</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7.html'>Python编程技巧</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14969731064895.html">
                
                  <h1>列表</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">列表生成式</h2>

<p>列表生成式,即List Comprehensions,Python内置的非常简单却强大的可以用来创建list的生成式。</p>

<p>例子</p>

<pre><code class="language-python">&gt;&gt;&gt;&gt; a = [ i for i in range(1,19)]
&gt;&gt;&gt;&gt; b = [i for i in ragne(10) if i%2 == 0]
&gt;&gt;&gt;&gt; c = [i for i in range(3) for j in range(2)]
&gt;&gt;&gt;&gt; d = [(i,j) for i in range(3) for j in range(2)]
</code></pre>

<h3 id="toc_1">range的风险</h3>

<pre><code class="language-python">&gt;&gt;&gt; range(1,1000000000)
</code></pre>

<p>内存空间太大，但在python3中已经解决: 在需要时，才生成</p>

<h2 id="toc_2">列表去重</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/9</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7.html'>Python编程技巧</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14969760599335.html">
                
                  <h1>作用域</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">命名空间</h2>

<p>命名空间就是生效的范围</p>

<h2 id="toc_1">全局，局部</h2>

<p>查看局部变量</p>

<pre><code class="language-python">&gt;&gt;&gt;&gt; locals() 
</code></pre>

<p>查看全局变量</p>

<pre><code class="language-python">&gt;&gt;&gt;&gt; globals() 
</code></pre>

<h2 id="toc_2">LEGB规则</h2>

<p>python 使用<code>LEGB</code>的顺序来查找一个符号对应的对象</p>

<p>locals-&gt; enclosing function-&gt;globals-&gt;builtins</p>

<ul>
<li>locals, 当前所在命名空间（如函数、模块），函数的参数也属于命名空间中的变量</li>
<li>enclosing，外部嵌套函数的命名空间（闭包中常见）</li>
<li>globals, 全局变量，函数定义所在模块的命名空间</li>
<li>builtins, 内建模块的命名空间</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/6</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7.html'>Python编程技巧</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14969760531704.html">
                
                  <h1>python是动态语言</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>C语言是静态语言，运行之前需要先编译，不允许在运行过程中修改代码。</p>

<p>动态编程语言，在运行时可以改变其结果的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。</p>

<h2 id="toc_0">运行的过程中给实例/类添加属性(实例属性/类属性)</h2>

<pre><code class="language-python">class Person(object):
    def __init__(self, name=None, age=None):
             self.name = name
             self.age = age
P = Person(&#39;X man&#39;,&#39;24&#39;)
P.sex = &#39;male&#39;  # 给对象添加属性
Person.sex = &#39;female&#39; #给类添加属性
</code></pre>

<h2 id="toc_1">运行的过程中给实例/类添加方法</h2>

<p>给实例添加方法时，一般需使用<code>MethodType</code>函数。</p>

<pre><code class="language-python">class Person(object):
    def __init__(self, name=None, age=None):
             self.name = name
             self.age = age
    def eat(self):
        print(&#39;---%s is eating&#39;%self.name)
        
def run(self):
    print(&#39;---%s is running&#39;%self.name)
    
p1= Person(&#39;P1&#39;, 10)
p1.eat()
p1.run = run
#虽然p1对象中 run属性已经指向了第10行的函数，但是这句代码还不正确
#因为run属性的函数是后来添加的，即p1.run()的时候，并没有把p1当作第1个参数

import types
p1.run = types.MethodType(run,p1)
p1.run()
</code></pre>

<p>但是静态方法(static method)和类方法(class method)可以直接添加</p>

<pre><code class="language-python">@staticmethod
def test():
    print(&quot;---static method-----&quot;)
p1.test = test
p1.test()

@classmethod
def printNum(cls):
    print(&#39;----class method---&#39;)
    
Person.printNum = printNum
Person.printNum()
</code></pre>

<h2 id="toc_2">限制属性 __slots__</h2>

<p>定义一个特殊的__slot__变量，限制class实例能添加的属性</p>

<pre><code class="language-python">class Person(object):
    __slots__=(&quot;name&quot;,&quot;age&quot;)

p = Person()
p.name = &quot;老王&quot;
p.age = 10
p.score = 100
&gt;&gt;&gt;&gt; AttributeError: &#39;Person&#39; object has no attribute &#39;score&#39;
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/6</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7.html'>Python编程技巧</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14970764330712.html">
                
                  <h1>属性@property的使用</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h3 id="toc_0">为什么要使用<code>getter</code>和<code>setter</code>方法</h3>

<p>在绑定属性时，如果可以直接设置属性，虽然写起来很简单，但是没有办法检查参数，并且可以随意更改参数。</p>

<pre><code class="language-python">s = People()
s.salary = -1000
</code></pre>

<p>这显然不符合逻辑。为了限制salary的范围，可以通过一个<code>setSalary</code>方法来设置工资，再通过一个<code>getSalary</code>来获得工资，这样在<code>setSalary</code>方法里，就可以检查参数。</p>

<h3 id="toc_1">私有属性添加<code>getter</code>和<code>setter</code>方法</h3>

<pre><code class="language-python">class People(object):
    def __init__(self):
        self.__salary = 0
    def getSalary(self):
        return self.__salary
    def setSalary(self, value):
        if not isinstance(value, int):
            raise ValueError(&#39;Money must be an integer!&#39;)
        if value &lt;0 or value &gt; 10000:
            raise ValueError(&#39;Money must between 0~10000!&#39;)
        
        self.__salary = value
</code></pre>

<h3 id="toc_2">注意点</h3>

<p>t.num到底是调用<code>getter</code>还是<code>setter</code>，要根据实际的场景来判断，</p>

<ol>
<li>如果是给t.num赋值，那么一定调用<code>setNum()</code></li>
<li>如果是获取t.num的值，那么久一定调用<code>getNum()</code></li>
</ol>

<h3 id="toc_3">@property装饰器</h3>

<p>但是直接调用<code>getter()</code>和<code>setter()</code>比较复杂。Python内置的<code>@property</code>装饰器可以把这两种方法转化为属性进行调用。看一下例子：</p>

<pre><code class="language-python">class People(object):
    def __init__(self):
        self.__salary = 0
    
    @property
    def salary(self):
        return self.__salary
    
    @salary.setter
    def salary(self, value):
        if not isinstance(value, int):
            raise ValueError(&#39;Salary must be an integer!&#39;)
        if value &lt;0 or value &gt; 10000:
            raise ValueError(&#39;Salary must between 0~10000!&#39;)
        
        self.__salary = value
        
    @property
    def tax(self):
        self.__tax = self.__salary*0.1
        return self.__tax
</code></pre>

<p>当不定义setter方法时，那么就定义了一个只读属性(例子中<code>tax</code>属性是只读属性)。</p>

<p>@property 成为属性函数，可以对属性赋值时做必要的检查，并保证代码的清晰短小，主要有2个作用：</p>

<ol>
<li>将方法转换为只读</li>
<li>重新实现一个属性的设置和读取方法，可做边界判定</li>
</ol>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/5/10</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7.html'>Python编程技巧</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14969760733622.html">
                
                  <h1>Python 高级</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">模块重新导入</h2>

<p>模块导入： import xxx, from xxx import xxxx<br/>
增加路径 <br/>
<code>python<br/>
import sys<br/>
sys.path.append(path)<br/>
</code><br/>
模块重新导入<br/>
<code>python<br/>
from imp import reload<br/>
reload(module name)<br/>
</code></p>

<h2 id="toc_1">02 模块循环导入问题</h2>

<p>不可以循环导入，不能在模块之间相互调用</p>

<p>怎样避免循环导入：导入语句放在后面需要导入时再倒入，例如放在函数体内导入</p>

<h2 id="toc_2">03/04 ==与is的区别</h2>

<ul>
<li>== 判断值是否相等</li>
<li>Is  id(a), id(b)是否相等，<strong>比较两个引用是否指向了同一个对象（引用比较）</strong></li>
</ul>

<h2 id="toc_3">05-07 深拷贝与浅拷贝</h2>

<ul>
<li>浅拷贝是一个对象的顶层拷贝，拷贝了引用，并没有拷贝内容
= 就是浅拷贝</li>
<li>深拷贝是对于一个对象所有层次的拷贝（递归）
<code>python
import copy
c = copy.deepcopy(a)
</code>
copy.deepcopy深拷贝会把引用都拷贝出来（递归）
copy.copy() 
使用copy模块的copy功能的时候，它会根据当前拷贝的数据类型是可变类型还是不可变类型，有不同的处理方式：如果拷贝可变类型，只能识别第一层拷贝；如果拷贝不可变类型，是浅拷贝</li>
</ul>

<h2 id="toc_4">08 不同进制的讲解</h2>

<p>略</p>

<h2 id="toc_5">09 原码，反码，补码，进制的转换</h2>

<p>有符号数和无符号数的概念<br/>
规则：把二进制数中的最高位（最左边的那位）用作符号位</p>

<p>对于有符号数，最高位被计算机系统规定为符号位（0为正，1为负）<br/>
对于无符号数，最高位被计算机系统规定为数据位</p>

<p>数字在计算机中，是用二进制补码的形式来保存的，因此-1+1需要按照补码进行相加才是正确的结果</p>

<p>1）如何计算补码？<br/>
正数：原码=反码=补码<br/>
负数：反码=符号位不变，其他位取反<br/>
      补码=反码+1<br/>
溢出：越界<br/>
    2) 从补码转回原码<br/>
    负数补码转换原码的规则：<br/>
    原码=补码的符号位不变，数据位取反，尾+1</p>

<p>进制的转换 bin, int, oct, hex</p>

<p>0b 二进制<br/>
0o八进制<br/>
0x十六进制</p>

<p>转换成十进制 int(&quot;&quot;,16/8/2)</p>

<h2 id="toc_6">10 位运算</h2>

<p>把一个数的各位整体向左移动一个位，就变成原来的2倍</p>

<h3 id="toc_7">位运算的介绍</h3>

<ul>
<li>&amp; 按位于</li>
<li>|按位或</li>
<li><sup>按位异或</sup></li>
<li>～按位取反</li>
<li>&lt;&lt;按位左移 &gt;&gt;按位右移</li>
</ul>

<h3 id="toc_8">位运算</h3>

<ul>
<li>按位与： 全1才1否则0：只有对应的两个二进位均为1时，结果位才为1，否则为0</li>
<li>按位或：有1就1： 只要对应的二个二进位有一个位1时，结果位就为1，否则为0</li>
<li>按位异或：不同为1: 当对应的二进位不相同时，结果为1，否则为0</li>
</ul>

<h2 id="toc_9">12 私有化</h2>

<p>属性的名字前面加上下划线，属于私有属性，不能从外部调用的<br/>
方法：setNum(), getNum() 设置两个方法，一个设置属性，一个获取数据</p>

<ul>
<li>xx: 公有变量</li>
<li>_xx: 单前置下划线，私有化属性或方法，from somemodule import * 禁止导入，类对象和子类可以访问</li>
<li>__xx__: 双前后下划线，用于名字空间的魔法对象或属性。例如：__init__</li>
<li>__xx: 双前置下划线，私有，无法在外部直接访问（名子重整所以访问不到）</li>
<li>xx_: 单后置下划线，用于避免与python关键词的冲突</li>
</ul>

<p>通过name mangling （名字重整）,目的是防止类意外重写基类的方法或者属性：__classname__privateatribute</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/4/9</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7.html'>Python编程技巧</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14969760668045.html">
                
                  <h1>闭包，装饰器</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h3 id="toc_0">函数引用</h3>

<pre><code class="language-python">&gt;&gt;&gt; def test():
...     print(&#39;lala&#39;)
...
&gt;&gt;&gt; test()
lala
&gt;&gt;&gt; test
&lt;function test at 0x109a51950&gt; 

&gt;&gt;&gt; b = test  # b指向函数体test

&gt;&gt;&gt; b
&lt;function test at 0x109a51950&gt;

&gt;&gt;&gt; b()  # 通过引用调用函数
lala
</code></pre>

<h3 id="toc_1">闭包</h3>

<p>在函数内部再定义一个函数，并且这个函数用到了外边函数的变量，那么将这个函数以及用到的一些变量统称为闭包</p>

<pre><code class="language-python">def test(number):
  def test_in(number_in):
    print(&quot;in test_in, number_in is %d&quot;%number_in)
    return number+number_in
  return test_in

ret = test(100)  # ret 指向函数体
ret(1)  # 调用函数
</code></pre>

<p>闭包的实际例子：</p>

<pre><code class="language-python">def line_conf(a,b):
  def line(x):
    return a*x + b
  return line

line1 = line_conf(1,1)
line2 = line_conf(4,5)

print(line1(5))
print(line2(5))
</code></pre>

<ol>
<li>闭包又花了变量，原来需要类对象完成的工作，闭包也可以完成</li>
<li>由于必报引用了外部函数的局部变量，则外部函数的局部变量没有及时释放，消耗内存</li>
</ol>

<h2 id="toc_2">装饰器</h2>

<p>装饰器是程序开发中经常会用到的一个功能，用好了装饰器，开发效率如虎添翼。<br/>
* 只要python解释器执行到了装饰器代码部分，那么就会自动装饰，而不是等到调用的时候才装饰<br/>
* 有多个装饰器时，先执行后面的装饰</p>

<pre><code class="language-python">def w1(func):
  print(&#39;---正在装饰1-----&#39;)
  def inner():
    print(&#39;-----装在验证权限1------&#39;)
    func()
  return inner
  
def w2(func):
  print(&#39;---正在装饰2-----&#39;)
  def inner():
    print(&#39;-----装在验证权限2------&#39;)
    func()
  return inner

@w1
@w2
def f1():
  print(&quot;---f1---&quot;)

f1()

&gt;&gt;&gt;
---正在装饰2-----
---正在装饰1-----
-----装在验证权限1------
-----装在验证权限2------
---f1---
</code></pre>

<h3 id="toc_3">通用装饰器</h3>

<p>无参数、有参数、不定长参数、有返回值、无返回值 示例</p>

<pre><code class="language-python">def func(functionName):

  def func_in(*args, **kwargs):
    ret = functionName(*args, **kwargs)
    return ret
    
  return func_in
</code></pre>

<h3 id="toc_4">带有参数的装饰器</h3>

<p>同一个装饰器，在装饰不同函数时，起到不同的效果</p>

<pre><code class="language-python">def func_arg(arg):
    def func(functionName):
        def func_in():
            print(&quot;---记录日志-arg=%s--&quot;%arg)
            if arg==&quot;heihei&quot;:
                functionName()
                functionName()
            else:
                functionName()
        return func_in
    return func

#1. 先执行func_arg(&quot;heihei&quot;)函数,这个函数return 的结果是func这个函数的引用
#2. @func
#3. 使用@func对test进行装饰
@func_arg(&quot;heihei&quot;)
def test():
    print(&quot;--test--&quot;)

#带有参数的装饰器,能够起到在运行时,有不同的功能
@func_arg(&quot;haha&quot;)
def test2():
    print(&quot;--test2--&quot;)

test()
test2()
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/4/5</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7.html'>Python编程技巧</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="http://or9a8nskt.bkt.clouddn.com/figure.jpeg" /></div>
            
                <h1>techlarry</h1>
                <div class="site-des">他山之石，可以攻玉</div>
                <div class="social">










<a target="_blank" class="email" href="mailto:wang.zhen.hua.larry@gmail.com" title="Email">Email</a>
  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html"><strong>Python数据结构与算法</strong></a>
        
            <a href="Python%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7.html"><strong>Python编程技巧</strong></a>
        
            <a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html"><strong>机器学习</strong></a>
        
            <a href="Python%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96.html"><strong>Python科学计算三维可视化</strong></a>
        
            <a href="Linux%20%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html"><strong>Linux 系统编程</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="14985711297859.html">Machine Learning (3): Classification</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14985240916710.html">Python科学计算三维可视化</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14974355508816.html">MySql 数据库</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14974279917175.html">Python树(二)：二叉搜索树</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14973171257726.html">Python树(一)：二叉树和二叉堆</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2017
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    <script src="asset/chart/all-min.js"></script><script type="text/javascript">$(function(){    var mwebii=0;    var mwebChartEleId = 'mweb-chart-ele-';    $('pre>code').each(function(){        mwebii++;        var eleiid = mwebChartEleId+mwebii;        if($(this).hasClass('language-sequence')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = Diagram.parse($(this).text());            diagram.drawSVG(eleiid,{theme: 'simple'});        }else if($(this).hasClass('language-flow')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = flowchart.parse($(this).text());            diagram.drawSVG(eleiid);        }    });});</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
