<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  techlarry
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="techlarry" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:larryim.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        <li id=""><a target="_self" href="about.html">About</a></li>
        
        <li id=""><a target="_self" href="category.html">Category</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="http://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; techlarry</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        
        <li><a target="_self" href="about.html">About</a></li>
        
        <li><a target="_self" href="category.html">Category</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Leetcode.html">Leetcode</a></li>
        
            <li><a href="Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html">Python数据结构与算法</a></li>
        
            <li><a href="Python%E7%89%B9%E6%80%A7.html">Python特性</a></li>
        
            <li><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html">机器学习</a></li>
        
            <li><a href="Python%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96.html">Python科学计算三维可视化</a></li>
        
            <li><a href="English.html">English</a></li>
        
            <li><a href="%20%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA.html"> 理解计算机</a></li>
        
            <li><a href="Deep%20Learning.html">Deep Learning</a></li>
        
            <li><a href="Latex.html">Latex</a></li>
        
            <li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html">操作系统</a></li>
        
            <li><a href="Linux%20%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html">Linux 系统编程</a></li>
        
            <li><a href="%E6%95%B0%E6%8D%AE%E5%BA%93.html">数据库</a></li>
        
            <li><a href="Tensorflow.html">Tensorflow</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="Hash_Table_3_A_variant_of_2_Sum_Algorithm.html">
                
                  <h1>Hash Table (3): A variant of 2-Sum Algorithm</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>The goal of the arcticle is to implement a variant of the <code>2-SUM algorithm</code>.</p>

<p>The file contains 1 million integers, both positive and negative (repetitions exists!). This is your array of integers, with the \(i\)th row of the file specifying the \(i\)th entry of the array.</p>

<p>The task is to compute the number of target values \(t\) in the interval \([-10000,10000]\)(inclusive) such that there are distinct numbers \(x,y\) in the input file that satisfy \(x+y=t\). </p>

<h2 id="toc_0">Implementation</h2>

<p>The key process lies in the <code>hash function</code>, which might be set to appropriate small value based on the origin value:<br/>
\[\text{hash_function}= \frac{\text{number}}{\text{factor}}\]</p>

<p>The <code>factor</code> is selected based on the number of <code>slots</code> needed in the algorithm. i.e.<br/>
\[\frac{\text{the range of keys}}{\text{factor}}\approx \text{the number of slots} &lt; \text{the number of keys}\]</p>

<p>There, factor is \(\frac{\text{the number of key}}{2}\)</p>

<pre><code class="language-python">class HashTable(object):

    def __init__(self):

        self.size = 5000000
        self.slots = [set() for i in range(self.size)]
        self.data = set()

    def put(self, key, data):

        hash_value = self.hash_function(key)
        self.slots[hash_value].add(data)
        self.data.add(data)

    def hash_function(self, key):

        return key//(self.size//2)

    def get(self, key):
        &quot;&quot;&quot;
        there key == data
        &quot;&quot;&quot;
        slot = self.hash_function(key)
        if key in self.slots[slot]:
            return key
        else:
            return None

    def buildfromfile(self, textfile):

        with open(text_file, &#39;r&#39;) as infile:
            for line in infile.readlines():
                self.put(int(line), int(line))

    def two_sum_count(self):
        &quot;&quot;&quot;
        Compute the number of target values t in the interval[low, high] (inclusive),
        such that there are distinct numbers x, y that satisfy x+y = t
        &quot;&quot;&quot;
        sums = set()

        for key1 in self.data:
            left = self.hash_function(-key1-10000)
            right = self.hash_function(-key1+10000)

            for slot in self.slots[left:right+1]:

                for key2 in slot:

                    if 10000 &gt; key1 + key2 &gt; -10000:
                        sums.add(key1+key2)

        return len(sums)


if __name__ == &quot;__main__&quot;:

    # target files for counting
    text_file = &#39;two_sum.txt&#39;

    hashnumber = HashTable()
    hashnumber.buildfromfile(text_file)
    print(hashnumber.two_sum_count())
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/7/23</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Hash%20Table.html'>Hash Table</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="heap_median_maintenance.html">
                
                  <h1>Heap (2): Median Maintenance</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><strong>Problem Statement</strong>: The goal of the problem is to implement the <code>Median Maintenance</code> algorithm. The text file contains a list of the integers; you should treat this as a stream of numbers, arriving one by one. Letting \(x_i\) denote the \(i\)th number of the file, the \(k\)th median \(m_k\) is defined as the median of the numbers \(x_1,…,x_k\). (So, if \(k\) is odd, then \(m_k\) is \(((k+1)/2)\)th smallest number among \(x_1,…,x_k\); if \(k\) is even, then \(m_k\) is the \((k/2)\)th smallest number among \(x_1,…,x_k\).)</p>

<h1 id="toc_0">Solution</h1>

<p>We might use a max heap to represent elements that are less than the median, and a min heap to represent elements that are greater than the median.</p>

<p>After balancing the heaps, the number of elements in two heaps differs at most by 1. </p>

<pre><code class="language-python">Step 1: Add next item to one of the heaps

   if next item &lt; maxHeap root:
        add it to maxHeap
   else:
        add it to minHeap

Step 2: Balance the heaps (after this step heaps will be either balanced or
   one of them will contain 1 more item)

   if number of elements in one of the heaps &gt; the other by
   more than 1:
        remove the root element from the one containing more elements 
        and add to the other one

Step 3: Calculate the median:

   if the heaps contain equal amount of elements:
        median = root of maxHeap
   else:
        median = root of the heap with more elements
</code></pre>

<h2 id="toc_1">Implementation</h2>

<pre><code class="language-python">import doctest
import sys

class MinHeap(object):
    &quot;&quot;&quot;
    Min Heap
    &gt;&gt;&gt; bh = MinHeap()
    &gt;&gt;&gt; bh.buildHeap([9,5,14,18,-17,27,33,19,11,21])
    &gt;&gt;&gt; bh.findMin()
    -17
    &gt;&gt;&gt; bh.delMin()
    -17
    &gt;&gt;&gt; bh.list[1:]
    [5, 9, 14, 11, 21, 27, 33, 19, 18]
    &gt;&gt;&gt; bh.insert(-100)
    &gt;&gt;&gt; bh.delMin()
    -100
    &quot;&quot;&quot;

    def __init__(self):
        &quot;&quot;&quot;
        add self.list 0 with initialization in order to divide
        &quot;&quot;&quot;
        self.list = [-sys.maxsize]
        self.size = 0


    def insert(self, k):
        &quot;&quot;&quot;
        Insert element to the MinBinaryHeap
        &quot;&quot;&quot;
        self.list.append(k)
        self.size += 1
        self.perc_up(self.size)


    def findMin(self):
        &quot;&quot;&quot;
        Find the min element and return it
        &quot;&quot;&quot;
        return self.list[1]


    def delMin(self):
        &quot;&quot;&quot;
        Delete the min element
        and return it
        &quot;&quot;&quot;
        retrival = self.list[1]
        self.size -= 1
        self.list[1] = self.list[-1]
        self.list.pop()
        self.perc_down(1)

        return retrival


    def isEmpty(self):
        &quot;&quot;&quot;
        Return if the MinBinaryHeap is empty
        &quot;&quot;&quot;
        return self.size == 0

    def __len__(self):
        &quot;&quot;&quot;
        Magic Method: return the length of MinBinaryHeap
        &quot;&quot;&quot;
        return self.size


    def buildHeap(self, alist):
        &quot;&quot;&quot;
        Build a MinBinaryHeap from alist which is a collection of data
        &quot;&quot;&quot;
        self.list.extend(alist)
        self.size = len(alist)

        i = self.size//2
        while i &gt; 0:
            self.perc_down(i)
            i -= 1

    def perc_up(self, i):
        &quot;&quot;&quot;&quot;
        perc_up i
        &quot;&quot;&quot;
        while i//2&gt;0:
            if self.list[i] &lt; self.list[i // 2]:
                self.list[i], self.list[i // 2] = self.list[i // 2], self.list[i]
            i = i // 2

    def perc_down(self, i):
        &quot;&quot;&quot;
        perc down i
        &quot;&quot;&quot;
        while (i * 2) &lt;= self.size:
            mc = self.minChild(i)
            if self.list[i] &gt; self.list[mc]:
                self.list[i], self.list[mc] = self.list[mc], self.list[i]
            i = mc

    def minChild(self, i):
        &quot;&quot;&quot;
        find the min child
        &quot;&quot;&quot;
        if i * 2 + 1 &gt; self.size:
            return i * 2
        else:
            if self.list[i * 2] &lt; self.list[i * 2 + 1]:
                return i * 2
            else:
                return i * 2 + 1

    def __iter__(self):
        return iter(self.list[1:])


class MaxHeap(object):
    &quot;&quot;&quot;
    Max Heap
    &gt;&gt;&gt; bh = MaxHeap()
    &gt;&gt;&gt; bh.buildHeap([9,5,14,18,-17,27,33,19,11,21])
    &gt;&gt;&gt; bh.delMax()
    33
    &gt;&gt;&gt; bh.insert(100)
    &gt;&gt;&gt; bh.delMax()
    100
    &gt;&gt;&gt; len(bh)
    9
    &quot;&quot;&quot;

    def __init__(self):
        self.heap = MinHeap()

    def insert(self, k):
        self.heap.insert(-k)

    def delMax(self):
        return -self.heap.delMin()

    def buildHeap(self, alist):
        for i in range(len(alist)):
            alist[i] = -alist[i]
        self.heap.buildHeap(alist)

    def findMax(self):
        return -self.heap.findMin()

    def __len__(self):
        return self.heap.size

    def __iter__(self):
        for i in range(1, self.heap.size+1):
            yield -self.heap.list[i]


def median_maintenance(textfile):

    min_heap = MinHeap()  # &gt; medium
    max_heap = MaxHeap()  # &lt; medium

    medians = []
    count = 0

    with open(textfile) as infile:
        for line in infile:
            item = int(line)
            count += 1

            # Step 1: Add next item to one of the hepas
            # special case: initialize
            if count == 1:
                max_heap.insert(item)
            else:
                if item &lt; max_heap.findMax():
                    max_heap.insert(item)
                else:
                    min_heap.insert(item)

            # Step2: Balance the heap
            if abs(len(max_heap) - len(min_heap)) &gt; 1:
                if len(max_heap) &gt; len(min_heap):
                    min_heap.insert(max_heap.delMax())
                else:
                    max_heap.insert(min_heap.delMin())

            # Step3: calculate median
            if len(max_heap) == len(min_heap):
                median = max_heap.findMax()
            else:
                if len(max_heap) &gt; len(min_heap):
                    median = max_heap.findMax()
                else:
                    median = min_heap.findMin()

            medians.append(median)

            # test
            #for element in max_heap:
            #    print(element, end=&#39; &#39;)
            #for element in min_heap:
            #    print(element, end=&#39; &#39;)
            #print(&#39;total elem:&#39;,len(max_heap)+len(min_heap))


    return medians

if __name__ == &#39;__main__&#39;:
    # doctest.testmod(verbose=True)
    #textfile = &#39;SmallTest.txt&#39;
    textfile = &#39;Median.txt&#39;
    medians = median_maintenance(textfile)
    answer = sum(medians)%10000
    print(answer)
</code></pre>

<h2 id="toc_2">Resources</h2>

<ol>
<li><a href="https://stackoverflow.com/questions/14189540/python-topn-max-heap-use-heapq-or-self-implement">max heap implementation</a></li>
<li><a href="https://stackoverflow.com/questions/10657503/find-running-median-from-a-stream-of-integers">median maintenance</a></li>
</ol>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/7/21</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html'>Python数据结构与算法</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="binary_search_tree.html">
                
                  <h1>Python树(三)：Binary Search Tree</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>A <code>binary search tree</code>  is a tree that keys that are less than the parent are found in the left subtree, and keys that are greater than the parent are found in the right subtree.</p>

<p>Let \(x\) be a node in a binary search tree. If \(y\) is a node in the left subtree of \(x\), then \(y.key\le x.key\). If \(y\) is a node in the right subtree of \(x\), then \(y.key\le x.key\).</p>

<h2 id="toc_0">Implementation</h2>

<ul>
<li><code>Map()</code> Create a new, empty map.</li>
<li><code>put(key,val)</code> Add a new key-value pair to the map. If the key is already in the map then replace the old value with the new value.</li>
<li><code>get(key)</code> Given a key, return the value stored in the map or <code>None</code> otherwise.</li>
<li><code>del</code> Delete the key-value pair from the map using a statement of the form <code>del map[key]</code>.</li>
<li><code>len()</code> Return the number of key-value pairs stored in the map.</li>
<li><code>in</code> Return <code>True</code> for a statement of the form <code>key in map</code>, if the given key is in the map.</li>
</ul>

<p>To implement the binary search tree,  the method of <code>the nodes and references approached</code> similar to <code>binary tree</code>(<a href="http://larryim.cc/tree_2.html">Link</a>) The <code>BinarySearchTree</code> class has a reference to the <code>TreeNode</code> that is the root of the binary search tree. </p>

<h3 id="toc_1"><code>delete</code> method</h3>

<p>Once we’ve found the node containing the key we want to delete, there are three cases that we must consider:</p>

<ul>
<li>The node to be deleted has no children.</li>
<li>The node to be deleted has only one child.</li>
<li>The node to be deleted has two children.</li>
</ul>

<p>The first case is straightforward. If the current node has no children all we need to do is delete the node and remove the reference to this node in the parent. The code for this case is shown in here.</p>

<p>The second case is only slightly more complicated. If a node has only a single child, then we can simply promote the child to take the place of its parent. The code for this case is shown in the next listing. As you look at this code you will see that there are six cases to consider. Since the cases are symmetric with respect to either having a left or right child we will just discuss the case where the current node has a left child. The decision proceeds as follows:</p>

<ul>
<li>If the current node is a left child then we only need to update the parent reference of the left child to point to the parent of the current node, and then update the left child reference of the parent to point to the current node’s left child.</li>
<li>If the current node is a right child then we only need to update the parent reference of the left child to point to the parent of the current node, and then update the right child reference of the parent to point to the current node’s left child.</li>
<li>If the current node has no parent, it must be the root. In this case we will just replace the key, payload, leftChild, and rightChild data by calling the <code>replaceNodeData</code> method on the root.</li>
</ul>

<p>The third case is the most difficult case to handle. If a node has two children, then it is unlikely that we can simply promote one of them to take the node’s place. We can, however, search the tree for a node that can be used to replace the one scheduled for deletion. What we need is a node that will preserve the binary search tree relationships for both of the existing left and right subtrees. The node that will do this is the node that has the next-largest key in the tree. We call this node the <code>successor</code>, and we will look at a way to find the successor shortly. The successor is guaranteed to have no more than one child, so we know how to remove it using the two cases for deletion that we have already implemented. Once the successor has been removed, we simply put it in the tree in place of the node to be deleted.</p>

<h3 id="toc_2"><code>successor</code> Method</h3>

<p>The code to find the successor is a method of the <code>TreeNode</code> class. This code makes use of the same properties of binary search trees that cause an <code>inorder traversal</code> to print out the nodes in the tree from smallest to largest. There are three cases to consider when looking for the successor:</p>

<ul>
<li>If the node has a right child, then the successor is the smallest key in the right subtree.</li>
<li>If the node has no right child and is the left child of its parent, then the parent is the successor.</li>
<li>If the node is the right child of its parent, and itself has no right child, then the successor to this node is the successor of its parent, excluding this node.</li>
</ul>

<pre><code class="language-python">
class BinarySearchTree(object):

    def __init__(self):
        self.root = None
        self.size = 0

    def put(self, key, val):
        if self.root:
            self._put(key, val, self.root)
        else:
            self.root = TreeNode(key, val)
        self.size = self.size + 1

    def _put(self, key, val, currentNode):
        if key &lt; currentNode.key:
            if currentNode.hasLeftChild():
                self._put(key, val, currentNode.leftChild)
            else:
                currentNode.leftChild = TreeNode(key, val, parent=currentNode)
        else:
            if currentNode.hasRightChild():
                self._put(key, val, currentNode.rightChild)
            else:
                currentNode.rightChild = TreeNode(key, val, parent=currentNode)

    def __setitem__(self, k, v):
        self.put(k, v)

    def get(self, key):
        if self.root:
            res = self._get(key, self.root)
            if res:
                return res.payload
            else:
                return None
        else:
            return None

    def _get(self, key, currentNode):
        if not currentNode:
            return None
        elif currentNode.key == key:
            return currentNode
        elif key &lt; currentNode.key:
            return self._get(key, currentNode.leftChild)
        else:
            return self._get(key, currentNode.rightChild)

    def __getitem__(self, key):
        res = self.get(key)
        if res:
            return res
        else:
            raise KeyError(&#39;Error, key not in tree&#39;)

    def __contains__(self, key):
        if self._get(key, self.root):
            return True
        else:
            return False

    def length(self):
        return self.size

    def __len__(self):
        return self.size

    def __iter__(self):
        return self.root.__iter__()

    def delete(self, key):
        if self.size &gt; 1:
            nodeToRemove = self._get(key, self.root)
            if nodeToRemove:
                self.remove(nodeToRemove)
                self.size = self.size - 1
            else:
                raise KeyError(&#39;Error, key not in tree&#39;)
        elif self.size == 1 and self.root.key == key:
            self.root = None
            self.size = self.size - 1
        else:
            raise KeyError(&#39;Error, key not in tree&#39;)

    def __delitem__(self, key):
        self.delete(key)

    def remove(self, currentNode):
        if currentNode.isLeaf():  # leaf
            if currentNode == currentNode.parent.leftChild:
                currentNode.parent.leftChild = None
            else:
                currentNode.parent.rightChild = None
        elif currentNode.hasBothChildren():  # interior
            succ = currentNode.findSuccessor()
            succ.spliceOut()
            currentNode.key = succ.key
            currentNode.payload = succ.payload
        else:  # this node has one child
            if currentNode.hasLeftChild():
                if currentNode.isLeftChild():
                    currentNode.leftChild.parent = currentNode.parent
                    currentNode.parent.leftChild = currentNode.leftChild
                elif currentNode.isRightChild():
                    currentNode.leftChild.parent = currentNode.parent
                    currentNode.parent.rightChild = currentNode.leftChild
                else:
                    currentNode.replaceNodeData(currentNode.leftChild.key,
                                                currentNode.leftChild.payload,
                                                currentNode.leftChild.leftChild,
                                                currentNode.leftChild.rightChild)
            else:
                if currentNode.isLeftChild():
                    currentNode.rightChild.parent = currentNode.parent
                    currentNode.parent.leftChild = currentNode.rightChild
                elif currentNode.isRightChild():
                    currentNode.rightChild.parent = currentNode.parent
                    currentNode.parent.rightChild = currentNode.rightChild
                else:
                    currentNode.replaceNodeData(currentNode.rightChild.key,
                                                currentNode.rightChild.payload,
                                                currentNode.rightChild.leftChild,
                                                currentNode.rightChild.rightChild)

    def inorder(self):
        self._inorder(self.root)

    def _inorder(self, tree):
        if tree != None:
            self._inorder(tree.leftChild)
            print(tree.key)
            self._inorder(tree.rightChild)

    def postorder(self):
        self._postorder(self.root)

    def _postorder(self, tree):
        if tree:
            self._postorder(tree.rightChild)
            self._postorder(tree.leftChild)
            print(tree.key)

    def preorder(self):
        self._preorder(self, self.root)

    def _preorder(self, tree):
        if tree:
            print(tree.key)
            self._preorder(tree.leftChild)
            self._preorder(tree.rightChild)


class TreeNode:
    def __init__(self, key, val, left=None, right=None, parent=None):
        self.key = key
        self.payload = val
        self.leftChild = left
        self.rightChild = right
        self.parent = parent
        self.balanceFactor = 0

    def hasLeftChild(self):
        return self.leftChild

    def hasRightChild(self):
        return self.rightChild

    def isLeftChild(self):
        return self.parent and self.parent.leftChild == self

    def isRightChild(self):
        return self.parent and self.parent.rightChild == self

    def isRoot(self):
        return not self.parent

    def isLeaf(self):
        return not (self.rightChild or self.leftChild)

    def hasAnyChildren(self):
        return self.rightChild or self.leftChild

    def hasBothChildren(self):
        return self.rightChild and self.leftChild

    def replaceNodeData(self, key, value, lc, rc):
        self.key = key
        self.payload = value
        self.leftChild = lc
        self.rightChild = rc
        if self.hasLeftChild():
            self.leftChild.parent = self
        if self.hasRightChild():
            self.rightChild.parent = self

    def findSuccessor(self):
        succ = None
        if self.hasRightChild():
            succ = self.rightChild.findMin()
        else:
            if self.parent:
                if self.isLeftChild():
                    succ = self.parent
                else:
                    self.parent.rightChild = None
                    succ = self.parent.findSuccessor()
                    self.parent.rightChild = self
        return succ

    def spliceOut(self):
        if self.isLeaf():
            if self.isLeftChild():
                self.parent.leftChild = None
            else:
                self.parent.rightChild = None
        elif self.hasAnyChildren():
            if self.hasLeftChild():
                if self.isLeftChild():
                    self.parent.leftChild = self.leftChild
                else:
                    self.parent.rightChild = self.leftChild
                self.leftChild.parent = self.parent
            else:
                if self.isLeftChild():
                    self.parent.leftChild = self.rightChild
                else:
                    self.parent.rightChild = self.rightChild
                self.rightChild.parent = self.parent

    def findMin(self):
        current = self
        while current.hasLeftChild():
            current = current.leftChild
        return current

    def __iter__(self):
        &quot;&quot;&quot;The standard inorder traversal of a binary tree.&quot;&quot;&quot;
        if self:
            if self.hasLeftChild():
                for elem in self.leftChild:
                    yield elem
            yield self.key
            if self.hasRightChild():
                for elem in self.rightChild:
                    yield elem
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/7/19</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Tree.html'>Tree</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="tree_2.html">
                
                  <h1>Python树(二)：二叉树的实现</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">嵌套列表表示树</a>
</li>
<li>
<a href="#toc_1">节点和引用</a>
</li>
<li>
<a href="#toc_2">优先队列和二叉堆</a>
<ul>
<li>
<a href="#toc_3">列表与完全二叉树</a>
</li>
<li>
<a href="#toc_4">二叉堆的操作与实现</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">分析树</a>
</li>
<li>
<a href="#toc_6">树的遍历</a>
</li>
</ul>


<p>树可以具有以下方法：</p>

<ul>
<li><code>BinaryTree()</code> creates a new instance of a binary tree.</li>
<li><code>get_left_child()</code> returns the binary tree corresponding to the left child of the current node</li>
<li><code>get_right_child()</code> return the binary tree corresponding to the right child of the current node</li>
<li><code>set_root_val(val)</code> stores the object stored in the current node</li>
<li><code>get_root_val()</code> returns the object stored in the current node</li>
<li><code>insert_left(val)</code> creates a new binary tree and installs it as the left child of the current node</li>
<li><code>insert_right(val)</code> creates a new binary tree and installs it as the right child of the current node</li>
</ul>

<h2 id="toc_0">嵌套列表表示树</h2>

<p>在列表实现树时，我们将存储根节点作为列表的第一个元素的值。列表的第二个元素的本身是一个表示左子树的列表。这个列表的第三个元素表示在右子树的另一个列表。</p>

<pre><code class="language-python"># coding: utf-8


def BinaryTree(r):
    &quot;&quot;&quot;
    creates a new instance of a binary tree.
    &quot;&quot;&quot;
    return [r,[],[]]


def get_left_child(root):
    &quot;&quot;&quot;
    returns the binary tree corresponding to the left child of the current node
    &quot;&quot;&quot;
    return root[1]


def get_right_child(root):
    &quot;&quot;&quot;
    return the binary tree corresponding to the right child of the current node
    &quot;&quot;&quot;
    return  root[2]


def set_root_val(root, val):
    &quot;&quot;&quot;stores the object stored in the current node
    &quot;&quot;&quot;
    root[0] = val



def get_root_val(root):
    &quot;&quot;&quot;
    returns the object stored in the current node
    &quot;&quot;&quot;
    return root[0]

def insert_left(root, new_branch):
    &quot;&quot;&quot;
    creates a new binary tree and installs it as the left child of the current node

    插入一个左子节点，首先获取对应于当前左子节点的列表（可能是空的）。
    然后，添加新的左子节点，将原来的左子节点作为新节点的左子节点。
    这使我们能够将新节点插入到树中的任何位置.
    &quot;&quot;&quot;
    if root[1]:
        root[1] = [new_branch,root[1], []]
    else:
        root[1] = [new_branch, [], []]
    return root



def insert_right(root, new_branch):
    &quot;&quot;&quot;
    creates a new binary tree and installs it as the right child of the current node
    &quot;&quot;&quot;
    if root[2]:
        root[2] = [new_branch, [], root[2]]
    else:
        root[2] = [new_branch, [], []]
    return root


if __name__ == &quot;__main__&quot;:
    r = BinaryTree(3)
    insert_left(r,4)
    insert_left(r,5)
    insert_right(r,6)
    insert_right(r,7)
    l = get_left_child(r)
    print(l)

    set_root_val(l,9)
    print(r)
    insert_left(l,11)
    print(r)
    print(get_right_child(get_right_child(r)))

# result
#[5, [4, [], []], []]
#[3, [9, [4, [], []], []], [7, [], [6, [], []]]]
#[3, [9, [11, [4, [], []], []], []], [7, [], [6, [], []]]]
#[6, [], []]

</code></pre>

<h2 id="toc_1">节点和引用</h2>

<p>节点和引用方法，定义一个类，具有根、以及左、右子树属性。这种表示更紧密地结合了面向对象的方式。树的结构类似于下图所示。</p>

<p><img src="media/14973171257726/14974056999880.jpg" alt="binary tree"/></p>

<p>左右子树是其他二叉树实例的引用。例如，当插入一个新的左子节点到树上时，即创建了二叉树的另一个实例，并修改了根节点的<code>self.left_child</code>使之指向新的树。</p>

<pre><code class="language-python">
import doctest


class BinaryTree(object):
    &quot;&quot;&quot;
    &gt;&gt;&gt; r = BinaryTree(&#39;a&#39;)
    &gt;&gt;&gt; r.get_root_val()
    &#39;a&#39;
    &gt;&gt;&gt; r.get_left_child()

    &gt;&gt;&gt; r.insert_left(&#39;b&#39;)
    &gt;&gt;&gt; r.get_left_child().get_root_val()
    &#39;b&#39;
    &gt;&gt;&gt; r.insert_right(&#39;c&#39;)
    &gt;&gt;&gt; r.get_right_child().get_root_val()
    &#39;c&#39;
    &gt;&gt;&gt; r.get_right_child().set_root_val(&#39;hello&#39;)
    &gt;&gt;&gt; r.get_right_child().get_root_val()
    &#39;hello&#39;
    &quot;&quot;&quot;
    
    def __init__(self, root):
        self.key = root
        self.left_child = None
        self.right_child = None

    def insert_left(self, item):
        &quot;&quot;&quot;
        creates a new binary tree and installs it as the left child of the current node
        &quot;&quot;&quot;
        if self.left_child:
            self.left_child = BinaryTree(item)
        else:
            t = self.left_child
            self.left_child = BinaryTree(item)
            self.left_child.left_child = t

    def insert_right(self, item):
        &quot;&quot;&quot;
        creates a new binary tree and installs it as the right child of the current node
        &quot;&quot;&quot;
        if self.right_child:
            self.right_child = BinaryTree(item)
        else:
            t = self.right_child
            self.right_child = BinaryTree(item)
            self.right_child.right_child = t

    def get_right_child(self):
        &quot;&quot;&quot;
        return the binary tree corresponding to the right child of the current node
        &quot;&quot;&quot;
        return self.right_child

    def get_left_child(self):
        &quot;&quot;&quot;
        return the binary tree corresponding to the left child of the current node
        &quot;&quot;&quot;
        return self.left_child

    def set_root_val(self, root):
        &quot;&quot;&quot;
        stores the object stored in the current node
        &quot;&quot;&quot;
        self.key = root

    def get_root_val(self):
        &quot;&quot;&quot;
        returns the object stored in the current node
        &quot;&quot;&quot;
        return self.key

    def pre_order(self, root):
        &quot;&quot;&quot;
        preorder traversal
        &quot;&quot;&quot;
        print(root.key, end=&#39; &#39;)
        if root.left_child:
            root.pre_order(root.left_child)
        if root.right_child:
            root.pre_order(root.right_child)

    def post_order(self, root):
        &quot;&quot;&quot;
        postorder traversal
        &quot;&quot;&quot;
        if root is not None:
            self.post_order(root.left_child)
            self.post_order(root.right_child)
            print(root.key, end=&#39; &#39;)

    def pre_order(self, root):
        &quot;&quot;&quot;
        Preorder traversal
        &quot;&quot;&quot;
        print(root.key, end=&#39; &#39;)
        if root.left_child:
            self.pre_order(root.left_child)
        if root.right_child:
            self.pre_order(root.right_child)

    def in_order(self, root):
        &quot;&quot;&quot;
        postorder traversal
        &quot;&quot;&quot;
        if root is not None:
            self.in_order(root.left_child)
            print(root.key, end=&#39; &#39;)
            self.in_order(root.right_child)

if __name__ == &quot;__main__&quot;:
    doctest.testmod(verbose=True)

</code></pre>

<h2 id="toc_2">优先队列和二叉堆</h2>

<p><strong>优先队列</strong>(Priority Queues)是一类抽象数据类型。优先队列中的每个元素都有各自的优先级，优先级最高的元素最先得到服务；优先级相同的元素按照其在优先队列中的顺序得到服务。在优先队列的内部，元素的次序是由“优先级”来决定：高优先级的元素排在队首，而低优先级的元素则排在后面。</p>

<p>实现优先队列的经典方法是采用<strong>二叉堆</strong>(Binary Heap)。因为使用二叉堆能将优先队列的入队和出队复杂度都保持在\(O(\log n)\)。 二叉堆有两种：键值总是最小的排在队首称为<strong>最小堆</strong>(min heap)，反之，键值总是最大的排在队首称为<strong>最大堆</strong>(max heap)。</p>

<p>储存元素要满足<strong>堆次序</strong>，即堆中任何一个节点\(x\)，其父节点\(p\)的键值均小于或等于\(x\)的键值。下图所示是具备堆次序性质的完全二叉树。</p>

<h3 id="toc_3">列表与完全二叉树</h3>

<p><strong>不需要使用节点，引用或嵌套列表，用单个列表就能代表完全二叉树</strong>。因为对于完全二叉树，如果节点在列表中的下标为\(p\)，那么其左子节点下标为\(2p\)，右节点为\(2p+1\)。当我们要找任何节点的父节点时，可以直接使用 python 的整除。如果节点在列表中下标为\(n\)，那么父节点下标为\(n//2\)（参考下图）。使用列表, 能够使用简单的数学方法高效地遍历一棵完全二叉树，这也导致了二叉堆的高效实现。</p>

<p><img src="media/14973171257726/14974117374605.jpg" alt=""/></p>

<h3 id="toc_4">二叉堆的操作与实现</h3>

<ul>
<li><code>BinaryHeap()</code>：创建一个新的、空的二叉堆对象</li>
<li><code>insert(k)</code>：把新元素加入到堆中</li>
<li><code>findMin()</code>：返回堆中的最小项，最小项仍保留在堆中</li>
<li><code>delMin()</code>：返回堆中的最小项，同时从堆中删除</li>
<li><code>isEmpty()</code>：返回堆是否为空</li>
<li><code>size()</code>：返回堆中元素的个数</li>
<li><code>buildHeap(list)</code>：从一个包含元素的列表创建新堆</li>
</ul>

<p>有两个关键的操作：<br/>
1. <code>insert</code>方法。首先，为了满足“完全二叉树”的性质，新键值应该添加到列表的末尾。然而新键值简单地添加在列表末尾，显然无法满足堆次序。所以要通过比较父节点和新加入的元素的方法来重新满足堆次序。如果新加入的元素比父节点要小，可以与父节点互换位置；不断交换，直到到达树的顶端。下图所示一系列交换操作来使新加入元素“上浮”到正确的位置。</p>

<p><img src="media/14973171257726/14974156268132.jpg" alt=""/></p>

<p>2.<code>delMin</code>方法 移走根节点的元素后如何保持堆结构和堆次序: 首先，用最后一个节点来代替根节点, 移走最后一个节点保持了堆结构的性质。这么简单的替换，还是会破坏堆次序。第二步，将新节点“下沉”来恢复堆次序。下图所示的是一系列交换操作来使新节点“下沉”到正确的位置。</p>

<p><img src="media/14973171257726/14974156980805.jpg" alt=""/></p>

<pre><code class="language-python">class BinHeap(object):
    &quot;&quot;&quot;
    创建一个新的、空的二叉堆对象
    &quot;&quot;&quot;
    def __init__(self):
        self.list = [0]
        self.size = 0

    def perc_up(self,i):
        &quot;&quot;&quot;
        Percolate the new node into proper position
        &quot;&quot;&quot;
        while i//2&gt;0: 
            if self.list[i] &lt; self.list[i//2]:
                self.list[i], self.list[i//2] = self.list[i//2], self.list[i]
            i = i//2
    
    def insert(self, item):
        &quot;&quot;&quot;把新元素加入到堆中&quot;&quot;&quot;
        self.list.append(item)
        self.size += 1
        self.perc_up(self.size)

    def findMin(self):
        &quot;&quot;&quot;返回堆中的最小项，最小项仍保留在堆中&quot;&quot;&quot;
        return self.list[1]

    def delMin(self):
        &quot;&quot;&quot;返回堆中的最小项，同时从堆中删除&quot;&quot;&quot;
        retval = self.list[1]
        self.list[1] = self.list[-1]
        self.size -=1
        self.list.pop()
        self.perc_down(1)

        return retval


    def perc_down(self, i):
        &quot;&quot;&quot;
        Percolate the root node  down the tree
        &quot;&quot;&quot;
        while (i * 2) &lt;= self.currentSize:
            mc = self.minChild(i)
            if self.heapList[i] &gt; self.heapList[mc]:
                tmp = self.heapList[i]
                self.heapList[i] = self.heapList[mc]
                self.heapList[mc] = tmp
            i = mc
            
    def minChild(self, i):
        &quot;&quot;&quot;
        find the min child
        &quot;&quot;&quot;
        if i * 2 + 1 &gt; self.currentSize:
            return i * 2
        else:
            if self.heapList[i * 2] &lt; self.heapList[i * 2 + 1]:
                return i * 2
            else:
                return i * 2 + 1

    def isEmpty(self):
        &quot;&quot;&quot;返回堆是否为空&quot;&quot;&quot;
        return self.size == 0

    def __len__(self):
        &quot;&quot;&quot;返回堆中元素的个数&quot;&quot;&quot;
        return self.size

    def buildHeap(self,alist):
        &quot;&quot;&quot;从一个包含元素的列表创建新堆&quot;&quot;&quot;
        self.size = len(alist)
        self.list.extend(alist)
        i = self.size//2
        while i &gt;0:
            self.perc_down(i)
            i -= 1

</code></pre>

<h2 id="toc_5">分析树</h2>

<p><strong>分析树</strong>(Parse Tree)是一个反映某种形式语言字符串的语法关系的有根有序树, 常常用于真实世界的结构表示，例如句子或数学表达式。</p>

<p>下图是\( ((7+3)*(5−2))\) 的分析树, 树的层级结构帮我们理解了整个表达式的运算顺序。在计算最顶上的乘法运算前，我们先要计算子树中的加法和减法运算。左子树的加法运算结果为\(10\)，右子树的减法运算结果为\(3\)。利用树的层级结构，一旦我们计算出了子节点中表达式的结果，我们能够将整个子树用一个节点来替换。</p>

<p><img src="media/14973171257726/14974242592531.jpg" alt=""/></p>

<p>建立分析树的第一步是将表达式字符串分解成符号保存在列表里。有四种符号需要考虑：<strong>左括号</strong>，<strong>右括号</strong>，<strong>操作符</strong>和<strong>操作数</strong>。当读到一个左括号时，将开始一个新的表达式，因此需要创建一个子树来对应这个新的表达式。相反，每当读到一个右括号，就得结束这个表达式。另外，操作数将成为叶节点和他们所属的操作符的子节点。最后，每个操作符都应该有一个左子节点和一个右子节点。通过上面的分析我们定义以下四条规则：</p>

<ul>
<li>如果当前读入的字符是<code>(</code>，添加一个新的节点作为当前节点的左子节点，并下降到左子节点处。</li>
<li>如果当前读入的字符在列表[<code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>]中，将当前节点的根值设置为当前读入的字符。添加一个新的节点作为当前节点的右子节点，并下降到右子节点处。</li>
<li>如果当前读入的字符是一个数字，将当前节点的根值设置为该数字，并返回到它的父节点。</li>
<li>如果当前读入的字符是<code>)</code>，返回当前节点的父节点。</li>
</ul>

<p>利用<code>get_left_child</code>和<code>get_right_child</code>方法可以获得子节点的方法。<strong>利用栈跟踪父节点</strong>：当要下降到当前节点的子节点时，将当前节点压入栈；当要返回当前节点的父节点时，从栈中弹出该父节点。</p>

<p>所以使用栈和二叉树来创建分析树，代码如下：</p>

<pre><code class="language-python">from stack import Stack
from binary_tree2 import BinaryTree
import operator

def build_parse_tree(fp_exp):
    fp_list = fp_exp.split()
    p_stack = Stack()
    e_tree = BinaryTree(&#39;&#39;)
    p_stack.push(e_tree)
    current_tree = e_tree

    for i in fp_list:
        if i == &#39;(&#39;:
            current_tree.insert_left(&#39;&#39;)
            p_stack.push(current_tree)
            current_tree = current_tree.get_left_child()
        elif i not in [&#39;+&#39;,&#39;-&#39;,&#39;*&#39;,&#39;/&#39;,&#39;)&#39;]:
            current_tree.set_root_val(int(i))
            parent = p_stack.pop()
            current_tree = parent
        elif i in [&#39;+&#39;,&#39;-&#39;,&#39;*&#39;,&#39;/&#39;]:
            current_tree.set_root_val(i)
            current_tree.insert_right(&#39;&#39;)
            p_stack.push(current_tree)
            current_tree = current_tree.get_right_child()
        elif i == &#39;)&#39;:
            current_tree = p_stack.pop()
        else:
            raise ValueError

    return e_tree

def postorder_eval(tree):
    opers = {&#39;+&#39;:operator.add, &#39;-&#39;:operator.sub, &#39;*&#39;:operator.mul, &#39;/&#39;: operator.truediv}
    res1 = None
    res2 = None

    if tree:
        res1 = postorder_eval(tree.get_left_child())
        res2 = postorder_eval(tree.get_right_child())
        if res1 and res2:
            return opers[tree.get_root_val()](res1, res2)
        else:
            return tree.get_root_val()

pt = build_parse_tree(&quot;( ( 10 + 5 ) * 3 )&quot;)

print(&#39;result = %d&#39; %postorder_eval(pt))
</code></pre>

<h2 id="toc_6">树的遍历</h2>

<p>对树中所有节点的访问称为<strong>遍历</strong>(traversal)。按照节点的访问方式不同，树的遍历模式可分为 3 种。这三种方式常被用于访问树的节点，它们之间的不同在于访问每个节点的次序不同。这三种遍历分别叫做<strong>先序遍历</strong>(preorder)，<strong>中序遍历</strong>(inorder)和<strong>后序遍历</strong>(postorder)。具体定义为：</p>

<ul>
<li><p><strong>先序遍历</strong> 先访问根节点，然后递归使用先序遍历访问左子树，再递归使用先序遍历访问右子树。</p></li>
<li><p><strong>中序遍历</strong> 递归使用中序遍历访问左子树，然后访问根节点，最后再递归使用中序遍历访问右子树。</p></li>
<li><p><strong>后序遍历</strong> 先递归使用后序遍历访问左子树和右子树，最后访问根节点。</p></li>
</ul>

<p>三种遍历模式的代码已经包括在<code>BinaryTree</code>类中（参见<code>节点和引用</code>一节）。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/7/19</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Tree.html'>Tree</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="magic_method_item_access.html">
                
                  <h1>Magic Methods: Item Access</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>Useful magic methods allows you to create objects that behave like sequences or mappings.</p>

<h2 id="toc_0">Sequence and Mapping Protocol</h2>

<p><code>protocol</code> in Python usually describe the rules governing some form of behavior. The <code>protocol</code> states which methods you should implement and what those methods should do. So, to be a sequence means,  to follow the sequence protocol.</p>

<ul>
<li><code>__len__(self)</code>: This method should return the number of items contained in the collection. For a sequence, this would simply be the number of elements. For a mapping, it would be the number of key-value pairs. If <code>__len__</code> returns zero (and you don’t implement <code>__nonzero__</code>, which overrides this behavior), the object is treated as false in a Boolean context (as with empty lists, tuples, strings, and dictionaries).</li>
<li><code>__getitem__(self, key)</code>: This should return the value corresponding to the given key. For a sequence, the key should be an integer from \(0\) to \(n–1\) (or, it could be negative, as noted later), where \(n\) is the length of the sequence. For a mapping, you could really have any kind of keys.</li>
<li><code>__setitem__(self, key, value)</code>: This should store value in a manner associated with key, so it can later be retrieved with <code>__getitem__</code>. Of course, you define this method only for mutable objects.</li>
<li><code>__delitem__(self, key)</code>: This is called when someone uses the <code>del</code> statement on a part of the object, and should delete the element associated with key. Again, only mutable objects (and not all of them—only those for which you want to let items be removed) should define this method.</li>
</ul>

<h2 id="toc_1">Example</h2>

<pre><code class="language-python">def checkIndex(key):
    &quot;&quot;&quot;
    Is the given key an acceptable index?
    To be acceptable, the key should be a non-negative integer. If it
    is not an integer, a TypeError is raised; if it is negative, an
    IndexError is raised (since the sequence is of infinite length).
    &quot;&quot;&quot;
    if not isinstance(key, int):
        raise TypeError
    if key &lt; 0:
        raise IndexError


class ArithmeticSequence:
    def __init__(self, start=0, step=1):
        &quot;&quot;&quot;
        Initialize the arithmetic sequence.
        start   - the first value in the sequence
        step    - the difference between two adjacent values
        changed - a dictionary of values that have been modified by the user
        &quot;&quot;&quot;
        self.start = start
        self.step = step
        self.changed = {}

    def __getitem__(self, key):
        &quot;&quot;&quot;
        Get an item from the arithmetic sequence.
        &quot;&quot;&quot;
        checkIndex(key)
        try:
            return self.changed[key]
        except KeyError:
            return self.start + key*self.step
    # Store the start value
    # Store the step value
    # No items have been modified
    # Modified?
    # otherwise...
    # ...calculate the value

    def __setitem__(self, key, value):
        &quot;&quot;&quot;
        Change an item in the arithmetic sequence.
        &quot;&quot;&quot;
        checkIndex(key)
        self.changed[key] = value                 # Store the changed value

    def __delitem__(self, key):
        &quot;&quot;&quot;
        Delete the key provided from sequence
        &quot;&quot;&quot;
        checkIndex(key)
        del self.changed[key]



if __name__ == &quot;__main__&quot;:
    s = ArithmeticSequence(1, 2)
    print(s[4])
    s[4]=3
    print(s[4])
    del s[4]
    print(s[4])
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/7/18</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%89%B9%E6%80%A7.html'>Python特性</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_7.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_9.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="http://or9a8nskt.bkt.clouddn.com/figure.jpeg" /></div>
            
                <h1>techlarry</h1>
                <div class="site-des">他山之石，可以攻玉</div>
                <div class="social">









<a target="_blank" class="github" target="_blank" href="https://github.com/techlarry" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:wang.zhen.hua.larry@gmail.com" title="Email">Email</a>
  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Leetcode.html"><strong>Leetcode</strong></a>
        
            <a href="Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html"><strong>Python数据结构与算法</strong></a>
        
            <a href="Python%E7%89%B9%E6%80%A7.html"><strong>Python特性</strong></a>
        
            <a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html"><strong>机器学习</strong></a>
        
            <a href="Python%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96.html"><strong>Python科学计算三维可视化</strong></a>
        
            <a href="English.html"><strong>English</strong></a>
        
            <a href="%20%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA.html"><strong> 理解计算机</strong></a>
        
            <a href="Deep%20Learning.html"><strong>Deep Learning</strong></a>
        
            <a href="Latex.html"><strong>Latex</strong></a>
        
            <a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html"><strong>操作系统</strong></a>
        
            <a href="Linux%20%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html"><strong>Linux 系统编程</strong></a>
        
            <a href="%E6%95%B0%E6%8D%AE%E5%BA%93.html"><strong>数据库</strong></a>
        
            <a href="Tensorflow.html"><strong>Tensorflow</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15042359761425.html">Transfer Learning</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="cross-validation.html">Cross-Validation</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15037532856914.html">K-means clustering</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15036679491914.html">Feature Engineering</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15036619229303.html">Support Vector Machines</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    <script src="asset/chart/all-min.js"></script><script type="text/javascript">$(function(){    var mwebii=0;    var mwebChartEleId = 'mweb-chart-ele-';    $('pre>code').each(function(){        mwebii++;        var eleiid = mwebChartEleId+mwebii;        if($(this).hasClass('language-sequence')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = Diagram.parse($(this).text());            diagram.drawSVG(eleiid,{theme: 'simple'});        }else if($(this).hasClass('language-flow')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = flowchart.parse($(this).text());            diagram.drawSVG(eleiid);        }    });});</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
