<!doctype html>
<html class="no-js" lang="en">
<script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?fdc936c9f5a3b72177541183cdeb8cb3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Python数据结构与算法 - techlarry
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="techlarry" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:larryim.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        <li id=""><a target="_self" href="about.html">About</a></li>
        
        <li id=""><a target="_self" href="category.html">Category</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="http://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; techlarry</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
       
       <li><a href="index.html">HOME</a></li>
    <li><a href="archives.html">Archives</a></li>
    <li><a href="about.html">ABOUT</a></li>

    <li><label>Categories</label></li>

        
            <li><a href="Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html">Python数据结构与算法</a></li>
        
            <li><a href="Python%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7.html">Python编程技巧</a></li>
        
            <li><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html">机器学习</a></li>
        
            <li><a href="Python%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96.html">Python科学计算三维可视化</a></li>
        
            <li><a href="English.html">English</a></li>
        
            <li><a href="Linux%20%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html">Linux 系统编程</a></li>
        
            <li><a href="%E6%95%B0%E6%8D%AE%E5%BA%93.html">数据库</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="priority_queue.html">
                
                  <h1>Priority queue</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><strong>A priority queue</strong>(优先队列) is an ADP which likes a regular queue or stack , but where additionally each element has a <code>priority</code> associated with it. In a priority queue, an element with high priority is served before an element with low priority. If two elements have the same priority, they are served according to their order in the queue.</p>

<p>A priority queue must at least support the following operations:</p>

<ul>
<li><code>insert_with_priority</code>: add an element to the queue with an associated priority.</li>
<li><code>pull_highest_priority_element</code>: remove the element from the queue that has the highest priority, and return it.
*<code>peek</code> :return the highest-priority element but does not modify the queue</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/7/12</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html'>Python数据结构与算法</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="heap.html">
                
                  <h1>Heap</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>A <strong>heap</strong> (堆)is a specialized tree-based data structure。 A <strong>heap</strong> can be classified as either a <strong>max heap</strong> or a <strong>min heap</strong>. </p>

<ul>
<li>In a <strong>max heap</strong>, the keys of parent nodes are always greater than or equal to those of the children and the highest key is in the root node. </li>
<li>In a <strong>min heap</strong>, the keys of parent nodes are less than or equal to those of the children and the lowest key is in the root node.</li>
</ul>

<p><strong>Heap</strong> is one maximally efficient implementation of an abstract data type called a <strong>priority queue</strong> (see <a href="http://larryim.cc/priority_queue.html">here</a>), and in fact priority queues are often referred to as <strong>heaps</strong>, regardless of how they may be implemented. </p>

<h2 id="toc_0">Implementation</h2>

<p>Priority queues typically use a heap as backbone, giving \(O(\log n)\) performance for inserts and removals, and \(O(n \log n)\) to build initially.</p>

<h2 id="toc_1">Binary Heap</h2>

<p>A common implementation of a heap is the <strong>binary heap</strong>(二叉堆), in which the tree is a <strong>complete binary tree</strong>(完全二叉树). </p>

<p>二叉堆的操作与实现</p>

<ul>
<li><code>BinaryHeap()</code>：创建一个新的、空的二叉堆对象</li>
<li><code>insert(k)</code>：把新元素加入到堆中</li>
<li><code>findMin()</code>：返回堆中的最小项，最小项仍保留在堆中</li>
<li><code>delMin()</code>：返回堆中的最小项，同时从堆中删除</li>
<li><code>isEmpty()</code>：返回堆是否为空</li>
<li><code>size()</code>：返回堆中元素的个数</li>
<li><code>buildHeap(list)</code>：从一个包含元素的列表创建新堆</li>
</ul>

<p>有两个关键的操作：<br/>
1. <code>insert</code>方法。首先，为了满足“完全二叉树”的性质，新键值应该添加到列表的末尾。然而新键值简单地添加在列表末尾，显然无法满足堆次序。所以要通过比较父节点和新加入的元素的方法来重新满足堆次序。如果新加入的元素比父节点要小，可以与父节点互换位置；不断交换，直到到达树的顶端。下图所示一系列交换操作来使新加入元素“上浮”到正确的位置。</p>

<p><img src="media/14973171257726/14974156268132.jpg" alt=""/></p>

<p>2.<code>delMin</code>方法 移走根节点的元素后如何保持堆结构和堆次序: 首先，用最后一个节点来代替根节点, 移走最后一个节点保持了堆结构的性质。这么简单的替换，还是会破坏堆次序。第二步，将新节点“下沉”来恢复堆次序。下图所示的是一系列交换操作来使新节点“下沉”到正确的位置。</p>

<p><img src="media/14973171257726/14974156980805.jpg" alt=""/></p>

<pre><code class="language-python">class BinHeap(object):
    &quot;&quot;&quot;
    创建一个新的、空的二叉堆对象
    &quot;&quot;&quot;
    def __init__(self):
        self.list = [0]
        self.size = 0

    def perc_up(self,i):
        &quot;&quot;&quot;
        Percolate the new node into proper position
        &quot;&quot;&quot;
        while i: 
            if self.list[i] &lt; self.list[i//2]:
                self.list[i], self.list[i//2] = self.list[i//2], self.list[i]
            i = i//2
    
    def insert(self, item):
        &quot;&quot;&quot;把新元素加入到堆中&quot;&quot;&quot;
        self.list.append(item)
        self.size += 1
        self.perc_up(self.size)

    def findMin(self):
        &quot;&quot;&quot;返回堆中的最小项，最小项仍保留在堆中&quot;&quot;&quot;
        return self.list[1]

    def delMin(self):
        &quot;&quot;&quot;返回堆中的最小项，同时从堆中删除&quot;&quot;&quot;
        retval = self.list[1]
        self.list[1] = self.list[-1]
        self.size -=1
        self.list.pop()
        self.perc_down(1)

        return retval


    def perc_down(self, i):
        &quot;&quot;&quot;
        Percolate the root node  down the tree
        &quot;&quot;&quot;
        while i*2 &lt;= self.size:
            if i*2+1 &gt; self.size:
                self.list[i*2], self.list[i] = self.list[i], self.list[i*2]
                i = i*2
            else:
                if self.list[i*2] &gt; self.list[i*2+1]:
                    self.list[i*2+1], self.list[i] =  self.list[i], self.list[i*2+1]
                    i = i*2+1
                else:
                    self.list[i*2], self.list[i] = self.list[i], self.list[i*2]
                    i = i*2


    def isEmpty(self):
        &quot;&quot;&quot;返回堆是否为空&quot;&quot;&quot;
        return self.size == 0

    def __len__(self):
        &quot;&quot;&quot;返回堆中元素的个数&quot;&quot;&quot;
        return self.size

    def buildHeap(self,alist):
        &quot;&quot;&quot;从一个包含元素的列表创建新堆&quot;&quot;&quot;
        self.size = len(alist)
        self.list.extend(alist)
        i = self.size//2
        while i &gt;0:
            self.perc_down(i)
            i -= 1

</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/7/12</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html'>Python数据结构与算法</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14992350772045.html">
                
                  <h1>首先有一个概念：回溯</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>　　回溯法(探索与回溯法)是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p>

<p>深度优先算法：</p>

<p>（1）访问初始顶点v并标记顶点v已访问。<br/>
（2）查找顶点v的第一个邻接顶点w。<br/>
（3）若顶点v的邻接顶点w存在，则继续执行；否则回溯到v，再找v的另外一个未访问过的邻接点。<br/>
（4）若顶点w尚未被访问，则访问顶点w并标记顶点w为已访问。<br/>
（5）继续查找顶点w的下一个邻接顶点wi，如果v取值wi转到步骤（3）。直到连通图中所有顶点全部访问过为止。</p>

<p>广度优先算法：</p>

<p>（1）顶点v入队列。<br/>
（2）当队列非空时则继续执行，否则算法结束。<br/>
（3）出队列取得队头顶点v；访问顶点v并标记顶点v已被访问。<br/>
（4）查找顶点v的第一个邻接顶点col。<br/>
（5）若v的邻接顶点col未被访问过的，则col入队列。<br/>
（6）继续查找顶点v的另一个新的邻接顶点col，转到步骤（5）。直到顶点v的所有未被访问过的邻接点处理完。转到步骤（2）。</p>

<p>代码：</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/7/5</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html'>Python数据结构与算法</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="graph_basic.html">
                
                  <h1>Graph</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>Definition: A graph can be represented by \(G\) where \(G=(V,E)\). For the graph \(G\), \(V\) is a set of vertices and \(E\) is a set of edges. Each edge is a tuple \((v,w)\) where \(w, v \in V\). </p>

<h2 id="toc_0">Vocabulary and Definitions</h2>

<ul>
<li><p>Vertex<br/>
A <code>vertex</code> ( also a <code>node</code>) is a fundamental part of a graph. It can have a name <code>key</code>. A vertex may also have additional information called <code>payload</code>.</p></li>
<li><p>Edge<br/>
An <code>Edge</code> (also an <code>arc</code>) connects two vertices, and may be one-way(<code>directed graph</code>) or two-way(<code>undirected graph</code>).</p></li>
<li><p>Weight<br/>
Edges may be weighted to show that there is a cost (<code>weight</code>)to go from one vertex to another. E.g. the distance between the two cities.</p></li>
<li><p>Path<br/>
A <code>path</code> in a graph is a sequence of vertices that are connected by edges. Formally we could define a path as \(w_1, w_2,...,w_n\) such that \((w_i,w_{i+1}) \in E\) for all \(1 \le i \le  n-1\). The weighted path length is the sum of the weights of the edges in the path. </p></li>
<li><p>Cycle<br/>
A <code>cycle</code> in a directed graph is a graph that starts and ends at the same vertex.  A graph with no cycles is called an <code>acyclic graph</code>. A directed graph with no cycles is called a <code>directed acyclic graph</code> or a <code>DAG</code>.</p></li>
</ul>

<h2 id="toc_1">Representation</h2>

<p>Adjacency Matrix<br/>
Adjacency List<br/>
Edge List<br/>
<img src="media/14988021902558/Screen%20Shot%202017-06-30%20at%202.06.25%20PM.png" alt="Screen Shot 2017-06-30 at 2.06.25 P"/></p>

<p>A <code>path</code> in a graph \(G\) is a sequence of vertices \(v_0,v_1,...,v_n\) so that for all \(i, (v_i,v_{i+1})\) is an edge of \(G\).</p>

<h2 id="toc_2">The graph ADT</h2>

<p>The graph abstract data type (ADT) is defined as follows:</p>

<ul>
<li><code>Graph()</code> creates a new, empty graph.</li>
<li><code>addVertex(vert)</code> adds an instance of <code>Vertex</code> to the graph.</li>
<li><code>addEdge(fromVert, toVert)</code>Adds a new, directed edge to the graph that connects two vertices.</li>
<li><code>addEdge(fromVert, toVert, weight)</code> Adds a new, weighted, directed edge to the graph that connects two vertices.</li>
<li><code>getVertex(vertKey)</code> finds the vertex in the graph named vertKey.</li>
<li><code>getVertices()</code> returns the list of all vertices in the graph.</li>
<li><code>in</code> returns <code>True</code> for a statement of the form vertex in graph, if the given vertex is in the graph,<code>False</code> otherwise.</li>
</ul>

<h2 id="toc_3">Implementation</h2>

<p>We will create two classes, <code>Graph</code>, which holds the master list of vertices, and <code>Vertex</code>, which will represent each vertex in the graph.</p>

<p>Each <code>Vertex</code> uses a dictionary to keep track of the vertices to which it is connected, and the weight of each edge. This dictionary is called <code>connectedTo</code>. The listing below shows the code for the <code>Vertex</code> class. The constructor simply initializes the <code>id</code>, which will typically be a string, and the <code>connectedTo</code> dictionary. The <code>addNeighbor</code> method is used add a connection from this vertex to another. The g<code>etConnections</code> method returns all of the vertices in the adjacency list, as represented by the <code>connectedTo</code>instance variable. The <code>getWeight</code> method returns the weight of the edge from this vertex to the vertex passed as a parameter.</p>

<pre><code class="language-python">class Vertex:
    def __init__(self,key):
        self.id = key
        self.connectedTo = {}

    def addNeighbor(self,nbr,weight=0):
        self.connectedTo[nbr] = weight

    def __str__(self):
        return str(self.id) + &#39; connectedTo: &#39; + str([x.id for x in self.connectedTo])

    def getConnections(self):
        return self.connectedTo.keys()

    def getId(self):
        return self.id

    def getWeight(self,nbr):
        return self.connectedTo[nbr]
</code></pre>

<p>The <code>Graph</code> class, shown in the next listing, contains a dictionary that maps vertex names to vertex objects. <code>Graph</code> also provides methods for adding vertices to a graph and connecting one vertex to another. The <code>getVertices</code> method returns the names of all of the vertices in the graph. In addition, we have implemented the <code>__iter__</code> method to make it easy to iterate over all the vertex objects in a particular graph. Together, the two methods allow you to iterate over the vertices in a graph by name, or by the objects themselves.</p>

<pre><code class="language-python">class Graph:
    def __init__(self):
        self.vertList = {}
        self.numVertices = 0

    def addVertex(self,key):
        self.numVertices = self.numVertices + 1
        newVertex = Vertex(key)
        self.vertList[key] = newVertex
        return newVertex

    def getVertex(self,n):
        if n in self.vertList:
            return self.vertList[n]
        else:
            return None

    def __contains__(self,n):
        return n in self.vertList

    def addEdge(self,f,t,cost=0):
        if f not in self.vertList:
            nv = self.addVertex(f)
        if t not in self.vertList:
            nv = self.addVertex(t)
        self.vertList[f].addNeighbor(self.vertList[t], cost)

    def getVertices(self):
        return self.vertList.keys()

    def __iter__(self):
        return iter(self.vertList.values())
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/30</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html'>Python数据结构与算法</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14974279917175.html">
                
                  <h1>Python树(二)：二叉搜索树</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html'>Python数据结构与算法</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14973171257726.html">
                
                  <h1>Python树(一)：二叉树和二叉堆</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">定义</a>
</li>
<li>
<a href="#toc_1">树的应用</a>
</li>
<li>
<a href="#toc_2">树的术语</a>
</li>
<li>
<a href="#toc_3">树的种类</a>
</li>
<li>
<a href="#toc_4">树的存储</a>
</li>
<li>
<a href="#toc_5">树的实现</a>
<ul>
<li>
<a href="#toc_6">嵌套列表表示树</a>
</li>
<li>
<a href="#toc_7">节点和引用</a>
</li>
</ul>
</li>
<li>
<a href="#toc_8">优先队列和二叉堆</a>
<ul>
<li>
<a href="#toc_9">列表与完全二叉树</a>
</li>
<li>
<a href="#toc_10">二叉堆的操作与实现</a>
</li>
</ul>
</li>
<li>
<a href="#toc_11">分析树</a>
</li>
<li>
<a href="#toc_12">树的遍历</a>
</li>
</ul>


<p>树(tree)是一种抽象数据类型（ADT），用来模拟具有树状结构性质的数据集合。它是由\(n\)个有限节点组成一个具有层次关系的集合。树在计算机科学里应用广泛，包括操作系统，图形学，数据库和计算机网络。树和真正的树有许多相似的地方，也包括根、树枝和叶子，它们的不同在于计算机中的树的根在顶层而它的叶子在底部。它具有以下的特点：</p>

<ul>
<li>树是分级的，即树的顶层部分更加宽泛，而底部更加具体</li>
<li>一个节点（node）的所有子节点（children）和另一个节点的子节点是完全独立的</li>
<li>每个它的叶节点（leaf）都是不同的</li>
</ul>

<h2 id="toc_0">定义</h2>

<p>每个树或者为空，或者包含一个根节点和 0 个或多个子树，其中每个子树也符合这样的定义。每个子树的根节点和其父树的根节点之间通过边相连。</p>

<p>A tree is either empty or consists of a root and zeros or more subtrees, each of which is also a tree. The root of each subtree is connected to the root of the parent tree by an edge.</p>

<h2 id="toc_1">树的应用</h2>

<ul>
<li><p><strong>文件系统</strong>。在文件系统中，磁盘的分支或者说子目录都是运用了树来构建的。下图展示了Unix文件系统的部分的分层情况。<br/>
<img src="media/14973171257726/14973998176466.jpg" alt=""/></p></li>
<li><p><strong>网页</strong>。下图是一个利用超文本标记语言（HTML）编写的简单网页，以及构成网页的超文本标记语言中的标签相互关联关系所构成的树。</p></li>
</ul>

<pre><code class="language-html">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot; lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
        &lt;title&gt;simple&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;A simple web page&lt;/h1&gt;
            &lt;ul&gt;
                &lt;li&gt;List item one&lt;/li&gt;
                &lt;li&gt;List item two&lt;/li&gt;
            &lt;/ul&gt;
        &lt;h2&gt;&lt;a href=&quot;http://www.cs.luther.edu&quot;&gt;Luther CS &lt;/a&gt;&lt;h2&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p><img src="media/14973171257726/14973999293521.jpg" alt=""/></p>

<h2 id="toc_2">树的术语</h2>

<ul>
<li><p><strong>节点</strong>（Node） <br/>
节点是树的基本构成部分。它可能有其他专属的名称，我们称之为“键（key）”。一个节点也可能有更多的信息，我们称之为“负载”。虽然负载信息和树的许多算法并不直接相关，但是它对于树的应用至关重要。</p></li>
<li><p><strong>边</strong>（Edge） <br/>
边也是树的基本构成部分。边连接两个节点，并表示它们之间存在联系。除了根节点外每个节点都有且只有一条与其他节点相连的入边（指向该节点的边），每个节点可能有许多条出边（从该节点指向其他节点的边）。</p></li>
<li><p><strong>根节点</strong>（Root） <br/>
根节点是树种中唯一一个没有入边的节点。在文件系统中，“/”是树的根节点。</p></li>
<li><p><strong>路径</strong>（Path） <br/>
路径是由边连接起来的节点的有序排列。例如：（动物界——脊索动物门——哺乳动物纲——食肉动物目——猫科——猫属——家猫）就是一条路径。</p></li>
<li><p><strong>子节点集</strong>（Children） <br/>
当一个节点的入边来自另一个节点时，我们称前者是后者的子节点，同一个节点的所有子节点构成子节点集。在文件系统中，节点log/,spool/,yp/构成节点var/的子节点集。</p></li>
<li><p><strong>父节点</strong>（Parent） <br/>
一个节点是它出边所连接的所有节点的父节点。在文件系统中，节点var/是节点log/,spool/,yp/的父节点。</p></li>
<li><p><strong>兄弟节点</strong>（Sibling） <br/>
同一个节点的所有子节点互为兄弟节点，在文件系统树中节点etc/和节点usr/是兄弟节点。</p></li>
<li><p><strong>子树</strong>（Subtree） <br/>
子树是一个父节点的某个子节点的所有边和后代节点所构成的集合。</p></li>
<li><p><strong>叶节点</strong>（Leaf Node） <br/>
没有子节点的节点成为称为叶节点。</p></li>
<li><p><strong>层数</strong>（Level） <br/>
一个节点的层数是指从根节点到该节点的路径中的边的数目。定义根节点的层数为 0。</p></li>
<li><p><strong>高度</strong>（Height） <br/>
树的高度等于所有节点的层数的最大值。图 2 中树的高度为 2。</p></li>
</ul>

<h2 id="toc_3">树的种类</h2>

<ul>
<li><strong>无序树</strong>：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树；</li>
<li><strong>有序树</strong>：树中任意节点的子节点之间有顺序关系，这种树称为有序树；

<ul>
<li><strong>霍夫曼树</strong>（用于信息编码）：带权路径最短的二叉树称为哈夫曼树或最优二叉树；</li>
<li><strong>B树</strong>：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多余两个子树；</li>
<li><strong>二叉树</strong>：每个节点最多含有两个子树的树称为二叉树；

<ul>
<li><strong>完全二叉树</strong>：对于一颗二叉树，假设其深度为d(d&gt;1)。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树，其中满二叉树的定义是所有叶节点都在最底层的完全二叉树;</li>
<li><strong>平衡二叉树</strong>（AVL树）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树；</li>
<li><strong>二叉搜索树</strong>（Binary Search Tree）</li>
</ul></li>
</ul></li>
</ul>

<h2 id="toc_4">树的存储</h2>

<p>由于对节点的个数无法掌握，常见树的存储表示都转换成二叉树进行处理，子节点个数最多为2。</p>

<ul>
<li><p>嵌套列表：将数据结构存储在固定的数组中，然在遍历速度上有一定的优势，但因所占空间比较大，是非主流二叉树。二叉树通常以链式存储。</p></li>
<li><p>节点和引用：</p></li>
</ul>

<h2 id="toc_5">树的实现</h2>

<p>树可以具有以下方法：</p>

<ul>
<li><code>BinaryTree()</code> creates a new instance of a binary tree.</li>
<li><code>get_left_child()</code> returns the binary tree corresponding to the left child of the current node</li>
<li><code>get_right_child()</code> return the binary tree corresponding to the right child of the current node</li>
<li><code>set_root_val(val)</code> stores the object stored in the current node</li>
<li><code>get_root_val()</code> returns the object stored in the current node</li>
<li><code>insert_left(val)</code> creates a new binary tree and installs it as the left child of the current node</li>
<li><code>insert_right(val)</code> creates a new binary tree and installs it as the right child of the current node</li>
</ul>

<h3 id="toc_6">嵌套列表表示树</h3>

<p>在列表实现树时，我们将存储根节点作为列表的第一个元素的值。列表的第二个元素的本身是一个表示左子树的列表。这个列表的第三个元素表示在右子树的另一个列表。</p>

<pre><code class="language-python"># coding: utf-8


def BinaryTree(r):
    &quot;&quot;&quot;
    creates a new instance of a binary tree.
    &quot;&quot;&quot;
    return [r,[],[]]


def get_left_child(root):
    &quot;&quot;&quot;
    returns the binary tree corresponding to the left child of the current node
    &quot;&quot;&quot;
    return root[1]


def get_right_child(root):
    &quot;&quot;&quot;
    return the binary tree corresponding to the right child of the current node
    &quot;&quot;&quot;
    return  root[2]


def set_root_val(root, val):
    &quot;&quot;&quot;stores the object stored in the current node
    &quot;&quot;&quot;
    root[0] = val



def get_root_val(root):
    &quot;&quot;&quot;
    returns the object stored in the current node
    &quot;&quot;&quot;
    return root[0]

def insert_left(root, new_branch):
    &quot;&quot;&quot;
    creates a new binary tree and installs it as the left child of the current node

    插入一个左子节点，首先获取对应于当前左子节点的列表（可能是空的）。
    然后，添加新的左子节点，将原来的左子节点作为新节点的左子节点。
    这使我们能够将新节点插入到树中的任何位置.
    &quot;&quot;&quot;
    if root[1]:
        root[1] = [new_branch,root[1], []]
    else:
        root[1] = [new_branch, [], []]
    return root



def insert_right(root, new_branch):
    &quot;&quot;&quot;
    creates a new binary tree and installs it as the right child of the current node
    &quot;&quot;&quot;
    if root[2]:
        root[2] = [new_branch, [], root[2]]
    else:
        root[2] = [new_branch, [], []]
    return root


if __name__ == &quot;__main__&quot;:
    r = BinaryTree(3)
    insert_left(r,4)
    insert_left(r,5)
    insert_right(r,6)
    insert_right(r,7)
    l = get_left_child(r)
    print(l)

    set_root_val(l,9)
    print(r)
    insert_left(l,11)
    print(r)
    print(get_right_child(get_right_child(r)))

# result
#[5, [4, [], []], []]
#[3, [9, [4, [], []], []], [7, [], [6, [], []]]]
#[3, [9, [11, [4, [], []], []], []], [7, [], [6, [], []]]]
#[6, [], []]

</code></pre>

<h3 id="toc_7">节点和引用</h3>

<p>节点和引用方法，定义一个类，具有根、以及左、右子树属性。这种表示更紧密地结合了面向对象的方式。树的结构类似于下图所示。</p>

<p><img src="media/14973171257726/14974056999880.jpg" alt="binary tree"/></p>

<p>左右子树是其他二叉树实例的引用。例如，当插入一个新的左子节点到树上时，即创建了二叉树的另一个实例，并修改了根节点的<code>self.left_child</code>使之指向新的树。</p>

<pre><code class="language-python">
class BinaryTree(object):
    def __init__(self, root):
        self.key = root
        self.left_child = None
        self.right_child = None

    def insert_left(self, item):
        &quot;&quot;&quot;
        creates a new binary tree and installs it as the left child of the current node
        &quot;&quot;&quot;
        if self.left_child:
            self.left_child = BinaryTree(item)
        else:
            t = self.left_child
            self.left_child = BinaryTree(item)
            self.left_child.left_child = t


    def insert_right(self, item):
        &quot;&quot;&quot;
        creates a new binary tree and installs it as the right child of the current node
        &quot;&quot;&quot;
        if self.right_child:
            self.right_child = BinaryTree(item)
        else:
            t = self.right_child
            self.right_child = BinaryTree(item)
            self.right_child.right_child = t

    def get_right_child(self):
        &quot;&quot;&quot;
        return the binary tree corresponding to the right child of the current node
        &quot;&quot;&quot;
        return  self.right_child


    def get_left_child(self):
        &quot;&quot;&quot;
        return the binary tree corresponding to the left child of the current node
        &quot;&quot;&quot;
        return  self.left_child

    def set_root_val(self, root):
        &quot;&quot;&quot;
        stores the object stored in the current node
        &quot;&quot;&quot;
        self.key = root
        

    def get_root_val(self):
        &quot;&quot;&quot;
        returns the object stored in the current node
        &quot;&quot;&quot;
        return  self.key

    def pre_order(self, root):
        &quot;&quot;&quot;
        preorder traversal
        &quot;&quot;&quot;
        print(root.key, end=&#39; &#39;)
        if root.left_child:
            root.pre_order(root.left_child)
        if root.right_child:
            root.pre_order(root.right_child)

    def post_order(self, root):
        &quot;&quot;&quot;
        postorder traversal
        &quot;&quot;&quot;
        if root != None:
            self.post_order(root.left_child)
            self.post_order(root.right_child)
            print(root.key, end=&#39; &#39;)


    def pre_order(self, root):
        &quot;&quot;&quot;
        preorder traversal
        &quot;&quot;&quot;
        print(root.key, end=&#39; &#39;)
        if root.left_child:
            self.pre_order(root.left_child)
        if root.right_child:
            self.pre_order(root.right_child)       

    def in_order(self, root):
        &quot;&quot;&quot;
        postorder traversal
        &quot;&quot;&quot;
        if root != None:
            self.post_order(root.left_child)
            print(root.key, end=&#39; &#39;)  
            self.post_order(root.right_child)

</code></pre>

<h2 id="toc_8">优先队列和二叉堆</h2>

<p><strong>优先队列</strong>(Priority Queues)是一类抽象数据类型。优先队列中的每个元素都有各自的优先级，优先级最高的元素最先得到服务；优先级相同的元素按照其在优先队列中的顺序得到服务。在优先队列的内部，元素的次序是由“优先级”来决定：高优先级的元素排在队首，而低优先级的元素则排在后面。</p>

<p>实现优先队列的经典方法是采用<strong>二叉堆</strong>(Binary Heap)。因为使用二叉堆能将优先队列的入队和出队复杂度都保持在\(O(\log n)\)。 二叉堆有两种：键值总是最小的排在队首称为<strong>最小堆</strong>(min heap)，反之，键值总是最大的排在队首称为<strong>最大堆</strong>(max heap)。</p>

<p>储存元素要满足<strong>堆次序</strong>，即堆中任何一个节点\(x\)，其父节点\(p\)的键值均小于或等于\(x\)的键值。下图所示是具备堆次序性质的完全二叉树。</p>

<h3 id="toc_9">列表与完全二叉树</h3>

<p><strong>不需要使用节点，引用或嵌套列表，用单个列表就能代表完全二叉树</strong>。因为对于完全二叉树，如果节点在列表中的下标为\(p\)，那么其左子节点下标为\(2p\)，右节点为\(2p+1\)。当我们要找任何节点的父节点时，可以直接使用 python 的整除。如果节点在列表中下标为\(n\)，那么父节点下标为\(n//2\)（参考下图）。使用列表, 能够使用简单的数学方法高效地遍历一棵完全二叉树，这也导致了二叉堆的高效实现。</p>

<p><img src="media/14973171257726/14974117374605.jpg" alt=""/></p>

<h3 id="toc_10">二叉堆的操作与实现</h3>

<ul>
<li><code>BinaryHeap()</code>：创建一个新的、空的二叉堆对象</li>
<li><code>insert(k)</code>：把新元素加入到堆中</li>
<li><code>findMin()</code>：返回堆中的最小项，最小项仍保留在堆中</li>
<li><code>delMin()</code>：返回堆中的最小项，同时从堆中删除</li>
<li><code>isEmpty()</code>：返回堆是否为空</li>
<li><code>size()</code>：返回堆中元素的个数</li>
<li><code>buildHeap(list)</code>：从一个包含元素的列表创建新堆</li>
</ul>

<p>有两个关键的操作：<br/>
1. <code>insert</code>方法。首先，为了满足“完全二叉树”的性质，新键值应该添加到列表的末尾。然而新键值简单地添加在列表末尾，显然无法满足堆次序。所以要通过比较父节点和新加入的元素的方法来重新满足堆次序。如果新加入的元素比父节点要小，可以与父节点互换位置；不断交换，直到到达树的顶端。下图所示一系列交换操作来使新加入元素“上浮”到正确的位置。</p>

<p><img src="media/14973171257726/14974156268132.jpg" alt=""/></p>

<p>2.<code>delMin</code>方法 移走根节点的元素后如何保持堆结构和堆次序: 首先，用最后一个节点来代替根节点, 移走最后一个节点保持了堆结构的性质。这么简单的替换，还是会破坏堆次序。第二步，将新节点“下沉”来恢复堆次序。下图所示的是一系列交换操作来使新节点“下沉”到正确的位置。</p>

<p><img src="media/14973171257726/14974156980805.jpg" alt=""/></p>

<pre><code class="language-python">class BinHeap(object):
    &quot;&quot;&quot;
    创建一个新的、空的二叉堆对象
    &quot;&quot;&quot;
    def __init__(self):
        self.list = [0]
        self.size = 0

    def perc_up(self,i):
        &quot;&quot;&quot;
        Percolate the new node into proper position
        &quot;&quot;&quot;
        while i: 
            if self.list[i] &lt; self.list[i//2]:
                self.list[i], self.list[i//2] = self.list[i//2], self.list[i]
            i = i//2
    
    def insert(self, item):
        &quot;&quot;&quot;把新元素加入到堆中&quot;&quot;&quot;
        self.list.append(item)
        self.size += 1
        self.perc_up(self.size)

    def findMin(self):
        &quot;&quot;&quot;返回堆中的最小项，最小项仍保留在堆中&quot;&quot;&quot;
        return self.list[1]

    def delMin(self):
        &quot;&quot;&quot;返回堆中的最小项，同时从堆中删除&quot;&quot;&quot;
        retval = self.list[1]
        self.list[1] = self.list[-1]
        self.size -=1
        self.list.pop()
        self.perc_down(1)

        return retval


    def perc_down(self, i):
        &quot;&quot;&quot;
        Percolate the root node  down the tree
        &quot;&quot;&quot;
        while i*2 &lt;= self.size:
            if i*2+1 &gt; self.size:
                self.list[i*2], self.list[i] = self.list[i], self.list[i*2]
                i = i*2
            else:
                if self.list[i*2] &gt; self.list[i*2+1]:
                    self.list[i*2+1], self.list[i] =  self.list[i], self.list[i*2+1]
                    i = i*2+1
                else:
                    self.list[i*2], self.list[i] = self.list[i], self.list[i*2]
                    i = i*2


    def isEmpty(self):
        &quot;&quot;&quot;返回堆是否为空&quot;&quot;&quot;
        return self.size == 0

    def __len__(self):
        &quot;&quot;&quot;返回堆中元素的个数&quot;&quot;&quot;
        return self.size

    def buildHeap(self,alist):
        &quot;&quot;&quot;从一个包含元素的列表创建新堆&quot;&quot;&quot;
        self.size = len(alist)
        self.list.extend(alist)
        i = self.size//2
        while i &gt;0:
            self.perc_down(i)
            i -= 1

</code></pre>

<h2 id="toc_11">分析树</h2>

<p><strong>分析树</strong>(Parse Tree)是一个反映某种形式语言字符串的语法关系的有根有序树, 常常用于真实世界的结构表示，例如句子或数学表达式。</p>

<p>下图是\( ((7+3)*(5−2))\) 的分析树, 树的层级结构帮我们理解了整个表达式的运算顺序。在计算最顶上的乘法运算前，我们先要计算子树中的加法和减法运算。左子树的加法运算结果为\(10\)，右子树的减法运算结果为\(3\)。利用树的层级结构，一旦我们计算出了子节点中表达式的结果，我们能够将整个子树用一个节点来替换。</p>

<p><img src="media/14973171257726/14974242592531.jpg" alt=""/></p>

<p>建立分析树的第一步是将表达式字符串分解成符号保存在列表里。有四种符号需要考虑：<strong>左括号</strong>，<strong>右括号</strong>，<strong>操作符</strong>和<strong>操作数</strong>。当读到一个左括号时，将开始一个新的表达式，因此需要创建一个子树来对应这个新的表达式。相反，每当读到一个右括号，就得结束这个表达式。另外，操作数将成为叶节点和他们所属的操作符的子节点。最后，每个操作符都应该有一个左子节点和一个右子节点。通过上面的分析我们定义以下四条规则：</p>

<ul>
<li>如果当前读入的字符是<code>(</code>，添加一个新的节点作为当前节点的左子节点，并下降到左子节点处。</li>
<li>如果当前读入的字符在列表[<code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>]中，将当前节点的根值设置为当前读入的字符。添加一个新的节点作为当前节点的右子节点，并下降到右子节点处。</li>
<li>如果当前读入的字符是一个数字，将当前节点的根值设置为该数字，并返回到它的父节点。</li>
<li>如果当前读入的字符是<code>)</code>，返回当前节点的父节点。</li>
</ul>

<p>利用<code>get_left_child</code>和<code>get_right_child</code>方法可以获得子节点的方法。<strong>利用栈跟踪父节点</strong>：当要下降到当前节点的子节点时，将当前节点压入栈；当要返回当前节点的父节点时，从栈中弹出该父节点。</p>

<p>所以使用栈和二叉树来创建分析树，代码如下：</p>

<pre><code class="language-python">from stack import Stack
from binary_tree2 import BinaryTree
import operator

def build_parse_tree(fp_exp):
    fp_list = fp_exp.split()
    p_stack = Stack()
    e_tree = BinaryTree(&#39;&#39;)
    p_stack.push(e_tree)
    current_tree = e_tree

    for i in fp_list:
        if i == &#39;(&#39;:
            current_tree.insert_left(&#39;&#39;)
            p_stack.push(current_tree)
            current_tree = current_tree.get_left_child()
        elif i not in [&#39;+&#39;,&#39;-&#39;,&#39;*&#39;,&#39;/&#39;,&#39;)&#39;]:
            current_tree.set_root_val(int(i))
            parent = p_stack.pop()
            current_tree = parent
        elif i in [&#39;+&#39;,&#39;-&#39;,&#39;*&#39;,&#39;/&#39;]:
            current_tree.set_root_val(i)
            current_tree.insert_right(&#39;&#39;)
            p_stack.push(current_tree)
            current_tree = current_tree.get_right_child()
        elif i == &#39;)&#39;:
            current_tree = p_stack.pop()
        else:
            raise ValueError

    return e_tree

def postorder_eval(tree):
    opers = {&#39;+&#39;:operator.add, &#39;-&#39;:operator.sub, &#39;*&#39;:operator.mul, &#39;/&#39;: operator.truediv}
    res1 = None
    res2 = None

    if tree:
        res1 = postorder_eval(tree.get_left_child())
        res2 = postorder_eval(tree.get_right_child())
        if res1 and res2:
            return opers[tree.get_root_val()](res1, res2)
        else:
            return tree.get_root_val()

pt = build_parse_tree(&quot;( ( 10 + 5 ) * 3 )&quot;)

print(&#39;result = %d&#39; %postorder_eval(pt))
</code></pre>

<h2 id="toc_12">树的遍历</h2>

<p>对树中所有节点的访问称为<strong>遍历</strong>(traversal)。按照节点的访问方式不同，树的遍历模式可分为 3 种。这三种方式常被用于访问树的节点，它们之间的不同在于访问每个节点的次序不同。这三种遍历分别叫做<strong>先序遍历</strong>(preorder)，<strong>中序遍历</strong>(inorder)和<strong>后序遍历</strong>(postorder)。具体定义为：</p>

<ul>
<li><p><strong>先序遍历</strong> 先访问根节点，然后递归使用先序遍历访问左子树，再递归使用先序遍历访问右子树。</p></li>
<li><p><strong>中序遍历</strong> 递归使用中序遍历访问左子树，然后访问根节点，最后再递归使用中序遍历访问右子树。</p></li>
<li><p><strong>后序遍历</strong> 先递归使用后序遍历访问左子树和右子树，最后访问根节点。</p></li>
</ul>

<p>三种遍历模式的代码已经包括在<code>BinaryTree</code>类中（参见<code>节点和引用</code>一节）。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html'>Python数据结构与算法</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14973149842140.html">
                
                  <h1>搜索</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>搜索是在一个项目集合中找到一个特定项目的算法过程。返回值一般是<code>bool</code>:<code>True</code> or <code>False</code>. 搜索的几种常见方法：顺序查找、二分法查找、二叉树查找、哈希查找</p>

<h2 id="toc_0">在python中查找</h2>

<p>在python中，查找一个元素是否在列表中非常简单，可以用<code>in</code>操作符</p>

<pre><code class="language-python">&gt;&gt;&gt; 15 in [3,5,2,4,1]
False
&gt;&gt;&gt; 3 in [3,5,2,4,1]
True
&gt;&gt;&gt;
</code></pre>

<h2 id="toc_1">顺序查找</h2>

<p>顺序查找从列表中的第一个项目开始，我们按照顺序次序，简单地从一个项移动到另一个项，直到找到我们正在查找的项或遍历完整个列表。如果我们遍历完整个列表，则说明正在搜索的项不存在。</p>

<p><img src="media/14973149842140/14973392316280.png" alt=""/></p>

<pre><code class="language-python">def sequential_search(alist, item):
    &quot;&quot;&quot;
    顺序查找
    &quot;&quot;&quot;

    for i in range(len(alist)):
        if alist[i] == item:
            return True

    return False
</code></pre>

<h2 id="toc_2">二分查找</h2>

<p>二分查找过程类似于查字典。首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。</p>

<ul>
<li>优点是比较次数少，查找速度快，平均性能好</li>
<li>缺点是要求待查表为有序表，且插入删除困难</li>
<li>因此，折半查找方法适用于不经常变动而查找频繁的有序列表。</li>
</ul>

<p><img src="media/14973149842140/14973392434825.png" alt=""/></p>

<pre><code class="language-python">
def binary_search(alist, item):
    &quot;&quot;&quot;
    二分查找, 递归
    &quot;&quot;&quot;

    n = len(alist)
    if n &gt;0:
        mid = n//2

        if alist[mid] == item:
            return True
        elif alist[mid] &gt; item:
            return binary_search(alist[:mid], item)
        else:
            return binary_search(alist[mid+1:], item)
    return False

def binary_search2(alist, item):
    &quot;&quot;&quot;
    二分查找，非递归
    &quot;&quot;&quot;
    n = len(alist)
    first = 0
    last = n-1
    while first &lt;= last:
        mid = (first+last)//2
        if alist[mid] == item:
            return True
        elif alist[mid] &gt; item:
            last = mid-1
        else:
            first = mid+1

    return False

</code></pre>

<h2 id="toc_3">时间复杂度</h2>

<ul>
<li>最优时间复杂度: \(O(1)\)</li>
<li>最坏时间复杂度: \(O(\log n)\)</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/13</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html'>Python数据结构与算法</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14970829036232.html">
                
                  <h1>Python排序</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">排序算法的稳定性及意义</a>
</li>
<li>
<a href="#toc_1">冒泡排序</a>
<ul>
<li>
<a href="#toc_2">复杂度与稳定性</a>
</li>
</ul>
</li>
<li>
<a href="#toc_3">选择排序</a>
</li>
<li>
<a href="#toc_4">插入排序</a>
</li>
<li>
<a href="#toc_5">希尔排序</a>
</li>
<li>
<a href="#toc_6">快速排序</a>
</li>
<li>
<a href="#toc_7">归并排序</a>
<ul>
<li>
<a href="#toc_8">分治法</a>
</li>
</ul>
</li>
<li>
<a href="#toc_9">常见排序算法效率比较</a>
</li>
</ul>


<h2 id="toc_0">排序算法的稳定性及意义</h2>

<p>在待排序的序列中，存在具有相同关键字的记录，在排序后这些记录的相对次序保持不变，则排序算法是稳定的。</p>

<p>不稳定排序无法完成多个关键字的排序。例如整数排序，位数越高的数字优先级越高，从高位数到低位数一次排序。那么每一位的排序都需要稳定算法，否则无法得到正确的结果。</p>

<p>即，<strong>当要对多个关键词多次排序时，必须使用稳定算法</strong></p>

<h2 id="toc_1">冒泡排序</h2>

<p><img src="media/14970829036232/Screen%20Shot%202017-06-11%20at%2010.23.12%20AM.png" alt="Screen Shot 2017-06-11 at 10.23.12 A"/></p>

<pre><code class="language-python">def bubble_sort(alist):
    &quot;&quot;&quot;
    冒泡排序
    &quot;&quot;&quot;
    if len(alist) &lt;= 1:
        return alist

    for j in range(len(alist)-1,0,-1):
        for i in range(j):
            if alist[i] &gt; alist[i+1]:
                alist[i], alist[i+1] = alist[i+1], alist[i]

    return alist
</code></pre>

<h3 id="toc_2">复杂度与稳定性</h3>

<ul>
<li>最优时间复杂度：\(O(n)\) 遍历没有发现任何可以交换的元素，排序结束</li>
<li>最坏时间复杂度：\(O(n^2)\)</li>
<li>稳定性：稳定</li>
</ul>

<h2 id="toc_3">选择排序</h2>

<p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>

<h2 id="toc_4">插入排序</h2>

<p>插入排序通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>

<p><img src="media/14970829036232/Screen%20Shot%202017-06-12%20at%207.07.03%20PM.png" alt="Screen Shot 2017-06-12 at 7.07.03 P"/></p>

<pre><code class="language-python">def insert_sort(alist):
    &quot;&quot;&quot;
    插入排序
    &quot;&quot;&quot;
    n = len(alist)
    if n &lt;= 1:
        return alist

    # 从第二个位置，即下表为1的元素开始向前插入
    for i in range(1, n):
        j = i
        # 向前向前比较，如果小于前一个元素，交换两个元素
        while alist[j] &lt; alist[j-1] and j &gt; 0:
            alist[j], alist[j-1] = alist[j-1], alist[j]
            j-=1
    return alist
</code></pre>

<p>复杂度与稳定性</p>

<ul>
<li>最优时间复杂度：O(\(n\)) （升序排列，序列已经处于升序状态）</li>
<li>最坏时间复杂度：O(\(n^2\))</li>
<li>稳定性：稳定</li>
</ul>

<h2 id="toc_5">希尔排序</h2>

<p>希尔排序(Shell Sort)是插入排序的改进, 排序非稳定。希尔排序是把记录按下标的一定<em>增量</em>分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>

<pre><code class="language-python">def shell_sort(alist):
    
    n = len(alist)
    gap = n//2
    
    # gap 变化到0之前，插入算法之行的次数
    while gap &gt; 0:
        
        # 希尔排序， 与普通的插入算法的区别就是gap步长
        for i in range(gap,n):
            j = i
            while alist[j] &lt; alist[j-gap] and j &gt; 0:
                alist[j], alist[j-gap] = alist[j-gap], alist[j]
                j-=gap
    
        gap = gap//2

    return alist
</code></pre>

<p>复杂度与稳定性</p>

<ul>
<li>最优时间复杂度：\(O(n^{1.3})\) （不要求本身有序）</li>
<li>最坏时间复杂度：\(O(n^2)\)</li>
<li>稳定性：不稳定</li>
</ul>

<h2 id="toc_6">快速排序</h2>

<p>快速排序(Quicksort)，通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>

<p>步骤为：</p>

<ol>
<li>从数列中挑出一个元素，称为&quot;基准&quot;(pivot)</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区(partition)操作。</li>
<li>递归地(recursive)把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ol>

<p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代(iteration)中，它至少会把一个元素摆到它最后的位置去。</p>

<h2 id="toc_7">归并排序</h2>

<p>归并排序是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。</p>

<p>将数组分解最小之后，然后合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。</p>

<h3 id="toc_8">分治法</h3>

<p>分治法的思想：将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。</p>

<p>分治模式在每层递归时都有三个步骤：</p>

<ul>
<li><strong>分解</strong>原问题为若干子问题，这些子问题是原问题的规模较小的实例</li>
<li><strong>解决</strong>这些子问题，递归地求解各子问题。然而，若子问题的规模足够小，则直接求解</li>
<li><strong>合并</strong>这些子问题的解成原问题的解</li>
</ul>

<p>归并排序算法完全遵循分治模式。直观上其操作如下：</p>

<ul>
<li><strong>分解</strong>：分解待排序的n个元素的序列成各具n/2个元素的两个子序列</li>
<li><strong>解决</strong>：使用归并排序递归地排序两个子序列</li>
<li><strong>合并</strong>：合并两个已排序的子序列以产生已排序的答案。</li>
</ul>

<h2 id="toc_9">常见排序算法效率比较</h2>

<p><img src="media/14970829036232/14972715837154.jpg" alt=""/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/10</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html'>Python数据结构与算法</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14969804243106.html">
                
                  <h1>栈与队列</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">栈</h2>

<p>栈(stack)，是一种容器，可存入数据元素、访问元素、删除元素，它的特点是只能在容器的一端加入数据（push）和输出数据(pop)的运算。没有了位置概念，保证任何时候可以访问，删除的元素都是此前最后存入的那个元素，确定了一种默认的访问顺序。</p>

<p>栈数据结构只允许在一端进行操作，按照后进先出(LIFO, Last In First Out)的原理运作。</p>

<p>栈可以用顺序表实现，也可以用链表实现。</p>

<p><img src="media/14969804243106/Screen%20Shot%202017-06-10%20at%203.14.14%20PM.png" alt="Screen Shot 2017-06-10 at 3.14.14 P"/></p>

<h3 id="toc_1">栈的操作</h3>

<ul>
<li>Stack() 创建一个新的空栈</li>
<li>push(item) 添加一个新的元素item到栈顶</li>
<li>pop() 弹出栈顶元素</li>
<li>peek() 返回栈顶元素</li>
<li>is_empty() 判断栈是否为空</li>
<li>size() 返回栈的元素个数</li>
</ul>

<pre><code class="language-python">class Stack(object):
    &quot;&quot;&quot;
    创建一个新的空栈
    &quot;&quot;&quot;
    def __init__(self):
        self.__list = []

    def push(self, item):
        &quot;&quot;&quot;
        添加一个新的元素item到栈顶
        &quot;&quot;&quot;
        self.__list.append(item)

    def pop(self):
        &quot;&quot;&quot;
        弹出栈顶元素
        &quot;&quot;&quot;
        return self.__list.pop()

    def peek(self):
        &quot;&quot;&quot;
        返回栈顶元素
        &quot;&quot;&quot;
        if self.is_empty():
            return None
        else:
            return self.__list[-1]

    def is_empty(self):
        &quot;&quot;&quot;
        判断栈是否为空
        &quot;&quot;&quot;
        return not self.__list  ## 空链表、空字典等是假

    def size(self):
        &quot;&quot;&quot;
        返回栈的元素个数
        &quot;&quot;&quot;
        return self.__list.__len__()
</code></pre>

<h2 id="toc_2">队列</h2>

<p>队列(queue,美音/kju/)只是允许在一端进行插入操作，而在另一段进行删除操作的线性表。队列是一种先进先出（First In First Out, FIFO）的线性表。允许插入的一端为队尾，允许删除的一端为队头。队列不允许在中间部位进行操作。</p>

<p><img src="media/14969804243106/Screen%20Shot%202017-06-10%20at%203.21.23%20PM.png" alt="Screen Shot 2017-06-10 at 3.21.23 P"/></p>

<h3 id="toc_3">队列的操作</h3>

<ul>
<li>Queue() 创建一个空的队列</li>
<li>enqueue(item) 往队列中添加一个item元素</li>
<li>dequeue() 从队列头部删除一个元素</li>
<li>is_empty() 判断一个队列是否为空</li>
<li>size() 返回队列的大小</li>
</ul>

<pre><code class="language-python">class Queue(object):
    &quot;&quot;&quot;队列&quot;&quot;&quot;
    def __init__(self):
        self.__list = []

    def enqueue(self, item):
        &quot;&quot;&quot;往队列中添加一个item元素&quot;&quot;&quot;
        self.__list.append(item)

    def dequeue(self):
        &quot;&quot;&quot;从队列头部删除一个元素&quot;&quot;&quot;
        return self.__list.pop(0)

    def is_empty(self):
        &quot;&quot;&quot;判断一个队列是否为空&quot;&quot;&quot;
        return not self.__list

    def size(self):
        &quot;&quot;&quot;返回队列的大小&quot;&quot;&quot;
        return len(self.__list)
</code></pre>

<h2 id="toc_4">双端队列</h2>

<p>双端队列(deque，全名double-ended queue, (pronounced “deck”))，是一种具有队列和栈的性质的数据结构。</p>

<p>双端队列中的元素可以从两端弹出，其限定插入和删除操作在表的两端进行。双端队列可以在队列任意一端入队和出队。</p>

<p><img src="media/14969804243106/14970822950255.png" alt=""/></p>

<h3 id="toc_5">双端队列的操作</h3>

<ul>
<li>Deque() 创建一个空的双端队列</li>
<li>add_front(item) 从队头加入一个item元素</li>
<li>add_rear(item) 从队尾加入一个item元素</li>
<li>remove_front() 从队头删除一个item元素</li>
<li>remove_rear() 从队尾删除一个item元素</li>
<li>is_empty() 判断双端队列是否为空</li>
<li>size() 返回队列的大小</li>
</ul>

<pre><code class="language-python">class Deque():
    &quot;&quot;&quot;
    创建一个空的双端队列
    &quot;&quot;&quot;
    def __init__(self):
        self.__list = []

    def add_front(self, item):
        &quot;&quot;&quot;从队头加入一个item元素&quot;&quot;&quot;
        self.__list.insert(0, item)

    def add_rear(self, item):
        &quot;&quot;&quot;从队尾加入一个item元素&quot;&quot;&quot;
        self.__list.append(item)
    
    def remove_front(self):
        &quot;&quot;&quot;从队头删除一个item元素&quot;&quot;&quot;
        return self.__list.pop(0)

    def remove_rear(self):
        &quot;&quot;&quot;从队尾删除一个item元素&quot;&quot;&quot;
        return self.__list.pop()
    
    def is_empty(self):
        &quot;&quot;&quot;判断双端队列是否为空&quot;&quot;&quot;
        return not self.__list

    def size(self):
        &quot;&quot;&quot;返回队列的大小&quot;&quot;&quot;
        return self.__list.__len__()
    ```


</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/9</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html'>Python数据结构与算法</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="%E9%93%BE%E8%A1%A8.html">
                
                  <h1>链表</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">线性表</a>
</li>
<li>
<a href="#toc_1">单向链表</a>
<ul>
<li>
<a href="#toc_2">补充：python中变量标识的本质</a>
</li>
<li>
<a href="#toc_3">示意</a>
</li>
<li>
<a href="#toc_4">代码</a>
</li>
<li>
<a href="#toc_5">单项链表与顺序表的对比</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">双向链表</a>
</li>
<li>
<a href="#toc_7">单向循环列表</a>
</li>
</ul>


<p>链表(Linked list)，是一种<strong>线性表</strong>，不像顺序表一样连续存储数据，而是在每一个节点（数据存储单元）里存放下一个节点的位置信息（即地址）。</p>

<h2 id="toc_0">线性表</h2>

<p>一组序列元素的组织形式，可以将其抽象为线性表。一个线性表是某类元素的一个集合，还记录着元素之间的一种顺序关系。线性表是最基本的数据结果一直，在实际程序中应用非常广泛，它还将常被用来做更复杂的数据结构的实现基础。</p>

<p>根据<strong>线性表</strong>的存储方式，分为两种模型：</p>

<ul>
<li><strong>顺序表</strong>，将元素顺序地放在一块连续的存储区里，元素间的顺序关系由它们的存储顺序自然表示。</li>
<li><strong>链表</strong>，将元素存放在通过链接构造起来的一系列存储块中,包括单项列表，双向列表，单向循环列表</li>
</ul>

<h2 id="toc_1">单向链表</h2>

<p>节点：包括表元素域，和下一个节点连接域。<br/>
尾节点的连接域指向一个空值。</p>

<h3 id="toc_2">补充：python中变量标识的本质</h3>

<p>变量标识保存变量的地址。因此不用指定变量的类型，在程序运行过程中也可以改变变量类型。<br/>
与C语言不同：C语言需要申明变量类型。</p>

<h3 id="toc_3">示意</h3>

<p><img src="media/14969803634863/Screen%20Shot%202017-06-09%20at%2012.52.23%20PM.png" alt="Screen Shot 2017-06-09 at 12.52.23 P"/></p>

<h3 id="toc_4">代码</h3>

<pre><code class="language-python">class Node(object):
    &quot;&quot;&quot;节点&quot;&quot;&quot;
    def __init__(self, elem):
        self.elem = elem
        self.next = None


class SingleLinkList(object):
    &quot;&quot;&quot;单链表&quot;&quot;&quot;
    def __init__(self, node=None):
        self.__head = node

    def is_empty(self):
        &quot;&quot;&quot;链表是否为空&quot;&quot;&quot;
        return self.__head == None

    def length(self):
        &quot;&quot;&quot;链表长度&quot;&quot;&quot;
        # cur游标，用来移动遍历节点
        cur = self.__head
        # count记录数量
        count = 0
        while cur != None:
            count += 1
            cur = cur.next
        return count

    def travel(self):
        &quot;&quot;&quot;遍历整个链表&quot;&quot;&quot;
        cur = self.__head
        while cur != None:
            print(cur.elem, end=&quot; &quot;)
            cur = cur.next
        print(&quot;&quot;)

    def add(self, item):
        &quot;&quot;&quot;链表头部添加元素，头插法&quot;&quot;&quot;
        node = Node(item)
        node.next = self.__head
        self.__head = node

    def append(self, item):
        &quot;&quot;&quot;链表尾部添加元素, 尾插法&quot;&quot;&quot;
        node = Node(item)
        if self.is_empty():
            self.__head = node
        else:
            cur = self.__head
            while cur.next != None:
                cur = cur.next
            cur.next = node

    def insert(self, pos, item):
        &quot;&quot;&quot;指定位置添加元素
        :param  pos 从0开始
        &quot;&quot;&quot;
        if pos &lt;= 0:
            self.add(item)
        elif pos &gt; (self.length()-1):
            self.append(item)
        else:
            pre = self.__head
            count = 0
            while count &lt; (pos-1):
                count += 1
                pre = pre.next
            # 当循环退出后，pre指向pos-1位置
            node = Node(item)
            node.next = pre.next
            pre.next = node

    def remove(self, item):
        &quot;&quot;&quot;删除节点&quot;&quot;&quot;
        cur = self.__head
        pre = None
        while cur != None:
            if cur.elem == item:
                # 先判断此结点是否是头节点
                # 头节点
                if cur == self.__head:
                    self.__head = cur.next
                else:
                    pre.next = cur.next
                break
            else:
                pre = cur
                cur = cur.next

    def search(self, item):
        &quot;&quot;&quot;查找节点是否存在&quot;&quot;&quot;
        cur = self.__head
        while cur != None:
            if cur.elem == item:
                return True
            else:
                cur = cur.next
        return False
</code></pre>

<h3 id="toc_5">单项链表与顺序表的对比</h3>

<ul>
<li>顺序表随机读取，空间开销小的优点，但存储空间必须连续</li>
<li>链表由于增加了结点的指针域，空间开销比较大</li>
<li>链表对存储空间的使用要相对灵活，充分利用离散的存储空间</li>
</ul>

<table>
<thead>
<tr>
<th>操作</th>
<th>链表</th>
<th>顺序表</th>
</tr>
</thead>

<tbody>
<tr>
<td>访问元素</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>在头部插入/删除</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>在尾部插入/删除</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>在中间插入/删除</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table>

<h2 id="toc_6">双向链表</h2>

<p>节点：前驱区、数据区、后继区</p>

<p><img src="media/14969803634863/14970689776814.png" alt=""/></p>

<pre><code class="language-python">class Node(object):
    def __init__(self, elem):
        self.prev = None
        self.elem = elem
        self.next = None

class DobuleLinkList(object):
    &quot;&quot;&quot;
    双链表
    &quot;&quot;&quot;
    def __init__(self, node = None):
        self.__head =  node  # 私有属性


    def is_empty(self):
        &quot;&quot;&quot;
        链表是否为空
        &quot;&quot;&quot;
        return self.__head is None

    def length(self):
        &quot;&quot;&quot;
        链表长度
        &quot;&quot;&quot;
        current = self.__head # current 游标，用来移动遍历节点
        count  = 0 # count 记录数量
        while current != None:
            count += 1
            current = current.next

        return count

    def travel(self):
        &quot;&quot;&quot;
        遍历整个链表
        &quot;&quot;&quot;
        current = self.__head # current 游标，用来移动遍历节点
        lists = []
        while current != None:
            lists.append(current.elem)
            current = current.next

        print(lists)


    def add(self, item):
        &quot;&quot;&quot;
        链表头部添加元素
        &quot;&quot;&quot;
        second_elem = self.__head
        self.__head = Node(item)
        self.__head.next = second_elem
        second_elem.prev = self.__head


    def append(self, item):
        &quot;&quot;&quot;
        链表尾部添加元素
        item: 具体的数据，不是class Node
        &quot;&quot;&quot;
        node = Node(item)

        # 判断链表是否为空
        if self.is_empty():
            self.__head = node
        else:
            current = self.__head
            while current.next != None: # 遍历，找到节点尾部
                current = current.next
            current.next = node
            node.prev = current



    def insert(self, pos, item):
        &quot;&quot;&quot;
        指定位置添加元素
        pos: 从0开始索引
        &quot;&quot;&quot;
        if pos &lt;= 0:
            self.add(item)
        elif pos &gt;= self.length()-1:
            self.append(item)
        else:
            count = 0
            current = self.__head
            while count &lt; pos:
                current = current.next
                count += 1

            previous = current.prev
            nodes = Node(item)
            previous.next = nodes
            nodes.prev = previous
            nodes.next = current
            current.prev = nodes



    def remove(self,item):
        &quot;&quot;&quot;
        删除节点
        &quot;&quot;&quot;
        current = self.__head
        if current.elem == item:
            self.__head = current.next
            if current.next:
                current.next.prev = None
            print(&#39;Remove the element %d&#39;%item)
            return None
        else:
            while current != None:
                if current.elem == item:
                    current.prev.next = current.next
                    current.next.prev = current.prev
                    print(&#39;Remove the element %d&#39;%item)
                    return None
                else:
                    current = current.next
        print(&quot;Can&#39;t find it&quot;)


    def search(self,item):
        &quot;&quot;&quot;
        查找节点是否存在
        &quot;&quot;&quot;
        current = self.__head

        while current != None:         
            if current.elem == item:
                print(&#39;Find element %d !&#39;% item)
                return True
            else:
                current = current.next

        return False
</code></pre>

<h2 id="toc_7">单向循环列表</h2>

<p><img src="media/14969803634863/Screen%20Shot%202017-06-10%20at%2012.41.20%20PM.png" alt="Screen Shot 2017-06-10 at 12.41.20 P"/></p>

<pre><code class="language-python">class Node(object):
    &quot;&quot;&quot;
    节点
    &quot;&quot;&quot;
    def __init__(self, elem):
        self.elem = elem
        self.next = None

class SingleCycleLinkList(object):
    &quot;&quot;&quot;
    单链表
    &quot;&quot;&quot;
    def __init__(self, node = None):
        self.__head =  node  # 私有属性
        if node:
            node.next = node  #设置回环


    def is_empty(self):
        &quot;&quot;&quot;
        链表是否为空
        &quot;&quot;&quot;
        return self.__head is None

    def length(self):
        &quot;&quot;&quot;
        链表长度
        &quot;&quot;&quot;
        if self.is_empty():
            return 0
        else:
            current = self.__head # current 游标，用来移动遍历节点
            count  = 1 # count 记录数量
        
            while current.next != self.__head:
                count += 1
                current = current.next

            return count

    def travel(self):
        &quot;&quot;&quot;
        遍历整个链表
        &quot;&quot;&quot;
        current = self.__head # current 游标，用来移动遍历节点
        lists = []
        if current: # 如果链表有元素
            lists.append(current.elem)
            current = current.next
        while current is not self.__head:
            lists.append(current.elem)
            current = current.next
        print(lists)


    def add(self, item):
        &quot;&quot;&quot;
        链表头部添加元素
        &quot;&quot;&quot;
        if self.is_empty():
            self.__init__(Node(item))
        else:
            former_head = self.__head
            current = self.__head
            while current.next is not self.__head:
                current = current.next
            current.next= Node(item)
            current.next.next = former_head
            self.__head = current.next

    def append(self, item):
        &quot;&quot;&quot;
        链表尾部添加元素
        item: 具体的数据，不是class Node
        &quot;&quot;&quot;
        node = Node(item)

        # 判断链表是否为空
        if self.is_empty():
            self.__init__(node)
        else:
            current = self.__head
            while current.next != self.__head: # 遍历，找到节点尾部
                current = current.next
            current.next = node
            node.next = self.__head



    def insert(self, pos, item):
        &quot;&quot;&quot;
        指定位置添加元素
        pos: 从0开始索引
        &quot;&quot;&quot;
        if pos &lt;= 0:
            self.add(item)
        elif pos &gt;= self.length()-1:
            self.append(item)
        else:
            count = 0
            current = self.__head
            while count &lt; pos:
                previous = current
                current = current.next
                count += 1

            nodes = Node(item)
            previous.next = nodes
            nodes.next = current



    def remove(self,item):
        &quot;&quot;&quot;
        删除节点
        &quot;&quot;&quot;
        # 如果是空单向链表
        if self.is_empty():
            print(&quot;Can&#39;t find item %d&quot; % item)
            return False
        
        # 如果单向链表只有一个元素
        if self.length() == 1:
            if self.__head.elem == item:
                self.__head = None
                print(&#39;Remove the element %d&#39;%item)
                return True
            else:
                print(&quot;Can&#39;t find item %d&quot; % item)
                return False                
              
        # 通用
        current = self.__head
        # 删除第一个元素（头节点）
        if current.elem == item:

            former_head = current
            self.__head = current.next
            print(&#39;Remove the element %d&#39;%item)
            while current.next is not former_head:
                current = current.next
            current.next = self.__head
            return None
            
        else:

            while current.next != self.__head:
                if current.elem == item:
                    previous.next = current.next
                    print(&#39;Remove the element %d&#39;%item)
                    return None
                else:
                    previous = current
                    current = current.next
            
            # 处理尾部元素
            if current.elem == item:
                previous.next = self.__head
                print(&#39;Remove the element %d&#39;%item)
                return None

        print(&quot;Can&#39;t find item %d&quot; % item)


    def search(self,item):
        &quot;&quot;&quot;
        查找节点是否存在
        &quot;&quot;&quot;
        if self.is_empty():
            return False

        current = self.__head

        while current.next is not self.__head:         
            if current.elem == item:
                print(&#39;Find element %d&#39;% item)
                return True
            else:
                current = current.next
        if current.elem == item:
            return True
            print(&#39;Find element %d&#39;% item)
           
        return False
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/9</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html'>Python数据结构与算法</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14969800806372.html">
                
                  <h1>顺序表</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h3 id="toc_0">顺序表的结构</h3>

<p>一个顺序表的完整信息包括两部分，<br/>
* 数据区，表中的元素集合<br/>
* 信息区，是为实现正确操作而需记录的信息，即有关表的整体情况的信息，主要包括元素存储区的容量和当前表中已有的元素个数两项。</p>

<h3 id="toc_1">顺序表的两种基本实现形式</h3>

<ul>
<li><p><strong>一体式结构</strong>：存储表信息的单元与元素存储区以连续的方式安排在一块存储区里，两部分数据的整体形成一个完整的顺序表对象。</p></li>
<li><p><strong>分离式结构</strong>：表对象里只保存与整个表有关的信息（即容量和元素个数），实际数据元素存放在另一个独立的元素存储区里，通过链接与基本表对象关联。</p></li>
</ul>

<p>当申请内存空间不够时，只能向操作系统重新申请内存空间： 对于一体式结构，则意味着表头也需要重新申请<br/>
------&gt;一体式结构由于顺序表信息区与数据区连续存储在一起，所以若想更换数据区，则只能整体搬迁，即整个顺序表对象改变了；对于分离式结构，只需将表信息区中的数据区链接地址更新即可，该顺序表对象不变。</p>

<h3 id="toc_2">顺序表扩充</h3>

<p>顺序表扩充的两种策略</p>

<ul>
<li>每次扩充增加固定数目的存储位置，如每次扩充增加10个元素位置，这种策略可称为线性增长
特点：节省空间，但是扩充操作频繁，操作次数多</li>
<li>每次扩充容量加倍，如每次扩充增加一倍存储空间，倍增
特点：减少了扩充次数，但可能会浪费空间资源。以空间换时间，推荐的方式。</li>
</ul>

<h3 id="toc_3">顺序表增加/删除元素</h3>

<p>增加元素<br/>
* 尾端加入元素，时间复杂度为O(1)<br/>
* 非保序的加入元素(不常见)，时间复杂度为O(1)<br/>
* 保序的元素删除，时间复杂度为O(n) (常用，基本）</p>

<p>删除元素<br/>
* 删除表尾元素，时间复杂度为O(1)<br/>
* 非保序的元素删除（不常见），时间复杂度为O(1)<br/>
* 保序的元素删除，时间复杂度为O(n)</p>

<h2 id="toc_4">python中的顺序表</h2>

<p>Python 中的list和tuple两种类型采用了顺序表的实现技术。tuple是不可变类型，其他方面与list类似。</p>

<h3 id="toc_5">list的基本实现技术</h3>

<p>基于下标（位置）的高效元素访问和更新，时间复杂度是O(1)；</p>

<p>为满足该特征，应该采用顺序表技术，表中元素保存在一块连续的存储区中。</p>

<p>允许任意加入元素，而且在不断加入元素的过程中，表对象的标识（函数id得到的值）不变。</p>

<p>为满足该特征，就必须能更换元素存储区，并且为保证更换存储区时list对象的标识id不变，只能采用分离式实现技术。</p>

<p>在Python的官方实现中，list就是一种采用分离式技术实现的动态顺序表。这就是为什么用list.append(x) （或 list.insert(len(list), x)，即尾部插入）比在指定位置插入元素效率高的原因。</p>

<p>在Python的官方实现中，list实现采用了如下的策略：<br/>
<strong>在建立空表（或者很小的表）时，系统分配一块能容纳8个元素的存储区；在执行插入操作（insert或append）时，如果元素存储区满就换一块4倍大的存储区。但如果此时的表已经很大（目前的阀值为50000），则改变策略，采用加一倍的方法。引入这种改变策略的方式，是为了避免出现过多空闲的存储位置。</strong></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/9</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html'>Python数据结构与算法</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14969711309826.html">
                
                  <h1>内置LIST，DICT 时间复杂度</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">timeit 模块</h2>

<pre><code class="language-python">class timeit.Timer(stmt=&#39;pass&#39;, setup=&#39;pass&#39;, timer=&lt;timer function&gt;)
</code></pre>

<ul>
<li>Timer是测量小段代码执行速度的类。</li>
<li>stmt参数是要测试的代码语句（statment）；</li>
<li>setup参数是运行代码时需要的设置；</li>
<li>timer参数是一个定时器函数，与平台有关。</li>
</ul>

<p>timeit.Timer.timeit(number=1000000)</p>

<p>Timer类中测试语句执行速度的对象方法。number参数是测试代码时的测试次数，默认为1000000次。方法返回执行代码的平均耗时，一个float类型的秒数。</p>

<pre><code class="language-python">from timeit import Timer

li1 = [1,2]
li2 = [23,5]
li = li1+li2

li = [i for i in range(10000)]
li = list(range(10000))

def t1():
    li = []
    for i in range(10000):
        li.append(i)

def t2():
    li = []
    for i in range(10000):
        li += [i]

def t3():
    li = [ i for i in range(10000)]

def t4():
    li = list(range(10000))

timer1 = Timer(&#39;t1()&#39;,&quot;from __main__ import t1&quot;)
timer2 = Timer(&#39;t2()&#39;,&#39;from __main__ import t2&#39;)
timer3 = Timer(&#39;t3()&#39;,&#39;from __main__ import t3&#39;)
timer4 = Timer(&#39;t4()&#39;,&#39;from __main__ import t4&#39;)


print(&#39;append&#39;,timer1.timeit(1000))
print(&#39;+&#39;,timer2.timeit(1000))
print(&#39;comprehesion&#39;,timer3.timeit(1000))
print(&#39;list(range)&#39;,timer4.timeit(1000))


# pop
x = range(2000000)
pop_zero = Timer(&quot;x.pop(0)&quot;, &quot;from __main__ import x&quot;)
pop_end = Timer(&quot;x.pop()&quot;, &quot;from __main__ import x&quot;)
print(&#39;pop zero&#39;, pop_zero.timeit(1000))
print(&#39;pop end&#39;, pop_end.timeit(1000))

</code></pre>

<h2 id="toc_1">list 内置操作的时间复杂度</h2>

<pre><code>* Operatation Big-O Efficiency
* indexx[]          O(1)
* index assignment  O(1)
* append            O(1)
* pop()             O(1)    #弹出
* pop(i)            O(n)    #插入
* insert(i, item)   O(n)
* del operator      O(n)
* iteration         O(n)
* contains(in)      O(n)
* get slice[x:y]    O(k)    # 取切片
* del slice         O(n)    #删除切片
* set slice         O(n+k)  #设置切片
* reverse           O(n)
* concatenate       O(k)
* sort              O(nlogn)
* multiply          O(nk)
</code></pre>

<h2 id="toc_2">dict 内置操作的时间复杂度</h2>

<pre><code>* copy                O(n)
* get item            O(n)   #取
* set item            O(n)   #设置
* delete tiem         O(n)   #删除键
* contains(in)        O(1)    #包含，不用遍历
* iteration           O(n)    #迭代

</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/9</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html'>Python数据结构与算法</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14969711309827.html">
                
                  <h1>数据结构介绍</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">概念</h2>

<p>数据是一个抽象的概念，将其进行分类后得到程序设计语言中的基本类型。如：int，float，char等。数据元素之间不是独立的，存在特定的关系，这些关系便是结构。数据结构指数据对象中数据元素之间的关系。</p>

<p>程序= 数据结构+算法<br/>
总结：算法是为了解决实际问题而设计的，数据结构是算法需要处理的问题载体。</p>

<h2 id="toc_1">抽象数据类型(Abstract Data Type)</h2>

<p>抽象数据类型(ADT)的含义是指一个数学模型以及定义在此数学模型上的一组操作。即把数据类型和数据类型上的运算捆在一起，进行封装。引入抽象数据类型的目的是把数据类型的表示和数据类型上运算的实现与这些数据类型和运算在程序中的引用隔开，使它们相互独立。</p>

<h2 id="toc_2">内存、类型本质、连续存储</h2>

<p>内存是连续的存储空间，内存的基本存储单元是一个字节，1个字节(Byte)是8位(Bit)</p>

<p>顺序表的内存形式：</p>

<ul>
<li>逻辑地址：0,1,2,3,...,n01</li>
<li>元素存储: e0,e1,e2,e3,....,en-1</li>
<li>物理地址:l0,l0+c,l0+2c,l0+3c,l0+(n-1)c</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/9</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html'>Python数据结构与算法</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="http://or9a8nskt.bkt.clouddn.com/figure.jpeg" /></div>
            
                <h1>techlarry</h1>
                <div class="site-des">他山之石，可以攻玉</div>
                <div class="social">










<a target="_blank" class="email" href="mailto:wang.zhen.hua.larry@gmail.com" title="Email">Email</a>
  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html"><strong>Python数据结构与算法</strong></a>
        
            <a href="Python%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7.html"><strong>Python编程技巧</strong></a>
        
            <a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html"><strong>机器学习</strong></a>
        
            <a href="Python%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96.html"><strong>Python科学计算三维可视化</strong></a>
        
            <a href="English.html"><strong>English</strong></a>
        
            <a href="Linux%20%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html"><strong>Linux 系统编程</strong></a>
        
            <a href="%E6%95%B0%E6%8D%AE%E5%BA%93.html"><strong>数据库</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="14999241472668.html">Anaconda</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14999100451119.html">SQL</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="priority_queue.html">Priority queue</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="heap.html">Heap</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14992350772045.html">首先有一个概念：回溯</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2017
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    <script src="asset/chart/all-min.js"></script><script type="text/javascript">$(function(){    var mwebii=0;    var mwebChartEleId = 'mweb-chart-ele-';    $('pre>code').each(function(){        mwebii++;        var eleiid = mwebChartEleId+mwebii;        if($(this).hasClass('language-sequence')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = Diagram.parse($(this).text());            diagram.drawSVG(eleiid,{theme: 'simple'});        }else if($(this).hasClass('language-flow')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = flowchart.parse($(this).text());            diagram.drawSVG(eleiid);        }    });});</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
