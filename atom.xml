<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[techlarry]]></title>
  <link href="http://larryim.cc/atom.xml" rel="self"/>
  <link href="http://larryim.cc/"/>
  <updated>2017-07-17T11:04:33+08:00</updated>
  <id>http://larryim.cc/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Database System Concept (2): Introduction to Relational Model]]></title>
    <link href="http://larryim.cc/15002606936534.html"/>
    <updated>2017-07-17T11:04:53+08:00</updated>
    <id>http://larryim.cc/15002606936534.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Database System Concept (1): Introduction]]></title>
    <link href="http://larryim.cc/15002564768282.html"/>
    <updated>2017-07-17T09:54:36+08:00</updated>
    <id>http://larryim.cc/15002564768282.html</id>
    <content type="html"><![CDATA[
<p>A <code>database-management system</code> (DBMS，数据库管理系统) is a collection of interrelated data and a set of programs to access those data.  The collection of data, usually referred to as the <code>database</code>. The primary goal of a DBMS is to provide a way to store and retrieve database information that is both <code>convenient</code> and <code>efficient</code>.</p>

<h2 id="toc_0">Purpose of Database System</h2>

<p>Keeping organizational information in a file-processing system has a number of major disadvantages:</p>

<ul>
<li>Data redundancy and inconsistency

<ul>
<li>Users of one program may be unaware of potentially useful data held by other programs.</li>
</ul></li>
<li>Difficulty in accessing data

<ul>
<li>Programs are written to satisfy particular functions.<br/></li>
<li>Any new requirement needs a new program.</li>
</ul></li>
<li>Data isolation

<ul>
<li>Same data is held by different programs </li>
<li>Each program maintains its own set of data</li>
</ul></li>
<li>Integrity problems</li>
<li>Atomicity problems</li>
<li>Concurrent-access anomalies</li>
<li>Security problems</li>
</ul>

<h2 id="toc_1">View of data</h2>

<h3 id="toc_2">Data Abstraction</h3>

<p>The need for efficiency has led designers to use complex data structures to represent data in the database.</p>

<ul>
<li><code>Physical level</code>. The lowest level of abstraction <em>how</em> the data are actually stored</li>
<li><code>Logical level</code>. The next-higher level of abstraction describes <em>what</em> data are stored in the database, and what relationships exist among those data. Each record is described by a type definition, and the interrelationship of these record types is defined as well.</li>
<li><code>View level</code>. The highest level of abstraction describes only part of the entire data. The system may provide many views for the same database. Computer users see a set of application programs that hide details of the data types.</li>
</ul>

<p><img src="media/15002564768282/Screen%20Shot%202017-07-17%20at%2010.08.36%20AM.png" alt="The three views of data abstraction"/></p>

<h3 id="toc_3">Instances and Schemas</h3>

<ul>
<li><code>Instance</code>: the collection of information stored in the database at a particular moment</li>
<li><code>schema</code>: the overall design of the database.</li>
</ul>

<p>Database systems have several schemas, partitioned according to the levels of abstraction. The <code>Physical schema</code> describes the database design at the physical level, while the <code>logical schema</code> describes the database design at the logical level.</p>

<p>Applications programs are said to exhibit <code>physical data independence</code> if they do not depend on the <code>physical schema</code>, and thus need not be rewritten if the physical schema changes.</p>

<h3 id="toc_4">Data Models</h3>

<p><code>Data Model</code>(数据库): a collection of conceptual tools for describing data, data relationships, data semantics, and consistency constraints.</p>

<ul>
<li><code>Relational Model</code>(关系数据库)</li>
<li><code>Entity-Relationship Model</code> (实体对象模型)</li>
<li><code>Object-Based Data Model</code> (基于对象的数据模型)</li>
<li><code>Semistructed Data Model</code></li>
</ul>

<h2 id="toc_5">Database Language</h2>

<p>A database system provides a <code>data-definition language</code>(DDL) to specify the database schema and a <code>data-manipulation language</code>(DML) to express database queries and updates.</p>

<h2 id="toc_6">Data Storage and Querying</h2>

<p>A database system is partitioned into modules that deal with each of the responsibilities of the overall system. The functional components of a database system can be broadly divided into the <code>storage manager</code> and the <code>query processor</code></p>

<p>The <code>storage manager</code> is the component of a database system that provides the interface between the low-level data stored in the database and the application programs and queries submitted to the system. it is responsible for storing, retrieving, and updating data in the database. The storage manager translates the various DML statement into low-level file-system commands.</p>

<p>The <code>query processor</code> includes:</p>

<ul>
<li><code>DDL interpreter</code>, which interprets DDL statements and records the definitions in the data dictionary.</li>
<li><code>DML compiler</code>, which translates DML statements in a query language into an evaluation plan consisting of low-level instructions that the query evaluation engine understands.</li>
<li><code>Query evaluation engine</code>, which executes low-level instructions generated by the DML compiler.</li>
</ul>

<h2 id="toc_7">Transaction management</h2>

<p><code>Transaction management</code> ensures that the database remains in a consistent (correct) state despite system failures. The transaction manager ensures that concurrent transaction executions proceed without conflicting.</p>

<h2 id="toc_8">Database Architecture</h2>

<p>The architecture of a database system is greatly influenced by the underlying computer system on which the database system runs. Database system can be centralized, or client-server, where one server machine executes work on behalf of multiple client machines.</p>

<p><img src="media/15002564768282/Screen%20Shot%202017-07-17%20at%2010.55.20%20AM.png" alt="System Structure"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Recursion Iteration Performace]]></title>
    <link href="http://larryim.cc/recursion_iteration.html"/>
    <updated>2017-07-16T09:45:43+08:00</updated>
    <id>http://larryim.cc/recursion_iteration.html</id>
    <content type="html"><![CDATA[
<p>The performance of <code>Recursion</code> v.s. <code>Iteration</code> depends on the language being used.</p>

<p>In Java, C, and Python, <code>recursion</code> is fairly expensive compared to <code>iteration</code> (in general) because it requires the allocation of a new <code>stack frame</code>. In some C compilers, one can use a compiler flag to eliminate this overhead, which transforms certain types of recursion (actually, certain types of tail calls) into jumps instead of function calls.</p>

<h2 id="toc_0">Stack Frame</h2>

<p>When a function is called in Python, a <code>stack frame</code> is allocated to handle the local variables of the function. When the function returns, the return value is left on the top of the stack for the calling function to access.</p>

<p>The stack frame provide a <code>scope</code> for the variables used by the function. Even though we are calling the same function over and over, each call creates a new scope for the variables that are local to the function.</p>

<h3 id="toc_1">Get Stack Frame</h3>

<p>The <code>inspect</code> module in <code>python</code> provides several useful functions to help get information about live objects such as modules, classes, methods, functions, tracebacks, <code>frame objects</code>, and code objects.</p>

<pre><code class="language-python">import inspect

def f1():
    names = []
    # inpect.currentframe
    # Return the frame object for the caller’s stack frame.
    frame = inspect.currentframe()
  
    ## Keep moving to next outer frame
    while True:
        try:
            frame = frame.f_back # next outer frame object (this frame’s caller)
            name = frame.f_code.co_name # name with which this code object was defined
            names.append(name)
        except:
            break
    return names
    
def f2():
   return f1()

def f3():
   return f2()

def f4():
   return f3()

print(f4())
</code></pre>

<p>The results shows:</p>

<pre><code class="language-python">[&#39;f2&#39;, &#39;f3&#39;, &#39;f4&#39;, &#39;&lt;module&gt;&#39;]
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dijkstra's algorithm]]></title>
    <link href="http://larryim.cc/dijkstra_algorithm.html"/>
    <updated>2017-07-14T14:35:59+08:00</updated>
    <id>http://larryim.cc/dijkstra_algorithm.html</id>
    <content type="html"><![CDATA[
<p><code>Dijkstra&#39;s algorithm</code> is an iterative algorithm that provides us with the shortest path from one particular starting node to all other nodes in the graph.</p>

<p>The algorithm iterates once for every vertex in the graph. The order that iterates over the vertices is controlled by a <code>priority queue</code>. When a vertex is first created <code>dist</code> is set to a very large number(<code>sys.maxsize</code>)</p>

<pre><code class="language-python">from priorityqueue import PriorityQueue
from graph import Graph, Vertex
import sys
import unittest

def dijkstra(aGraph, start):
    &quot;&quot;&quot;
    Find Single-Source shortest-paths on a weighted, directed graph
    Return shortest path
    aGraph: class Graph
    start: class Vertex
    &quot;&quot;&quot;
    pq = PriorityQueue()
    start.setDistance(0)
    pq.buildHeap([(v.getDistance(), v) for v in aGraph])
    while not pq.isEmpty():
        u = pq.delMin()
        for adjacent in u.getConnections():
            newDist = u.dist + u.getWeight(adjacent)
            if adjacent.dist &gt; newDist:
                adjacent.setDistance(newDist)
                adjacent.setPred(u)
                pq.decreaseKey(adjacent, newDist)


class TestDijkstra(unittest.TestCase):


    def testShortest(self):

        aGraph = Graph()
        with open(&#39;dijkstraData.txt&#39;) as infile:
            for line in infile:
                numbers = [number for number in line.split()]
                from_v = int(numbers[0])

                for to_v_cost in numbers[1:]:
                    to_v, cost = to_v_cost.split(&#39;,&#39;)
                    aGraph.addEdge(from_v, int(to_v), int(cost))

        dijkstra(aGraph, aGraph.getVertex(1))

        dists = []
        for vertex_id in [7, 37, 59, 82, 99, 115, 133, 165, 188, 197]:
            dist = aGraph.getVertex(vertex_id).getDistance()
            if dist == sys.maxsize:
                dist = 100000
            dists.append(dist)
        assert dists == [2599, 2610, 2947, 2052, 2367, 2399, 2029, 2442, 2505, 3068]


if __name__ == &#39;__main__&#39;:
    unittest.main()
</code></pre>

<p>It is important to note that <code>Dijkstra&#39;s algorithm</code> works only when the weights are all positive. If you introduced a negative weight on one of the edges to the graph that the algorithm would never exit.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing]]></title>
    <link href="http://larryim.cc/testing.html"/>
    <updated>2017-07-14T10:33:50+08:00</updated>
    <id>http://larryim.cc/testing.html</id>
    <content type="html"><![CDATA[
<p><a href="https://en.wikipedia.org/wiki/Unit_testing">Unit testing</a> is a software testing method by which individual units of source code, sets of one or more computer program modules together with associated control data, usage procedures, and operating procedures, are tested to determine whether they are fit for use.</p>

<h2 id="toc_0">Test-driven programming</h2>

<p>&quot;<strong>Test first and code later</strong>&quot; practice, known as test-driven programming, instead of test after code.</p>

<h3 id="toc_1">Requirement Specification</h3>

<p>When developing a piece of software, you must first know what problem the software will solve—what objectives it will meet. You can clarify your goals for the program by writing a <strong>requirement specification</strong>, a document (or just some quick notes) describing requirements the program must satisfy. </p>

<h3 id="toc_2">The 1-2-3-4 of Testing</h3>

<p>Here’s a breakdown of the test-driven development process:</p>

<ul>
<li>Figure out the new feature you want. Possibly document it, and then write a test for it.</li>
<li>Write some skeleton code for the feature, so that you program runs without any syntax errors. See your test fail.</li>
<li>Write dummy code for skeleton code, just to appease the test.</li>
<li>Rewrite the code so that it actually pass the test.</li>
</ul>

<h2 id="toc_3">Testing Tools</h2>

<p>Two brilliant modules are available to automate the testing process:</p>

<ul>
<li><code>unittest</code>: A generic testing framework.</li>
<li><code>doctest</code>: A simpler module, designed for checking documentation, but excellent for writing unit tests as well.</li>
</ul>

<h3 id="toc_4">doctest</h3>

<p>The <code>testmod</code> function checks both the module docstring and function docstring.</p>

<p>E.g.</p>

<pre><code class="language-python">def square(x):
    &quot;&quot;&quot;
    squares a number and returns the result.
    &gt;&gt;&gt; square(2)
    4
    &gt;&gt;&gt; square(3)
    9
    &quot;&quot;&quot;
    return x*x

if __name__ == &quot;__main__&quot;:
    import doctest, doc_test_example
    doctest.testmod(doc_test_example)
</code></pre>

<p>Run the example. To get some more output, just add <code>-v</code>(for verbose)</p>

<pre><code class="language-bash">$ python doc_test_example.py -v
Trying:
    square(2)
Expecting:
    4
ok
Trying:
    square(3)
Expecting:
    9
ok
1 items had no tests:
    doc_test_example
1 items passed all tests:
   2 tests in doc_test_example.square
2 tests in 2 items.
2 passed and 0 failed.
Test passed.
</code></pre>

<h3 id="toc_5">unittest</h3>

<p><code>unittest</code> which is based on the popular test framework <code>JUnit</code>, is more flexible and powerful. It allows to write very large and thorough test sets in a more structured manner.</p>

<p><strong>注意： 测试方法应该以test为前缀命名</strong></p>

<p>E.g.</p>

<pre><code class="language-python">import unittest
import doc_test_example as my_math

class ProductTestCase(unittest.TestCase):

    def testIntegers(self):
        for x in xrange(-10,10):
            p = my_math.square(x)
            self.failUnless(p == x*x, &#39;Integer multiplication failed&#39;)

    def testFloats(self):
        for x in xrange(-10,10):
            x = x/10.0
            p = my_math.square(x)
            self.failUnless(p == x*x, &#39;Float multiplication failed&#39;)


if __name__ == &quot;__main__&quot;:
    unittest.main()
</code></pre>

<p>Another example to test <code>dijkstra&#39;s algorithm</code> see <a href="http://larryim.cc/dijkstra_algorithm.html">here</a></p>

<p>Methods such as <code>failUnless</code> check a condition to determine whether the given test succeeds or fails. </p>

<p>The <code>unittest</code> module distinguishes between <code>errors</code>, where an exception is raised, and <code>failures</code>, which result from calls to <code>failUnless</code> and the like. </p>

<h2 id="toc_6">Source Code Checking</h2>

<p><a href="https://www.pylint.org">Pylint</a> and PyChecker are good tools for checking Python source code, looking for mistakes.</p>

<p><code>Pylint</code> is a tool that checks for errors in Python code, tries to enforce a coding standard and looks for code smells. It can also look for certain type errors, it can recommend suggestions about how particular blocks can be refactored and can offer you details about the code’s complexity.</p>

<p><code>Pylint</code> can be integrated with <code>Pycharm</code>, see <a href="https://pylint.readthedocs.io/en/latest/user_guide/ide-integration.html#pylint-in-pycharm">detail</a>.</p>

<h3 id="toc_7">Resources</h3>

<ul>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-pylint/index.html">如何使用 Pylint 来规范 Python 代码风格</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0008/">Style Guide for Python Code</a></li>
</ul>

<h2 id="toc_8">Profile</h2>

<p><strong>When in doubt, use brute force</strong></p>

<p>The standard library includes nice profiler modules called <code>profile</code> and <code>cProfile</code>.  </p>

<p>A <code>profile</code> is a set of statistics that describes how often and for how long various parts of the program executed. </p>

<pre><code class="language-python">&gt;&gt;&gt; import profile
&gt;&gt;&gt; from my_math import square
&gt;&gt;&gt; profile.run(&#39;square(1, 2)&#39;)
</code></pre>

<p>Another way to use <code>profile</code> in command-line:</p>

<pre><code class="language-bash">$ python -m profile prof1py
</code></pre>

<p>The standard library also contains a module called <code>timeit</code>, which is a simple way of timing small snippets of Python code.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Anaconda]]></title>
    <link href="http://larryim.cc/anaconda.html"/>
    <updated>2017-07-13T13:35:47+08:00</updated>
    <id>http://larryim.cc/anaconda.html</id>
    <content type="html"><![CDATA[
<p><a href="https://www.continuum.io/why-anaconda">Anaconda </a>(/ˌænə&#39;kɑndə/)是一个用于科学计算的python发行版，支持各种系统，提供了包管理和环境管理的功能。Anaconda 利用<code>conda</code>来进行package和environment的管理。</p>

<h2 id="toc_0">Conda的包管理</h2>

<p><code>Conda</code>既是一个工具，也是一个可执行命令，其核心功能是包管理和环境管理。包管理与<code>pip</code>使用类似。</p>

<pre><code class="language-python"># 安装package
conda install package

# 查看已经安装的packages
conda list

# 查找package信息
conda search package

# 更新package
conda update -n python27 package

# 删除package
conda remove -n python27 package
</code></pre>

<h2 id="toc_1">Conda的环境管理</h2>

<pre><code class="language-bash"># 创建一个名为python27的环境，指定Python版本是2.7
conda create --name python27 python=2.7

# 安装好后，使用activate激活某个环境
source activate python27 # 激活后，会发现terminal输入的地方多了python27的字样，实际上，此时系统做的事情就是把默认环境从PATH中去除，再把2.7对应的命令加入PATH

# 如果想返回python 2.7环境，运行
source deactivate python27 # for Linux &amp; Mac

# 删除一个已有的环境
conda remove --name python27 --all
</code></pre>

<h2 id="toc_2">使用Pycharm</h2>

<p>在<code>Pycharm</code>配置里选用<code>Anaconda</code>的<code>python</code>编译器所在位置即可。</p>

<h2 id="toc_3">Resources</h2>

<p><a href="https://conda.io/docs/_downloads/conda-cheatsheet.pdf">Conda Cheat Sheet</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Database and SQL]]></title>
    <link href="http://larryim.cc/database_and_SQL.html"/>
    <updated>2017-07-13T09:40:45+08:00</updated>
    <id>http://larryim.cc/database_and_SQL.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">Database</a>
</li>
<li>
<a href="#toc_1">Primary key</a>
</li>
<li>
<a href="#toc_2">SQL</a>
</li>
<li>
<a href="#toc_3">Concepts</a>
</li>
<li>
<a href="#toc_4">SQL syntax rules</a>
</li>
<li>
<a href="#toc_5">List of SQL commands</a>
</li>
<li>
<a href="#toc_6">SQL Operators</a>
<ul>
<li>
<a href="#toc_7">Comparison Operators</a>
</li>
<li>
<a href="#toc_8">Logical Operators</a>
</li>
</ul>
</li>
<li>
<a href="#toc_9">Functions</a>
</li>
<li>
<a href="#toc_10">Subqueires</a>
</li>
<li>
<a href="#toc_11">Joining Tables</a>
<ul>
<li>
<a href="#toc_12">Types of Join</a>
</li>
</ul>
</li>
<li>
<a href="#toc_13">Resources</a>
</li>
</ul>


<h2 id="toc_0">Database</h2>

<p>A <code>Database</code> is a collection of data that is organized in a manner that facilitates ease of access, as well as efficient management and updating.</p>

<p>A database is made up of <code>tables</code> that store relevant information. Databases often contain multiple tables, each designed for a specific purpose.</p>

<h2 id="toc_1">Primary key</h2>

<p>A <code>primary key</code>(主键) is a field in the table that uniquely identifies the table records.</p>

<p>The primary key&#39;s main features:</p>

<ul>
<li>It must contain a unique value for each row.</li>
<li>It cannot contain <code>Null</code> values.</li>
<li>Tables are limited to <strong>One</strong> primary key each.</li>
<li>The primary key&#39;s value must be different for each row.</li>
</ul>

<h2 id="toc_2">SQL</h2>

<p><strong>SQL</strong>, <code>Structured Query Language</code>(结构化查询语言), is a programming language designed to manage data stored in <code>relational databases</code>(关系数据库). </p>

<p><strong>SQL</strong> operates through simple, declarative statements. This keeps data accurate and secure, and helps maintain the integrity of databases, regardless of size.</p>

<p><strong>SQL</strong> is used to access and manipulate a <strong>database</strong>, <code>MySQL</code> is a program that understands <strong>SQL</strong>.</p>

<p><strong>SQL</strong> can:</p>

<ul>
<li>Insert, update, or delete records in a database.</li>
<li>Create new databases, tables, stored procedures, views.</li>
<li>retrieve data from a database, etc.</li>
</ul>

<p><strong>Common Data types</strong> in SQL are <code>Integer</code>, <code>Text</code>, <code>Date</code>, and <code>Real</code>.</p>

<p>A <code>Null</code> value in SQL represents missing or unknown data.</p>

<h2 id="toc_3">Concepts</h2>

<ul>
<li>A <code>relational database</code> is a database that organizes information into one or more tables. </li>
<li>A <code>table</code> is a collection of data organized into rows and columns. Tables are sometimes referred to as<code>relations</code>.</li>
<li>A <code>column</code> is a set of data values of a particular type. </li>
<li>A <code>row</code> is a single record in a table. </li>
<li>A <code>statement</code> is text that the database recognizes as a valid command. Statements always end in a semi-colon ; The structure of SQL statements vary. The number of lines used do not matter. A statement can be written all on one line, or split up across multiple lines if it makes it easier to read.</li>
<li><code>Clauses</code> in a <code>statement</code> perform specific tasks in SQL. By convention, clauses are written in capital letters. Clauses can also be referred to as <code>commands</code>.</li>
<li>A <code>fully qualified name</code> puts the table name prior to the column name, by separating them a dot. E.g. customer.City. It is especially useful with multiple tables that may share the same column names.</li>
</ul>

<h2 id="toc_4">SQL syntax rules</h2>

<ol>
<li><p>SQL allows to run multiple queries or commands at the same time. We should end each SQL statement with a <strong>semicolon</strong> to indicate that the statement is complete and ready to be interpreted.</p></li>
<li><p>SQL is case <strong>insensitive</strong>. </p></li>
<li><p>A single SQL statement can be placed on one or more text lines. In addition, multiple SQL statements can be combined on a single text line. </p></li>
</ol>

<h2 id="toc_5">List of SQL commands</h2>

<p>Glossary of commonly used SQL commands:</p>

<p><code>ALTER TABLE</code></p>

<pre><code class="language-SQL">ALTER TABLE table_name ADD column datatype;
</code></pre>

<p><strong>ALTER TABLE</strong> lets you add columns to a table in a database.</p>

<p><code>AND</code></p>

<pre><code class="language-SQL">SELECT column_name(s)
FROM table_name
WHERE column_1 = value_1
AND column_2 = value_2;
</code></pre>

<p>AND is an operator that combines two conditions. Both conditions must be true for the row to be included in the result set.</p>

<p><code>AS</code></p>

<pre><code class="language-SQL">SELECT column_name AS &#39;Alias&#39;
FROM table_name;
</code></pre>

<p><strong>AS</strong> is a keyword in SQL that allows you to rename a column or table using an alias.</p>

<p><code>AVG</code></p>

<pre><code class="language-SQL">SELECT AVG(column_name)
FROM table_name;
</code></pre>

<p><strong>AVG()</strong> is an aggregate function that returns the average value for a numeric column.</p>

<p><code>BETWEEN</code></p>

<pre><code class="language-SQL">SELECT column_name(s)
FROM table_name
WHERE column_name BETWEEN value_1 AND value_2;
The BETWEEN operator is used to filter the result set within a certain range. The values can be numbers, text or dates.
</code></pre>

<p><code>COUNT</code></p>

<pre><code class="language-SQL">SELECT COUNT(column_name)
FROM table_name;
</code></pre>

<p><strong>COUNT()</strong> is a function that takes the name of a column as an argument and counts the number of rows where the column is not NULL.</p>

<p><code>CREATE TABLE</code></p>

<pre><code class="language-SQL">CREATE TABLE table_name (column_1 datatype, column_2 datatype, column_3 datatype);
</code></pre>

<p><strong>CREATE TABLE</strong> creates a new table in the database. It allows you to specify the name of the table and the name of each column in the table.</p>

<p><code>DELETE</code></p>

<pre><code class="language-SQL">DELETE FROM table_name WHERE some_column = some_value;
</code></pre>

<p><strong>DELETE</strong> statements are used to remove rows from a table.</p>

<p><code>GROUP BY</code></p>

<pre><code class="language-SQL">SELECT COUNT(*)
FROM table_name
GROUP BY column_name;
</code></pre>

<p><strong>GROUP BY</strong> is a clause in SQL that is only used with aggregate functions. It is used in collaboration with the SELECT statement to arrange identical data into groups.</p>

<p><code>INNER JOIN</code></p>

<pre><code class="language-SQL">SELECT column_name(s) FROM table_1
JOIN table_2
ON table_1.column_name = table_2.column_name;
</code></pre>

<p>An <strong>inner join</strong> will combine rows from different tables if the join condition is true.</p>

<p><code>INSERT</code></p>

<pre><code class="language-SQL">INSERT INTO table_name (column_1, column_2, column_3) VALUES (value_1, &#39;value_2&#39;, value_3);
</code></pre>

<p><strong>INSERT</strong> statements are used to add a new row to a table.</p>

<p><code>LIKE</code></p>

<pre><code class="language-SQL">SELECT column_name(s)
FROM table_name
WHERE column_name LIKE pattern;
</code></pre>

<p><strong>LIKE</strong> is a special operator used with the WHERE clause to search for a specific pattern in a column. SQL <code>pattern</code> matching enables you to use <code>_</code> to match any single character and <code>%</code> to match an arbitrary number of characters (including zero characters).</p>

<p><code>LIMIT</code></p>

<pre><code class="language-SQL">SELECT column_name(s)
FROM table_name
LIMIT number;
</code></pre>

<p><strong>LIMIT</strong> is a clause that lets you specify the maximum number of rows the result set will have.</p>

<p><code>MAX</code></p>

<pre><code class="language-SQL">SELECT MAX(column_name)
FROM table_name;
</code></pre>

<p><strong>MAX()</strong> is a function that takes the name of a column as an argument and returns the largest value in that column.</p>

<p><code>MIN</code></p>

<pre><code class="language-SQL">SELECT MIN(column_name)
FROM table_name;
MIN() is a function that takes the name of a column as an argument and returns the smallest value in that column.
</code></pre>

<p><code>OR</code></p>

<pre><code class="language-SQL">SELECT column_name
FROM table_name
WHERE column_name = value_1
OR column_name = value_2;
</code></pre>

<p><strong>OR</strong> is an operator that filters the result set to only include rows where either condition is true.</p>

<p><code>ORDER BY</code></p>

<pre><code class="language-SQL">SELECT column_name
FROM table_name
ORDER BY column_name1, column_name2 ASC|DESC;
</code></pre>

<p><strong>ORDER BY</strong> is a clause that indicates you want to sort the result set by a particular column either alphabetically or numerically.</p>

<p><code>OUTER JOIN</code></p>

<pre><code class="language-SQL">SELECT column_name(s) FROM table_1
LEFT JOIN table_2
ON table_1.column_name = table_2.column_name;
</code></pre>

<p>An <strong>outer join</strong> will combine rows from different tables even if the the join condition is not met. Every row in the left table is returned in the result set, and if the join condition is not met, then NULL values are used to fill in the columns from the right table.</p>

<p><code>ROUND</code></p>

<pre><code class="language-SQL">SELECT ROUND(column_name, integer)
FROM table_name;
</code></pre>

<p><strong>ROUND()</strong> is a function that takes a column name and an integer as an argument. It rounds the values in the column to the number of decimal places specified by the integer.</p>

<p><code>SELECT</code></p>

<pre><code class="language-SQL">SELECT column_name FROM table_name;
</code></pre>

<p><strong>SELECT</strong> statements are used to fetch data from a database. Every query will begin with SELECT.</p>

<p><code>SELECT DISTINCT</code></p>

<pre><code class="language-SQL">SELECT DISTINCT column_name FROM table_name;
</code></pre>

<p><strong>SELECT DISTINCT</strong> specifies that the statement is going to be a query that returns unique values in the specified column(s).</p>

<p><code>SUM</code></p>

<pre><code class="language-SQL">SELECT SUM(column_name)
FROM table_name;
</code></pre>

<p><strong>SUM()</strong> is a function that takes the name of a column as an argument and returns the sum of all the values in that column.</p>

<p><code>UPDATE</code></p>

<pre><code class="language-SQL">UPDATE table_name
SET some_column = some_value
WHERE some_column = some_value;
</code></pre>

<p><strong>UPDATE</strong> statments allow you to edit rows in a table.</p>

<p><code>WHERE</code></p>

<pre><code class="language-SQL">SELECT column_name(s)
FROM table_name
WHERE column_name operator value;
</code></pre>

<p><strong>WHERE</strong> is a clause that indicates you want to filter the result set to include only rows where the following condition is true. eg. <code>SELECT * FROM customers WHERE ID=7</code>;</p>

<h2 id="toc_6">SQL Operators</h2>

<p>Comparison Operators and Logical Operators are used in the <code>WHERE</code> clause to filter the data to be selected.</p>

<h3 id="toc_7">Comparison Operators</h3>

<p>The following comparison operators can be used in the <code>WHERE</code> clause:</p>

<table>
<thead>
<tr>
<th>Operator</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>=</td>
<td>Equal</td>
</tr>
<tr>
<td>!=</td>
<td>Not equal</td>
</tr>
<tr>
<td>&gt;</td>
<td>Greater than</td>
</tr>
<tr>
<td>&lt;</td>
<td>Less than </td>
</tr>
<tr>
<td>&gt;=</td>
<td>Greater than or equal</td>
</tr>
<tr>
<td>&lt;=</td>
<td>Less than or equal</td>
</tr>
<tr>
<td>BETWEEN</td>
<td>Between an inclusive range</td>
</tr>
</tbody>
</table>

<p><code>BETWEEN</code> Operator:</p>

<pre><code class="language-SQL">SELECT * FROM customers
WHERE ID BETWEEN 3 AND 7;
</code></pre>

<h3 id="toc_8">Logical Operators</h3>

<p>Logical operators can be used to combine two Boolean values and return a result of <strong>true</strong>, <strong>false</strong>, or <strong>null</strong>.</p>

<p>The following operators exists in SQL:</p>

<table>
<thead>
<tr>
<th>Operator</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>AND</td>
<td>TRUE if both expressions are TRUE</td>
</tr>
<tr>
<td>OR</td>
<td>TRUE if either expression is TRUE</td>
</tr>
<tr>
<td>IN</td>
<td>TRUE if the operand is equal to one of a list of expressions</td>
</tr>
<tr>
<td>NOT</td>
<td>Returns TRUE if expression is not TRUE</td>
</tr>
</tbody>
</table>

<p>The <code>IN</code> Operator:</p>

<pre><code class="language-SQL">SELECT * FROM customers 
WHERE City IN (&#39;New York&#39;, &#39;Los Angeles&#39;, &#39;Chicago&#39;);
</code></pre>

<p>The <code>NOT IN</code> Operator:</p>

<pre><code class="language-SQL">SELECT * FROM customers 
WHERE City NOT IN (&#39;New York&#39;, &#39;Los Angeles&#39;, &#39;Chicago&#39;);
</code></pre>

<h2 id="toc_9">Functions</h2>

<p>The <code>UPPER</code> function converts all letters in the specified string to uppercase. <br/>
The <code>LOWER</code> function converts the string to lowercase.</p>

<p>The following SQL query selects all <em>Lastnames</em> as uppercase:</p>

<pre><code class="language-SQL">SELECT FirstName, UPPER(LastName) AS LastName 
FROM employees;
</code></pre>

<p>The <code>SQRT</code> function returns the square root of given value in the argument.<br/>
Similarly, the <code>AVG</code> function returns the average value of a numeric column.<br/>
The <code>SUM</code> function is used to calculate the sum for a column&#39;s values.</p>

<p>The <code>MIN</code> function is used to return the minimum value of an expression in a <code>SELECT</code> statement.</p>

<p>E.g. you might wish to know the minimum salary among the employees:</p>

<pre><code class="language-SQL">SELECT MIN(salary) AS Salary FROM employees;
</code></pre>

<h2 id="toc_10">Subqueires</h2>

<p>A subquery is a query within another query. Enclose the subquery in parentheses. </p>

<p>E.g.</p>

<pre><code class="language-SQL">SELECT FirstName, Salary FROM employees 
WHERE  Salary &gt; (SELECT AVG(Salary) FROM employees) 
ORDER BY Salary DESC;
</code></pre>

<h2 id="toc_11">Joining Tables</h2>

<p>SQL can combine data from multiple tables. In SQL, &#39;joining tables&#39; means combining data from two or more tables. A table join creates a <code>temporary table</code> showing the data from the joined tables.</p>

<p>To join tables, specify them as a comma-separated list in the <code>FROM</code> clause:</p>

<pre><code class="language-SQL">SELECT customers.ID, customers.Name, orders.Name, orders.Amount FROM customers, orders
WHERE customers.ID = orders.Customer_ID
ORDER BY customers.ID
</code></pre>

<h3 id="toc_12">Types of Join</h3>

<p>The following are types of <code>JOIN</code> that can be used in SQL:</p>

<ul>
<li><code>INNER JOIN</code>: returns rows when there is a match between the tables.</li>
<li><code>LEFT JOIN</code>: returns rows from the left table, even if there are no matches in the right table.</li>
</ul>

<pre><code class="language-SQL">SELECT table1.column1, table2.column2...
FROM table1 LEFT JOIN table2
ON table1.column_name = table2.column_name;
</code></pre>

<p>If no match is found for a particular row,<code>NULL</code>is returned.</p>

<ul>
<li><code>RIGHT JOIN</code>
Just like <code>LEFT JOIN</code></li>
</ul>

<h2 id="toc_13">Resources</h2>

<ol>
<li><p><a href="https://www.codecademy.com/courses/learn-sql/lessons/manipulation/exercises/relational-databases?action=lesson_resume">Codecademy</a></p></li>
<li><p><a href="https://www.sololearn.com/Play/SQL">Sololearn</a></p></li>
<li><p><a href="http://www.w3school.com.cn/sql/index.asp">W3school</a></p></li>
<li><p><a href="https://lagunita.stanford.edu/courses/DB/2014/SelfPaced/about">Standford MOOC</a> </p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Priority queue]]></title>
    <link href="http://larryim.cc/priority_queue.html"/>
    <updated>2017-07-12T10:09:04+08:00</updated>
    <id>http://larryim.cc/priority_queue.html</id>
    <content type="html"><![CDATA[
<p><strong>A priority queue</strong>(优先队列) is an ADP which likes a regular queue or stack , but where additionally each element has a <code>priority</code> associated with it. In a priority queue, an element with high priority is served before an element with low priority. If two elements have the same priority, they are served according to their order in the queue.</p>

<p>A priority queue must at least support the following operations:</p>

<ul>
<li><code>insert_with_priority</code>: add an element to the queue with an associated priority.</li>
<li><code>pull_highest_priority_element</code>: remove the element from the queue that has the highest priority, and return it.</li>
<li><code>peek</code> :return the highest-priority element but does not modify the queue</li>
</ul>

<h2 id="toc_0">Naive Implementation</h2>

<p>There are a variety of simple, usually inefficient, ways to implement a priority queue. They provide an analogy to help one understand what a priority queue is. For instance, one can keep all the elements in an unsorted list. Whenever the highest-priority element is requested, search through all elements for the one with the highest priority. (In big O notation: \(O(1)\) insertion time, \(O(n)\) pull time due to search.)</p>

<h2 id="toc_1">Heap Implementation</h2>

<pre><code class="language-python">class PriorityQueue:
    def __init__(self):
        self.heapArray = [(0, 0)]
        self.currentSize = 0

    def buildHeap(self, alist):
        &quot;&quot;&quot;
        &quot;&quot;&quot;从一个包含元素的列表创建新堆&quot;&quot;&quot;
        :param alist: a list
        &quot;&quot;&quot;
        self.currentSize = len(alist)
        self.heapArray = [(0, 0)]
        for i in alist:
            self.heapArray.append(i)
        i = len(alist) // 2
        while (i &gt; 0):
            self.percDown(i)
            i = i - 1

    def percDown(self, i):
        &quot;&quot;&quot;
        Percolate the ith node down the tree
        &quot;&quot;&quot;
        while (i * 2) &lt;= self.currentSize:
            mc = self.minChild(i)
            if self.heapArray[i][0] &gt; self.heapArray[mc][0]:
                tmp = self.heapArray[i]
                self.heapArray[i] = self.heapArray[mc]
                self.heapArray[mc] = tmp
            i = mc

    def minChild(self, i):
        &quot;&quot;&quot;
        Find the smallest child
        &quot;&quot;&quot;
        if i * 2 &gt; self.currentSize:
            return -1
        else:
            if i * 2 + 1 &gt; self.currentSize:
                return i * 2
            else:
                if self.heapArray[i * 2][0] &lt; self.heapArray[i * 2 + 1][0]:
                    return i * 2
                else:
                    return i * 2 + 1

    def percUp(self, i):
        &quot;&quot;&quot;
        Percolate the ith node up the tree
        &quot;&quot;&quot;
        while i // 2 &gt; 0:
            if self.heapArray[i][0] &lt; self.heapArray[i // 2][0]:
                tmp = self.heapArray[i // 2]
                self.heapArray[i // 2] = self.heapArray[i]
                self.heapArray[i] = tmp
            i = i // 2

    def add(self, k):
        self.heapArray.append(k)
        self.currentSize = self.currentSize + 1
        self.percUp(self.currentSize)

    def delMin(self):
        &quot;&quot;&quot;
        delete the min-vertex of heap array, which always in the first position.
        &quot;&quot;&quot;
        retval = self.heapArray[1][1]
        self.heapArray[1] = self.heapArray[self.currentSize]
        self.currentSize = self.currentSize - 1
        self.heapArray.pop()
        self.percDown(1)
        return retval

    def isEmpty(self):
        &quot;&quot;&quot;
        return true if the heapArray is empty
        &quot;&quot;&quot;
        if self.currentSize == 0:
            return True
        else:
            return False

    def decreaseKey(self, val, amt):
        &quot;&quot;&quot;
        Decrease the key of the specific vertex (here, val)

        First, find its position in the heapArray: myKey
        Second, set its position to the right
        &quot;&quot;&quot;
        done = False
        i = 1
        myKey = 0
        while not done and i &lt;= self.currentSize:
            if self.heapArray[i][1] == val:
                done = True
                myKey = i
            else:
                i = i + 1
        if myKey &gt; 0:
            self.heapArray[myKey] = (amt, self.heapArray[myKey][1])
            self.percUp(myKey)

    def __contains__(self, vtx):
        &quot;&quot;&quot;
        Built-in Magic method
        &quot;&quot;&quot;
        for pair in self.heapArray:
            if pair[1] == vtx:
                return True
        return False
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Heap]]></title>
    <link href="http://larryim.cc/heap.html"/>
    <updated>2017-07-12T10:09:03+08:00</updated>
    <id>http://larryim.cc/heap.html</id>
    <content type="html"><![CDATA[
<p>A <strong>heap</strong> (堆)is a specialized tree-based data structure。 A <strong>heap</strong> can be classified as either a <strong>max heap</strong> or a <strong>min heap</strong>. </p>

<ul>
<li>In a <strong>max heap</strong>, the keys of parent nodes are always greater than or equal to those of the children and the highest key is in the root node. </li>
<li>In a <strong>min heap</strong>, the keys of parent nodes are less than or equal to those of the children and the lowest key is in the root node.</li>
</ul>

<p><strong>Heap</strong> is one maximally efficient implementation of an abstract data type called a <strong>priority queue</strong> (see <a href="http://larryim.cc/priority_queue.html">here</a>), and in fact priority queues are often referred to as <strong>heaps</strong>, regardless of how they may be implemented. </p>

<h2 id="toc_0">Implementation</h2>

<p>Priority queues typically use a heap as backbone, giving \(O(\log n)\) performance for inserts and removals, and \(O(n \log n)\) to build initially.</p>

<h2 id="toc_1">Binary Heap</h2>

<p>A common implementation of a heap is the <strong>binary heap</strong>(二叉堆), in which the tree is a <strong>complete binary tree</strong>(完全二叉树). </p>

<p>二叉堆的操作与实现</p>

<ul>
<li><code>BinaryHeap()</code>：创建一个新的、空的二叉堆对象</li>
<li><code>insert(k)</code>：把新元素加入到堆中</li>
<li><code>findMin()</code>：返回堆中的最小项，最小项仍保留在堆中</li>
<li><code>delMin()</code>：返回堆中的最小项，同时从堆中删除</li>
<li><code>isEmpty()</code>：返回堆是否为空</li>
<li><code>size()</code>：返回堆中元素的个数</li>
<li><code>buildHeap(list)</code>：从一个包含元素的列表创建新堆</li>
</ul>

<p>有两个关键的操作：<br/>
1. <code>insert</code>方法。首先，为了满足“完全二叉树”的性质，新键值应该添加到列表的末尾。然而新键值简单地添加在列表末尾，显然无法满足堆次序。所以要通过比较父节点和新加入的元素的方法来重新满足堆次序。如果新加入的元素比父节点要小，可以与父节点互换位置；不断交换，直到到达树的顶端。下图所示一系列交换操作来使新加入元素“上浮”到正确的位置。</p>

<p><img src="media/14973171257726/14974156268132.jpg" alt=""/></p>

<p>2.<code>delMin</code>方法 移走根节点的元素后如何保持堆结构和堆次序: 首先，用最后一个节点来代替根节点, 移走最后一个节点保持了堆结构的性质。这么简单的替换，还是会破坏堆次序。第二步，将新节点“下沉”来恢复堆次序。下图所示的是一系列交换操作来使新节点“下沉”到正确的位置。</p>

<p><img src="media/14973171257726/14974156980805.jpg" alt=""/></p>

<pre><code class="language-python">class BinHeap(object):
    &quot;&quot;&quot;
    创建一个新的、空的二叉堆对象
    &quot;&quot;&quot;
    def __init__(self):
        self.list = [0]
        self.size = 0

    def perc_up(self,i):
        &quot;&quot;&quot;
        Percolate the new node into proper position
        &quot;&quot;&quot;
        while i: 
            if self.list[i] &lt; self.list[i//2]:
                self.list[i], self.list[i//2] = self.list[i//2], self.list[i]
            i = i//2
    
    def insert(self, item):
        &quot;&quot;&quot;把新元素加入到堆中&quot;&quot;&quot;
        self.list.append(item)
        self.size += 1
        self.perc_up(self.size)

    def findMin(self):
        &quot;&quot;&quot;返回堆中的最小项，最小项仍保留在堆中&quot;&quot;&quot;
        return self.list[1]

    def delMin(self):
        &quot;&quot;&quot;返回堆中的最小项，同时从堆中删除&quot;&quot;&quot;
        retval = self.list[1]
        self.list[1] = self.list[-1]
        self.size -=1
        self.list.pop()
        self.perc_down(1)

        return retval


    def perc_down(self, i):
        &quot;&quot;&quot;
        Percolate the root node  down the tree
        &quot;&quot;&quot;
        while i*2 &lt;= self.size:
            if i*2+1 &gt; self.size:
                self.list[i*2], self.list[i] = self.list[i], self.list[i*2]
                i = i*2
            else:
                if self.list[i*2] &gt; self.list[i*2+1]:
                    self.list[i*2+1], self.list[i] =  self.list[i], self.list[i*2+1]
                    i = i*2+1
                else:
                    self.list[i*2], self.list[i] = self.list[i], self.list[i*2]
                    i = i*2


    def isEmpty(self):
        &quot;&quot;&quot;返回堆是否为空&quot;&quot;&quot;
        return self.size == 0

    def __len__(self):
        &quot;&quot;&quot;返回堆中元素的个数&quot;&quot;&quot;
        return self.size

    def buildHeap(self,alist):
        &quot;&quot;&quot;从一个包含元素的列表创建新堆&quot;&quot;&quot;
        self.size = len(alist)
        self.list.extend(alist)
        i = self.size//2
        while i &gt;0:
            self.perc_down(i)
            i -= 1

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[首先有一个概念：回溯]]></title>
    <link href="http://larryim.cc/14992350772045.html"/>
    <updated>2017-07-05T14:11:17+08:00</updated>
    <id>http://larryim.cc/14992350772045.html</id>
    <content type="html"><![CDATA[
<p>　　回溯法(探索与回溯法)是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p>

<p>深度优先算法：</p>

<p>（1）访问初始顶点v并标记顶点v已访问。<br/>
（2）查找顶点v的第一个邻接顶点w。<br/>
（3）若顶点v的邻接顶点w存在，则继续执行；否则回溯到v，再找v的另外一个未访问过的邻接点。<br/>
（4）若顶点w尚未被访问，则访问顶点w并标记顶点w为已访问。<br/>
（5）继续查找顶点w的下一个邻接顶点wi，如果v取值wi转到步骤（3）。直到连通图中所有顶点全部访问过为止。</p>

<p>广度优先算法：</p>

<p>（1）顶点v入队列。<br/>
（2）当队列非空时则继续执行，否则算法结束。<br/>
（3）出队列取得队头顶点v；访问顶点v并标记顶点v已被访问。<br/>
（4）查找顶点v的第一个邻接顶点col。<br/>
（5）若v的邻接顶点col未被访问过的，则col入队列。<br/>
（6）继续查找顶点v的另一个新的邻接顶点col，转到步骤（5）。直到顶点v的所有未被访问过的邻接点处理完。转到步骤（2）。</p>

<p>代码：</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Graph]]></title>
    <link href="http://larryim.cc/graph_basic.html"/>
    <updated>2017-06-30T13:56:30+08:00</updated>
    <id>http://larryim.cc/graph_basic.html</id>
    <content type="html"><![CDATA[
<p>Definition: A graph can be represented by \(G\) where \(G=(V,E)\). For the graph \(G\), \(V\) is a set of vertices and \(E\) is a set of edges. Each edge is a tuple \((v,w)\) where \(w, v \in V\). </p>

<h2 id="toc_0">Vocabulary and Definitions</h2>

<ul>
<li><p>Vertex<br/>
A <code>vertex</code> ( also a <code>node</code>) is a fundamental part of a graph. It can have a name <code>key</code>. A vertex may also have additional information called <code>payload</code>.</p></li>
<li><p>Edge<br/>
An <code>Edge</code> (also an <code>arc</code>) connects two vertices, and may be one-way(<code>directed graph</code>) or two-way(<code>undirected graph</code>).</p></li>
<li><p>Weight<br/>
Edges may be weighted to show that there is a cost (<code>weight</code>)to go from one vertex to another. E.g. the distance between the two cities.</p></li>
<li><p>Path<br/>
A <code>path</code> in a graph is a sequence of vertices that are connected by edges. Formally we could define a path as \(w_1, w_2,...,w_n\) such that \((w_i,w_{i+1}) \in E\) for all \(1 \le i \le  n-1\). The weighted path length is the sum of the weights of the edges in the path. </p></li>
<li><p>Cycle<br/>
A <code>cycle</code> in a directed graph is a graph that starts and ends at the same vertex.  A graph with no cycles is called an <code>acyclic graph</code>. A directed graph with no cycles is called a <code>directed acyclic graph</code> or a <code>DAG</code>.</p></li>
</ul>

<h2 id="toc_1">Representation</h2>

<p>Adjacency Matrix<br/>
Adjacency List<br/>
Edge List<br/>
<img src="media/14988021902558/Screen%20Shot%202017-06-30%20at%202.06.25%20PM.png" alt="Screen Shot 2017-06-30 at 2.06.25 P"/></p>

<p>A <code>path</code> in a graph \(G\) is a sequence of vertices \(v_0,v_1,...,v_n\) so that for all \(i, (v_i,v_{i+1})\) is an edge of \(G\).</p>

<h2 id="toc_2">The graph ADT</h2>

<p>The graph abstract data type (ADT) is defined as follows:</p>

<ul>
<li><code>Graph()</code> creates a new, empty graph.</li>
<li><code>addVertex(vert)</code> adds an instance of <code>Vertex</code> to the graph.</li>
<li><code>addEdge(fromVert, toVert)</code>Adds a new, directed edge to the graph that connects two vertices.</li>
<li><code>addEdge(fromVert, toVert, weight)</code> Adds a new, weighted, directed edge to the graph that connects two vertices.</li>
<li><code>getVertex(vertKey)</code> finds the vertex in the graph named vertKey.</li>
<li><code>getVertices()</code> returns the list of all vertices in the graph.</li>
<li><code>in</code> returns <code>True</code> for a statement of the form vertex in graph, if the given vertex is in the graph,<code>False</code> otherwise.</li>
</ul>

<h2 id="toc_3">Implementation</h2>

<p>We will create two classes, <code>Graph</code>, which holds the master list of vertices, and <code>Vertex</code>, which will represent each vertex in the graph.</p>

<p>Each <code>Vertex</code> uses a dictionary to keep track of the vertices to which it is connected, and the weight of each edge. This dictionary is called <code>connectedTo</code>. The listing below shows the code for the <code>Vertex</code> class. The constructor simply initializes the <code>id</code>, which will typically be a string, and the <code>connectedTo</code> dictionary. The <code>addNeighbor</code> method is used add a connection from this vertex to another. The g<code>etConnections</code> method returns all of the vertices in the adjacency list, as represented by the <code>connectedTo</code>instance variable. The <code>getWeight</code> method returns the weight of the edge from this vertex to the vertex passed as a parameter.</p>

<pre><code class="language-python">class Vertex:
    def __init__(self,key):
        self.id = key
        self.connectedTo = {}

    def addNeighbor(self,nbr,weight=0):
        self.connectedTo[nbr] = weight

    def __str__(self):
        return str(self.id) + &#39; connectedTo: &#39; + str([x.id for x in self.connectedTo])

    def getConnections(self):
        return self.connectedTo.keys()

    def getId(self):
        return self.id

    def getWeight(self,nbr):
        return self.connectedTo[nbr]
</code></pre>

<p>The <code>Graph</code> class, shown in the next listing, contains a dictionary that maps vertex names to vertex objects. <code>Graph</code> also provides methods for adding vertices to a graph and connecting one vertex to another. The <code>getVertices</code> method returns the names of all of the vertices in the graph. In addition, we have implemented the <code>__iter__</code> method to make it easy to iterate over all the vertex objects in a particular graph. Together, the two methods allow you to iterate over the vertices in a graph by name, or by the objects themselves.</p>

<pre><code class="language-python">class Graph:
    def __init__(self):
        self.vertList = {}
        self.numVertices = 0

    def addVertex(self,key):
        self.numVertices = self.numVertices + 1
        newVertex = Vertex(key)
        self.vertList[key] = newVertex
        return newVertex

    def getVertex(self,n):
        if n in self.vertList:
            return self.vertList[n]
        else:
            return None

    def __contains__(self,n):
        return n in self.vertList

    def addEdge(self,f,t,cost=0):
        if f not in self.vertList:
            nv = self.addVertex(f)
        if t not in self.vertList:
            nv = self.addVertex(t)
        self.vertList[f].addNeighbor(self.vertList[t], cost)

    def getVertices(self):
        return self.vertList.keys()

    def __iter__(self):
        return iter(self.vertList.values())
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Machine Learning (5): Neural Networks]]></title>
    <link href="http://larryim.cc/14987831190581.html"/>
    <updated>2017-06-30T08:38:39+08:00</updated>
    <id>http://larryim.cc/14987831190581.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">Why Neural Networks</a>
</li>
<li>
<a href="#toc_1">Background of Neural Networks</a>
</li>
<li>
<a href="#toc_2">Model Representation</a>
</li>
<li>
<a href="#toc_3">Examples and Intuitions</a>
</li>
<li>
<a href="#toc_4">Multiclass Classification</a>
</li>
</ul>


<h2 id="toc_0">Why Neural Networks</h2>

<p>The number of quadratic features closes to \(\frac{n^2}{2}\), it is computationally expensive.</p>

<p>The number of cubic features closes to \(O(n^3)\), it is more computationally expensive.</p>

<p>Computer vision problem looks at matrixes. Because dimensions of pixel images often large (e.g. n= 7500 for 50\(\times\)50 pixel images(RGB)), the number of quadratic features for the problem are 3 million.</p>

<h2 id="toc_1">Background of Neural Networks</h2>

<p><strong>Origins</strong>: Algorithms that try to mimic the brain. It was very widely used in 80s and early 90s; popularity diminished in late 90s. It is now a state of the art technique for many application, because its expensive computation can be meet.</p>

<p>Input wire: Dendrite<br/>
Output wire: Axon</p>

<h2 id="toc_2">Model Representation</h2>

<p>At a very simple level, neurons are basically computational units that take inputs (<code>dendrites</code>) as electrical inputs (<code>spikes</code>) that are channeled to outputs (<code>axons</code>). </p>

<p>In neural networks, dendrites are like the input features \(x_1⋯x_n\), and the output is the result of our hypothesis function. \(x_0\) input node is sometimes called the <code>bias unit</code>. It is always equal to 1. In neural networks, we use the same logistic function as in classification, \(\frac{1}{1+e^{-\theta^Tx}}\), yet we sometimes call it a sigmoid (logistic) activation function. In this situation, our &quot;theta&quot; parameters are sometimes called <code>weights</code>.</p>

<p><strong>Visually, a simplistic representation looks like:</strong><br/>
\[\begin{bmatrix}x_0 \newline x_1 \newline x_2 \newline \end{bmatrix}\rightarrow\begin{bmatrix}\ \ \ \newline \end{bmatrix}\rightarrow h_\theta(x)\]</p>

<p>Input nodes (layer 1), also known as the <code>input layer</code>, go into another node (layer 2), which finally outputs the hypothesis function, known as the <code>output layer</code>.</p>

<p>We can have intermediate layers of nodes between the input and output layers called the <code>hidden layers</code>.</p>

<p>In this example, we label these intermediate or hidden layer nodes \(a^2_0⋯a^2_n\) and call them <code>activation units</code>.</p>

<p>\[\begin{align*}&amp; a_i^{(j)} = \text{&quot;activation&quot; of unit $i$ in layer $j$} \newline&amp; \Theta^{(j)} = \text{matrix of weights controlling function mapping from layer $j$ to $j+1$}\end{align*}\]</p>

<p>The values for each of the &quot;activation&quot; nodes is obtained as follows:</p>

<p>\[\begin{align*} a_1^{(2)} = g(\Theta_{10}^{(1)}x_0 + \Theta_{11}^{(1)}x_1 + \Theta_{12}^{(1)}x_2 + \Theta_{13}^{(1)}x_3) \newline a_2^{(2)} = g(\Theta_{20}^{(1)}x_0 + \Theta_{21}^{(1)}x_1 + \Theta_{22}^{(1)}x_2 + \Theta_{23}^{(1)}x_3) \newline a_3^{(2)} = g(\Theta_{30}^{(1)}x_0 + \Theta_{31}^{(1)}x_1 + \Theta_{32}^{(1)}x_2 + \Theta_{33}^{(1)}x_3) \newline h_\Theta(x) = a_1^{(3)} = g(\Theta_{10}^{(2)}a_0^{(2)} + \Theta_{11}^{(2)}a_1^{(2)} + \Theta_{12}^{(2)}a_2^{(2)} + \Theta_{13}^{(2)}a_3^{(2)}) \newline \end{align*}\]</p>

<p>If network has \(s_j\) units in layer \(j\) and \(s_{j+1}\) units in layer \(j+1\), then \(\Theta^{(j)}\) will be of dimension \(s_{j+1}×(s_j+1)\). The \(+1\) comes from the addition in \(\Theta^{(j)}\) of the <code>bias nodes</code>, \(x_0\) and \(\Theta^{(j)}_0\). In other words the output nodes will not include the bias nodes while the inputs will. </p>

<p>We&#39;re going to define a new variable \(z^{(j)}_k\) that encompasses the parameters inside our \(g\) function. In our previous example if we replaced by the variable \(z\) for all the parameters we would get:</p>

<p>\[\begin{align*}a_1^{(2)} = g(z_1^{(2)}) \newline a_2^{(2)} = g(z_2^{(2)}) \newline a_3^{(2)} = g(z_3^{(2)}) \newline \end{align*}\]</p>

<p>In other words, for layer \(j=2\) and node \(k\), the variable \(z\) will be:</p>

<p>\[z_k^{(2)} = \Theta_{k,0}^{(1)}x_0 + \Theta_{k,1}^{(1)}x_1 + \cdots + \Theta_{k,n}^{(1)}x_n\]</p>

<p>The vector representation of \(x\) and \(z_j\) is:</p>

<p>\[\begin{align*}x = \begin{bmatrix}x_0 \newline x_1 \newline\cdots \newline x_n\end{bmatrix} &amp;z^{(j)} = \begin{bmatrix}z_1^{(j)} \newline z_2^{(j)} \newline\cdots \newline z_n^{(j)}\end{bmatrix}\end{align*}\]</p>

<p>Setting \(x=a^{(1)}\), we can rewrite the equation as:</p>

<p>\[z^{(j)} = \Theta^{(j-1)}a^{(j-1)}\]</p>

<p>Now we can get a vector of our activation nodes for layer \(j\) as follows:</p>

<p>\[a^{(j)} = g(z^{(j)})\]</p>

<p>Last Step:<br/>
\[h_\Theta(x) = a^{(j+1)} = g(z^{(j+1)})\]</p>

<h2 id="toc_3">Examples and Intuitions</h2>

<p>The \(\Theta^{(1)}\) matrices for AND, NOR, and OR are:</p>

<p>\[\begin{align*}AND:\newline\Theta^{(1)} &amp;=\begin{bmatrix}-30 &amp; 20 &amp; 20\end{bmatrix} \newline NOR:\newline\Theta^{(1)} &amp;= \begin{bmatrix}10 &amp; -20 &amp; -20\end{bmatrix} \newline OR:\newline\Theta^{(1)} &amp;= \begin{bmatrix}-10 &amp; 20 &amp; 20\end{bmatrix} \newline\end{align*}\]</p>

<p>We can combine these to get the \(XNOR\) logical operator (which gives 1 if \(x_1\) and \(x_2\) are both 0 or both 1).</p>

<p>\[\begin{align*}\begin{bmatrix}x_0 \newline x_1 \newline x_2\end{bmatrix} \rightarrow\begin{bmatrix}a_1^{(2)} \newline a_2^{(2)} \end{bmatrix} \rightarrow\begin{bmatrix}a^{(3)}\end{bmatrix} \rightarrow h_\Theta(x)\end{align*}\]</p>

<p>For the transition between the first and second layer, we&#39;ll use a \(\Theta^{(1)}\) matrix that combines the values for AND and NOR:</p>

<p>\[\Theta^{(1)} =\begin{bmatrix}-30 &amp; 20 &amp; 20 \newline 10 &amp; -20 &amp; -20\end{bmatrix}\]</p>

<p>For the transition between the second and third layer, we&#39;ll use a \(\Theta^{(2)}\) matrix that uses the value for OR:</p>

<p>\[\Theta^{(2)} =\begin{bmatrix}-10 &amp; 20 &amp; 20\end{bmatrix}\]</p>

<p>Let&#39;s write out the values for all our nodes:</p>

<p>\[\begin{align*}&amp; a^{(2)} = g(\Theta^{(1)} \cdot x) \newline&amp; a^{(3)} = g(\Theta^{(2)} \cdot a^{(2)}) \newline&amp; h_\Theta(x) = a^{(3)}\end{align*}\]</p>

<h2 id="toc_4">Multiclass Classification</h2>

<p>To classify data into multiple classes, we let our hypothesis function return a vector of values. Say we wanted to classify our data into one of four categories. We will use the following example to see how this classification is done. This algorithm takes as input an image and classifies it accordingly:</p>

<p><img src="media/14987831190581/14987929949268.png" alt=""/></p>

<p>We can define our set of resulting classes as \(y\):</p>

<p><img src="media/14987831190581/14987930862309.png" alt=""/></p>

<p>Each \(y(i)\) represents a different image corresponding to either a car, pedestrian, truck, or motorcycle. The inner layers, each provide us with some new information which leads to our final hypothesis function. The setup looks like:</p>

<p><img src="media/14987831190581/14987931059100.png" alt=""/></p>

<p>Our resulting hypothesis for one set of inputs may look like:</p>

<p>\[h_\Theta(x) =\begin{bmatrix}0 \newline 0 \newline 1 \newline 0 \newline\end{bmatrix}\]</p>

<p>In which case our resulting class is the third one down, or \(h_\Theta(x)_3\), which represents the motorcycle.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Machine Learning (4): Overfitting and normalization]]></title>
    <link href="http://larryim.cc/14987114340830.html"/>
    <updated>2017-06-29T12:43:54+08:00</updated>
    <id>http://larryim.cc/14987114340830.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">The problem of Overfitting</a>
</li>
<li>
<a href="#toc_1">Regularized Linear Regression</a>
<ul>
<li>
<a href="#toc_2">Normal Equation</a>
</li>
</ul>
</li>
<li>
<a href="#toc_3">Regularized Logistic Regression</a>
</li>
</ul>


<h2 id="toc_0">The problem of Overfitting</h2>

<p><strong>Underfitting</strong>, or <strong>high bias</strong>, is when the form of our hypothesis function \(h\) maps poorly to the trend of the data. It is usually caused by a function that is too simple or uses too few features. </p>

<p><strong>Overfitting</strong>, or <strong>high variance</strong>, is caused by a hypothesis function that fits the available data but does not generalize well to predict new data. It is usually caused by a complicated function that creates a lot of unnecessary curves and angles unrelated to the data.</p>

<p>There are two main options to address the issue of overfitting:</p>

<ol>
<li><p><strong><em>Reduce the number of features</em></strong>:<br/>
Manually select which features to keep.<br/>
(Use a model selection algorithm).</p></li>
<li><p><strong><em>Regularization</em></strong><br/>
Keep all the features, but reduce the magnitude of parameters \(\theta_j\). Regularization works well when we have a lot of slightly useful features.</p></li>
</ol>

<p><img src="media/14985711297859/14987109337751.png" alt="sd"/></p>

<p>The figure above shows the Underfitting, Normal, Overfitting.</p>

<h2 id="toc_1">Regularized Linear Regression</h2>

<p>We regularize all of theta parameters in a single summation as:</p>

<p>\[J(\theta)= \dfrac{1}{2m}[ \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})^2 + \lambda\ \sum_{j=1}^n \theta_j^2]\]</p>

<p>where the \(\lambda\), or lambda, is the <strong>regularization parameter</strong>. It determines how much the costs of our theta parameters are inflated.  If \(\lambda\) is chosen to be too large, it may smooth out the function too much and cause underfitting. </p>

<p><strong>Note that you should not regularize the parameter \(\theta_0\)</strong>.</p>

<p>The corresponding gradient descent is</p>

<p>\[\begin{align*} &amp; \text{Repeat}\ \lbrace \newline &amp; \ \ \ \ \theta_0 := \theta_0 - \alpha\ \frac{1}{m}\ \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})x_0^{(i)} \newline &amp; \ \ \ \ \theta_j := \theta_j - \alpha\ \left[ \left( \frac{1}{m}\ \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})x_j^{(i)} \right) + \frac{\lambda}{m}\theta_j \right] &amp;\ \ \ \ \ \ \ \ \ \ j \in \lbrace 1,2...n\rbrace\newline &amp; \rbrace \end{align*}\]</p>

<p>With some manipulation our update rule can also be represented as:<br/>
\[\theta_j := \theta_j(1 - \alpha\frac{\lambda}{m}) - \alpha\frac{1}{m}\sum_{i=1}^m(h_\theta(x^{(i)}) - y^{(i)})x_j^{(i)}\]</p>

<h3 id="toc_2">Normal Equation</h3>

<p>To add in regularization, the equation is the same as our original, except that we add another term inside the parentheses:</p>

<p>\[\begin{align*}&amp; \theta = \left( X^TX + \lambda \cdot L \right)^{-1} X^Ty \newline&amp; \text{where}\ \ L = \begin{bmatrix} 0 &amp; &amp; &amp; &amp; \newline &amp; 1 &amp; &amp; &amp; \newline &amp; &amp; 1 &amp; &amp; \newline &amp; &amp; &amp; \ddots &amp; \newline &amp; &amp; &amp; &amp; 1 \newline\end{bmatrix}\end{align*}\]</p>

<p>Recall that if \(m &lt; n\), then \(XTX\) is non-invertible. However, when we add the term \(\lambda L\), then \(XTX + \lambda L\) becomes invertible.</p>

<h2 id="toc_3">Regularized Logistic Regression</h2>

<p>We regularize all of \(\theta\) parameters in a single summation as:</p>

<p>\[ J(\theta) = -\dfrac{1}{m} \sum_{i=1}^m[ y ^{(i)}\log(h_\theta(x^{(i)}))+(1-y^{(i)}) \log(1-h_\theta(x^{(i)}))]+ \frac{\lambda}{2m} \sum_{j=1}^n \theta_j^2\]</p>

<p>The corresponding gradient descent is<br/>
\[\theta_j:=\theta_j-\frac{\alpha}{m}\Sigma^m_{i=1}(h_\theta(x^{(i)})-y^{(i)})x^{(i)}_j+\frac{\alpha\lambda}{m}\theta_j\]</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[口语]]></title>
    <link href="http://larryim.cc/14987012023353.html"/>
    <updated>2017-06-29T09:53:22+08:00</updated>
    <id>http://larryim.cc/14987012023353.html</id>
    <content type="html"><![CDATA[
<ol>
<li>发音 native</li>
<li>流畅度</li>
<li>地道的语料</li>
</ol>

<p>方法</p>

<ol>
<li>逐句跟读   <strong>不看原文</strong></li>
<li>影子跟读</li>
<li>全文复数  用到关键词句</li>
</ol>

<p>每天2个小时，1个小时跟读，1个小时背诵和跟读</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Machine Learning (3): Classification]]></title>
    <link href="http://larryim.cc/14985711297859.html"/>
    <updated>2017-06-27T21:45:29+08:00</updated>
    <id>http://larryim.cc/14985711297859.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">Binary Classification</a>
<ul>
<li>
<a href="#toc_1">Examples</a>
</li>
<li>
<a href="#toc_2">Hypothesis Representation</a>
</li>
<li>
<a href="#toc_3">Decision boundary</a>
</li>
<li>
<a href="#toc_4">Cost Function</a>
</li>
<li>
<a href="#toc_5">Gradient Descent</a>
</li>
<li>
<a href="#toc_6">Advanced Optimization</a>
</li>
</ul>
</li>
<li>
<a href="#toc_7">Multiclass classification</a>
<ul>
<li>
<a href="#toc_8">Example</a>
</li>
<li>
<a href="#toc_9">Method</a>
</li>
</ul>
</li>
</ul>


<p>The classification problem is just like the regression problem, except that the values y we now want to predict take on only a small number of discrete values.</p>

<h2 id="toc_0">Binary Classification</h2>

<p><strong>Binary classification problem</strong> : y can take on only two values, 0 and 1.</p>

<h3 id="toc_1">Examples</h3>

<ul>
<li>Email: Spam/Not Spam?</li>
<li>Online Transaction: Fraudulent(Yes/NO)?</li>
<li>Tumor: Malignant/ Benign?</li>
</ul>

<p>Given \(x(i)\), the corresponding \(y(i)\) is also called the <strong>label</strong> for the training example.</p>

<h3 id="toc_2">Hypothesis Representation</h3>

<p>It doesn&#39;t make sense for \(h_\theta(x)\) to take values larger than 1 or smaller than0, when we know that \( y\in \{0,1\}\). To fix this, let&#39;s change the form for our hypotheses \(h_\theta(x)\) to satisfy \(0\leq_\theta(x)\leq 1\). This is accomplished by plugging \(\theta^Tx\) into the Logistic Function.</p>

<p><strong>Logistic Function</strong>:<br/>
also called sigmoid (/&#39;sɪgmɔɪd/) function<br/>
   \[\begin{align*}&amp; h_\theta (x) = g ( \theta^T x ) \newline \newline&amp; z = \theta^T x \newline&amp; g(z) = \dfrac{1}{1 + e^{-z}}\end{align*}\]</p>

<ol>
<li><p>The sigmoid function g(z), maps any real number to the (0, 1) interval, making it useful for transforming an arbitrary-valued function into a function better suited for classification.</p></li>
<li><p>\(h_\theta(x)\) gives us the probability that our output is 1. Probability that prediction is 0 is just the complement of probability that it is 1:</p></li>
</ol>

<p>\[\begin{align*}&amp; h_\theta(x) = P(y=1 | x ; \theta) = 1 - P(y=0 | x ; \theta) \newline&amp; P(y = 0 | x;\theta) + P(y = 1 | x ; \theta) = 1\end{align*}\]</p>

<h3 id="toc_3">Decision boundary</h3>

<p>The <strong>decision boundary</strong> is the line that separates the area where y = 0 and where y = 1. It is defined by hypothesis function.</p>

<h3 id="toc_4">Cost Function</h3>

<p>We cannot use the same cost function that we use for linear regression because the Logistic Function will cause the output to be wary, causing many local optima.</p>

<p>Instead, our cost function for logistic regression looks like:</p>

<p>\[\begin{align*}&amp; J(\theta) = \dfrac{1}{m} \sum_{i=1}^m \mathrm{Cost}(h_\theta(x^{(i)}),y^{(i)}) \newline &amp; \mathrm{Cost}(h_\theta(x),y) = -\log(h_\theta(x)) \; &amp; \text{if y = 1} \newline &amp; \mathrm{Cost}(h_\theta(x),y) = -\log(1-h_\theta(x)) \; &amp; \text{if y = 0}\end{align*}\]</p>

<p>Cost function&#39;s two conditional cases can be compressed into one case:<br/>
\[Cost(h_\theta(x),y)= -y \log(h_\theta(x))-(1-y) \log(1-h_\theta(x))\]</p>

<p>The entire cost function can be written as follows:</p>

<p>\[ J(\theta) = -\dfrac{1}{m} \sum_{i=1}^m[ y ^{(i)}\log(h_\theta(x^{(i)}))+(1-y^{(i)}) \log(1-h_\theta(x^{(i)}))]\]</p>

<p>A vectorized implementation is:<br/>
\[h=g(X\theta)\]<br/>
\[J(\theta)=\frac{1}{m}(-y^T\log(h)-(1-y)^T\log(1-h))\]</p>

<p>And the gradient of the cost is a vector of the same length as \(\theta\) where the \(j^{th}\) element is defined as follows:</p>

<p>\[\frac{\partial J(\theta)}{\partial \theta_j}=\frac{1}{m}\Sigma_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x^{(i)}_j\]</p>

<p>A vectorized implementation is:<br/>
\[\frac{\partial J(\theta)}{\partial \theta_j}=\frac{1}{m}(h-y)^TX\]</p>

<h3 id="toc_5">Gradient Descent</h3>

<p>Repeat until {</p>

<p>\[\theta_j:=\theta_j-\frac{\alpha}{m}\Sigma^m_{i=1}(h_\theta(x^{(i)})-y^{(i)})x^{(i)}_j\]<br/>
}</p>

<p>A vectorized implementation is:</p>

<p>\[\theta:=\theta-\frac{\alpha}{m}X^T(g(X\theta)-y)\]</p>

<h3 id="toc_6">Advanced Optimization</h3>

<p>There are more sophisticated, faster ways to optimize \(\theta\) that can be used instead of gradient descent:</p>

<ul>
<li>Conjugate gradient</li>
<li>BFGS</li>
<li>L-BFGS</li>
</ul>

<p>You should not write these algorithms yourself, but use the libraries provided by Octave and Matlab instead.</p>

<h2 id="toc_7">Multiclass classification</h2>

<h3 id="toc_8">Example</h3>

<ul>
<li>Email foldering/tagging: Work, friends, family, hobby</li>
<li>Medical diagrams: Not ill, Cold, Flu</li>
<li>Weather: Sunny, Cloudy, Rain, Snow</li>
</ul>

<h3 id="toc_9">Method</h3>

<p>Since \(y = \{0,1...n\}\), we divide our problem into \(n+1\) (+1 because the index starts at 0) binary classification problems; in each one, we predict the probability that &#39;y&#39; is a member of one of our classes.</p>

<p>We are basically choosing one class and then lumping all the others into a single second class. We do this repeatedly, applying binary logistic regression to each case, and then use the hypothesis that returned the highest value as our prediction.</p>

<p>\[\begin{align*}&amp; y \in \lbrace0, 1 ... n\rbrace \newline&amp; h_\theta^{(0)}(x) = P(y = 0 | x ; \theta) \newline&amp; h_\theta^{(1)}(x) = P(y = 1 | x ; \theta) \newline&amp; \cdots \newline&amp; h_\theta^{(n)}(x) = P(y = n | x ; \theta) \newline&amp; \mathrm{prediction} = \max_i( h_\theta ^{(i)}(x) )\newline\end{align*}\]</p>

<p><strong>To summarize</strong>:</p>

<p>Train a logistic regression classifier hθ(x) for each class to predict the probability that  \(y = i\) .</p>

<p>To make a prediction on a new x, pick the class that maximizes \(h_\theta(x)\)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python科学计算三维可视化]]></title>
    <link href="http://larryim.cc/14985240916710.html"/>
    <updated>2017-06-27T08:41:31+08:00</updated>
    <id>http://larryim.cc/14985240916710.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">第三方库</h2>

<ul>
<li>VTK</li>
<li>Mayavi</li>
<li>Numpy</li>
<li>PyQt4</li>
<li>Traites</li>
<li>TraitsUI</li>
</ul>

<h2 id="toc_1">实例</h2>

<ul>
<li>流体数据的标量可视化、矢量可视化实例</li>
<li>三维扫描数据（）可视化实例</li>
<li>三维地球场景可视化实例</li>
<li>曲线UI交互控制可视化实例</li>
</ul>

<h2 id="toc_2">TVTK</h2>

<p>The tvtk module (<a href="http://docs.enthought.com/mayavi/tvtk/README.html">TVTK</a>) provides a traits enabled version of VTK. TVTK objects wrap around VTK objects but additionally support traits, and provide a convenient Pythonic API. TVTK is implemented mostly in pure Python (except for a small extension module). Here is a list of current features.</p>

<h3 id="toc_3">Installation</h3>

<ol>
<li>安装 <a href="https://www.continuum.io/downloads">Anaconda</a></li>
<li>在终端依次运行：</li>
</ol>

<pre><code>    conda install vtk
    conda install numpy
    conda install traits
    conda install mayavi
    conda install PyQt
</code></pre>

<h3 id="toc_4">创建一个三维对象</h3>

<p>tvtk.CubeSource()<br/>
s = tvtk.CubeSource()</p>

<h3 id="toc_5">traits</h3>

<p>traits 就是TVTK的属性</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySql 数据库]]></title>
    <link href="http://larryim.cc/14974355508816.html"/>
    <updated>2017-06-14T18:19:10+08:00</updated>
    <id>http://larryim.cc/14974355508816.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">E-R 关系模型，</a>
</li>
<li>
<a href="#toc_1">三范式</a>
</li>
<li>
<a href="#toc_2">MySQL 数据类型</a>
</li>
<li>
<a href="#toc_3">约束</a>
</li>
</ul>


<p>数据库（Database）是按照数据结构来组织、存储和管理数据的仓库，每个数据库都有一个或多个不同的API用于创建，访问，管理，搜索和复制所保存的数据。</p>

<p><code>mysql</code>数据库，是当前应用非常广泛的一款关系型数据库。</p>

<p>数据库系统解决的问题：持久化存储，优化读写，保证数据的有效性</p>

<p>当前使用的数据库，主要分为两类：</p>

<ul>
<li>文档型，如<code>sqlite</code>, 就是一个文件，通过对文件的复制完成数据库的复制</li>
<li>服务型，如<code>mysql</code>,<code>postgre</code>, 数据存储在一个物理文件中，但是需要使用终端以tcp/ip协议连接，进行数据库的读写操作 （有服务端、客户端，客户端连接服务端）</li>
</ul>

<h2 id="toc_0">E-R 关系模型，</h2>

<p>当前物理的数据库都是按照E-R模型进行设计的。</p>

<ul>
<li>E表示Enty, 实体</li>
<li>R表示relationship, 关系</li>
<li>一个实体转换为数据库中的一个表</li>
<li><p>关系描述两个实体之间的对应规则，包括</p>

<ul>
<li>一对一</li>
<li>一对多</li>
<li>多对多</li>
</ul></li>
<li><p>关系转换为数据表中的一个利</p></li>
<li><p>在关系型数据库中一行就是一个对象。</p></li>
</ul>

<h2 id="toc_1">三范式</h2>

<p>经过研究和对使用中问题的总结，对于设计设局哭提出了一些规范，这些规范被称为范式</p>

<ul>
<li>第一范式(IF1): 列不可拆分</li>
<li>第二范式(2NF): 唯一标识</li>
<li>第三范式(3NF): 引用主键</li>
<li>说明：后一个范式，都是在前一个范式的基础上建立的</li>
</ul>

<h2 id="toc_2">MySQL 数据类型</h2>

<p>MySQL支持多种类型，这里主要列出来常用几种</p>

<ul>
<li>数字

<ul>
<li>int 整数</li>
<li>decimal 小数</li>
</ul></li>
<li>字符串

<ul>
<li>char 定长字符串</li>
<li>varchar 变长字符串</li>
<li>text 长文本数据</li>
</ul></li>
<li>日期

<ul>
<li>datetime 混合日期和时间值，时间戳</li>
</ul></li>
<li>布尔

<ul>
<li>bit </li>
</ul></li>
</ul>

<h2 id="toc_3">约束</h2>

<ul>
<li>主键约束 primary key 主键不能重复</li>
<li>非空约束 not null 比如要求姓名不能为空</li>
<li>唯一约束 unique 主键约束只能有一个，唯一约束可以有多个</li>
<li>默认约束 default 比如默认性别为男</li>
<li>外键约束 foreign key </li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python树(二)：二叉搜索树]]></title>
    <link href="http://larryim.cc/14974279917175.html"/>
    <updated>2017-06-14T16:13:11+08:00</updated>
    <id>http://larryim.cc/14974279917175.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python树(一)：二叉树和二叉堆]]></title>
    <link href="http://larryim.cc/14973171257726.html"/>
    <updated>2017-06-13T09:25:25+08:00</updated>
    <id>http://larryim.cc/14973171257726.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">定义</a>
</li>
<li>
<a href="#toc_1">树的应用</a>
</li>
<li>
<a href="#toc_2">树的术语</a>
</li>
<li>
<a href="#toc_3">树的种类</a>
</li>
<li>
<a href="#toc_4">树的存储</a>
</li>
<li>
<a href="#toc_5">树的实现</a>
<ul>
<li>
<a href="#toc_6">嵌套列表表示树</a>
</li>
<li>
<a href="#toc_7">节点和引用</a>
</li>
</ul>
</li>
<li>
<a href="#toc_8">优先队列和二叉堆</a>
<ul>
<li>
<a href="#toc_9">列表与完全二叉树</a>
</li>
<li>
<a href="#toc_10">二叉堆的操作与实现</a>
</li>
</ul>
</li>
<li>
<a href="#toc_11">分析树</a>
</li>
<li>
<a href="#toc_12">树的遍历</a>
</li>
</ul>


<p>树(tree)是一种抽象数据类型（ADT），用来模拟具有树状结构性质的数据集合。它是由\(n\)个有限节点组成一个具有层次关系的集合。树在计算机科学里应用广泛，包括操作系统，图形学，数据库和计算机网络。树和真正的树有许多相似的地方，也包括根、树枝和叶子，它们的不同在于计算机中的树的根在顶层而它的叶子在底部。它具有以下的特点：</p>

<ul>
<li>树是分级的，即树的顶层部分更加宽泛，而底部更加具体</li>
<li>一个节点（node）的所有子节点（children）和另一个节点的子节点是完全独立的</li>
<li>每个它的叶节点（leaf）都是不同的</li>
</ul>

<h2 id="toc_0">定义</h2>

<p>每个树或者为空，或者包含一个根节点和 0 个或多个子树，其中每个子树也符合这样的定义。每个子树的根节点和其父树的根节点之间通过边相连。</p>

<p>A tree is either empty or consists of a root and zeros or more subtrees, each of which is also a tree. The root of each subtree is connected to the root of the parent tree by an edge.</p>

<h2 id="toc_1">树的应用</h2>

<ul>
<li><p><strong>文件系统</strong>。在文件系统中，磁盘的分支或者说子目录都是运用了树来构建的。下图展示了Unix文件系统的部分的分层情况。<br/>
<img src="media/14973171257726/14973998176466.jpg" alt=""/></p></li>
<li><p><strong>网页</strong>。下图是一个利用超文本标记语言（HTML）编写的简单网页，以及构成网页的超文本标记语言中的标签相互关联关系所构成的树。</p></li>
</ul>

<pre><code class="language-html">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot; lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
        &lt;title&gt;simple&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;A simple web page&lt;/h1&gt;
            &lt;ul&gt;
                &lt;li&gt;List item one&lt;/li&gt;
                &lt;li&gt;List item two&lt;/li&gt;
            &lt;/ul&gt;
        &lt;h2&gt;&lt;a href=&quot;http://www.cs.luther.edu&quot;&gt;Luther CS &lt;/a&gt;&lt;h2&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p><img src="media/14973171257726/14973999293521.jpg" alt=""/></p>

<h2 id="toc_2">树的术语</h2>

<ul>
<li><p><strong>节点</strong>（Node） <br/>
节点是树的基本构成部分。它可能有其他专属的名称，我们称之为“键（key）”。一个节点也可能有更多的信息，我们称之为“负载”。虽然负载信息和树的许多算法并不直接相关，但是它对于树的应用至关重要。</p></li>
<li><p><strong>边</strong>（Edge） <br/>
边也是树的基本构成部分。边连接两个节点，并表示它们之间存在联系。除了根节点外每个节点都有且只有一条与其他节点相连的入边（指向该节点的边），每个节点可能有许多条出边（从该节点指向其他节点的边）。</p></li>
<li><p><strong>根节点</strong>（Root） <br/>
根节点是树种中唯一一个没有入边的节点。在文件系统中，“/”是树的根节点。</p></li>
<li><p><strong>路径</strong>（Path） <br/>
路径是由边连接起来的节点的有序排列。例如：（动物界——脊索动物门——哺乳动物纲——食肉动物目——猫科——猫属——家猫）就是一条路径。</p></li>
<li><p><strong>子节点集</strong>（Children） <br/>
当一个节点的入边来自另一个节点时，我们称前者是后者的子节点，同一个节点的所有子节点构成子节点集。在文件系统中，节点log/,spool/,yp/构成节点var/的子节点集。</p></li>
<li><p><strong>父节点</strong>（Parent） <br/>
一个节点是它出边所连接的所有节点的父节点。在文件系统中，节点var/是节点log/,spool/,yp/的父节点。</p></li>
<li><p><strong>兄弟节点</strong>（Sibling） <br/>
同一个节点的所有子节点互为兄弟节点，在文件系统树中节点etc/和节点usr/是兄弟节点。</p></li>
<li><p><strong>子树</strong>（Subtree） <br/>
子树是一个父节点的某个子节点的所有边和后代节点所构成的集合。</p></li>
<li><p><strong>叶节点</strong>（Leaf Node） <br/>
没有子节点的节点成为称为叶节点。</p></li>
<li><p><strong>层数</strong>（Level） <br/>
一个节点的层数是指从根节点到该节点的路径中的边的数目。定义根节点的层数为 0。</p></li>
<li><p><strong>高度</strong>（Height） <br/>
树的高度等于所有节点的层数的最大值。图 2 中树的高度为 2。</p></li>
</ul>

<h2 id="toc_3">树的种类</h2>

<ul>
<li><strong>无序树</strong>：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树；</li>
<li><strong>有序树</strong>：树中任意节点的子节点之间有顺序关系，这种树称为有序树；

<ul>
<li><strong>霍夫曼树</strong>（用于信息编码）：带权路径最短的二叉树称为哈夫曼树或最优二叉树；</li>
<li><strong>B树</strong>：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多余两个子树；</li>
<li><strong>二叉树</strong>：每个节点最多含有两个子树的树称为二叉树；

<ul>
<li><strong>完全二叉树</strong>：对于一颗二叉树，假设其深度为d(d&gt;1)。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树，其中满二叉树的定义是所有叶节点都在最底层的完全二叉树;</li>
<li><strong>平衡二叉树</strong>（AVL树）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树；</li>
<li><strong>二叉搜索树</strong>（Binary Search Tree）</li>
</ul></li>
</ul></li>
</ul>

<h2 id="toc_4">树的存储</h2>

<p>由于对节点的个数无法掌握，常见树的存储表示都转换成二叉树进行处理，子节点个数最多为2。</p>

<ul>
<li><p>嵌套列表：将数据结构存储在固定的数组中，然在遍历速度上有一定的优势，但因所占空间比较大，是非主流二叉树。二叉树通常以链式存储。</p></li>
<li><p>节点和引用：</p></li>
</ul>

<h2 id="toc_5">树的实现</h2>

<p>树可以具有以下方法：</p>

<ul>
<li><code>BinaryTree()</code> creates a new instance of a binary tree.</li>
<li><code>get_left_child()</code> returns the binary tree corresponding to the left child of the current node</li>
<li><code>get_right_child()</code> return the binary tree corresponding to the right child of the current node</li>
<li><code>set_root_val(val)</code> stores the object stored in the current node</li>
<li><code>get_root_val()</code> returns the object stored in the current node</li>
<li><code>insert_left(val)</code> creates a new binary tree and installs it as the left child of the current node</li>
<li><code>insert_right(val)</code> creates a new binary tree and installs it as the right child of the current node</li>
</ul>

<h3 id="toc_6">嵌套列表表示树</h3>

<p>在列表实现树时，我们将存储根节点作为列表的第一个元素的值。列表的第二个元素的本身是一个表示左子树的列表。这个列表的第三个元素表示在右子树的另一个列表。</p>

<pre><code class="language-python"># coding: utf-8


def BinaryTree(r):
    &quot;&quot;&quot;
    creates a new instance of a binary tree.
    &quot;&quot;&quot;
    return [r,[],[]]


def get_left_child(root):
    &quot;&quot;&quot;
    returns the binary tree corresponding to the left child of the current node
    &quot;&quot;&quot;
    return root[1]


def get_right_child(root):
    &quot;&quot;&quot;
    return the binary tree corresponding to the right child of the current node
    &quot;&quot;&quot;
    return  root[2]


def set_root_val(root, val):
    &quot;&quot;&quot;stores the object stored in the current node
    &quot;&quot;&quot;
    root[0] = val



def get_root_val(root):
    &quot;&quot;&quot;
    returns the object stored in the current node
    &quot;&quot;&quot;
    return root[0]

def insert_left(root, new_branch):
    &quot;&quot;&quot;
    creates a new binary tree and installs it as the left child of the current node

    插入一个左子节点，首先获取对应于当前左子节点的列表（可能是空的）。
    然后，添加新的左子节点，将原来的左子节点作为新节点的左子节点。
    这使我们能够将新节点插入到树中的任何位置.
    &quot;&quot;&quot;
    if root[1]:
        root[1] = [new_branch,root[1], []]
    else:
        root[1] = [new_branch, [], []]
    return root



def insert_right(root, new_branch):
    &quot;&quot;&quot;
    creates a new binary tree and installs it as the right child of the current node
    &quot;&quot;&quot;
    if root[2]:
        root[2] = [new_branch, [], root[2]]
    else:
        root[2] = [new_branch, [], []]
    return root


if __name__ == &quot;__main__&quot;:
    r = BinaryTree(3)
    insert_left(r,4)
    insert_left(r,5)
    insert_right(r,6)
    insert_right(r,7)
    l = get_left_child(r)
    print(l)

    set_root_val(l,9)
    print(r)
    insert_left(l,11)
    print(r)
    print(get_right_child(get_right_child(r)))

# result
#[5, [4, [], []], []]
#[3, [9, [4, [], []], []], [7, [], [6, [], []]]]
#[3, [9, [11, [4, [], []], []], []], [7, [], [6, [], []]]]
#[6, [], []]

</code></pre>

<h3 id="toc_7">节点和引用</h3>

<p>节点和引用方法，定义一个类，具有根、以及左、右子树属性。这种表示更紧密地结合了面向对象的方式。树的结构类似于下图所示。</p>

<p><img src="media/14973171257726/14974056999880.jpg" alt="binary tree"/></p>

<p>左右子树是其他二叉树实例的引用。例如，当插入一个新的左子节点到树上时，即创建了二叉树的另一个实例，并修改了根节点的<code>self.left_child</code>使之指向新的树。</p>

<pre><code class="language-python">
class BinaryTree(object):
    def __init__(self, root):
        self.key = root
        self.left_child = None
        self.right_child = None

    def insert_left(self, item):
        &quot;&quot;&quot;
        creates a new binary tree and installs it as the left child of the current node
        &quot;&quot;&quot;
        if self.left_child:
            self.left_child = BinaryTree(item)
        else:
            t = self.left_child
            self.left_child = BinaryTree(item)
            self.left_child.left_child = t


    def insert_right(self, item):
        &quot;&quot;&quot;
        creates a new binary tree and installs it as the right child of the current node
        &quot;&quot;&quot;
        if self.right_child:
            self.right_child = BinaryTree(item)
        else:
            t = self.right_child
            self.right_child = BinaryTree(item)
            self.right_child.right_child = t

    def get_right_child(self):
        &quot;&quot;&quot;
        return the binary tree corresponding to the right child of the current node
        &quot;&quot;&quot;
        return  self.right_child


    def get_left_child(self):
        &quot;&quot;&quot;
        return the binary tree corresponding to the left child of the current node
        &quot;&quot;&quot;
        return  self.left_child

    def set_root_val(self, root):
        &quot;&quot;&quot;
        stores the object stored in the current node
        &quot;&quot;&quot;
        self.key = root
        

    def get_root_val(self):
        &quot;&quot;&quot;
        returns the object stored in the current node
        &quot;&quot;&quot;
        return  self.key

    def pre_order(self, root):
        &quot;&quot;&quot;
        preorder traversal
        &quot;&quot;&quot;
        print(root.key, end=&#39; &#39;)
        if root.left_child:
            root.pre_order(root.left_child)
        if root.right_child:
            root.pre_order(root.right_child)

    def post_order(self, root):
        &quot;&quot;&quot;
        postorder traversal
        &quot;&quot;&quot;
        if root != None:
            self.post_order(root.left_child)
            self.post_order(root.right_child)
            print(root.key, end=&#39; &#39;)


    def pre_order(self, root):
        &quot;&quot;&quot;
        preorder traversal
        &quot;&quot;&quot;
        print(root.key, end=&#39; &#39;)
        if root.left_child:
            self.pre_order(root.left_child)
        if root.right_child:
            self.pre_order(root.right_child)       

    def in_order(self, root):
        &quot;&quot;&quot;
        postorder traversal
        &quot;&quot;&quot;
        if root != None:
            self.post_order(root.left_child)
            print(root.key, end=&#39; &#39;)  
            self.post_order(root.right_child)

</code></pre>

<h2 id="toc_8">优先队列和二叉堆</h2>

<p><strong>优先队列</strong>(Priority Queues)是一类抽象数据类型。优先队列中的每个元素都有各自的优先级，优先级最高的元素最先得到服务；优先级相同的元素按照其在优先队列中的顺序得到服务。在优先队列的内部，元素的次序是由“优先级”来决定：高优先级的元素排在队首，而低优先级的元素则排在后面。</p>

<p>实现优先队列的经典方法是采用<strong>二叉堆</strong>(Binary Heap)。因为使用二叉堆能将优先队列的入队和出队复杂度都保持在\(O(\log n)\)。 二叉堆有两种：键值总是最小的排在队首称为<strong>最小堆</strong>(min heap)，反之，键值总是最大的排在队首称为<strong>最大堆</strong>(max heap)。</p>

<p>储存元素要满足<strong>堆次序</strong>，即堆中任何一个节点\(x\)，其父节点\(p\)的键值均小于或等于\(x\)的键值。下图所示是具备堆次序性质的完全二叉树。</p>

<h3 id="toc_9">列表与完全二叉树</h3>

<p><strong>不需要使用节点，引用或嵌套列表，用单个列表就能代表完全二叉树</strong>。因为对于完全二叉树，如果节点在列表中的下标为\(p\)，那么其左子节点下标为\(2p\)，右节点为\(2p+1\)。当我们要找任何节点的父节点时，可以直接使用 python 的整除。如果节点在列表中下标为\(n\)，那么父节点下标为\(n//2\)（参考下图）。使用列表, 能够使用简单的数学方法高效地遍历一棵完全二叉树，这也导致了二叉堆的高效实现。</p>

<p><img src="media/14973171257726/14974117374605.jpg" alt=""/></p>

<h3 id="toc_10">二叉堆的操作与实现</h3>

<ul>
<li><code>BinaryHeap()</code>：创建一个新的、空的二叉堆对象</li>
<li><code>insert(k)</code>：把新元素加入到堆中</li>
<li><code>findMin()</code>：返回堆中的最小项，最小项仍保留在堆中</li>
<li><code>delMin()</code>：返回堆中的最小项，同时从堆中删除</li>
<li><code>isEmpty()</code>：返回堆是否为空</li>
<li><code>size()</code>：返回堆中元素的个数</li>
<li><code>buildHeap(list)</code>：从一个包含元素的列表创建新堆</li>
</ul>

<p>有两个关键的操作：<br/>
1. <code>insert</code>方法。首先，为了满足“完全二叉树”的性质，新键值应该添加到列表的末尾。然而新键值简单地添加在列表末尾，显然无法满足堆次序。所以要通过比较父节点和新加入的元素的方法来重新满足堆次序。如果新加入的元素比父节点要小，可以与父节点互换位置；不断交换，直到到达树的顶端。下图所示一系列交换操作来使新加入元素“上浮”到正确的位置。</p>

<p><img src="media/14973171257726/14974156268132.jpg" alt=""/></p>

<p>2.<code>delMin</code>方法 移走根节点的元素后如何保持堆结构和堆次序: 首先，用最后一个节点来代替根节点, 移走最后一个节点保持了堆结构的性质。这么简单的替换，还是会破坏堆次序。第二步，将新节点“下沉”来恢复堆次序。下图所示的是一系列交换操作来使新节点“下沉”到正确的位置。</p>

<p><img src="media/14973171257726/14974156980805.jpg" alt=""/></p>

<pre><code class="language-python">class BinHeap(object):
    &quot;&quot;&quot;
    创建一个新的、空的二叉堆对象
    &quot;&quot;&quot;
    def __init__(self):
        self.list = [0]
        self.size = 0

    def perc_up(self,i):
        &quot;&quot;&quot;
        Percolate the new node into proper position
        &quot;&quot;&quot;
        while i: 
            if self.list[i] &lt; self.list[i//2]:
                self.list[i], self.list[i//2] = self.list[i//2], self.list[i]
            i = i//2
    
    def insert(self, item):
        &quot;&quot;&quot;把新元素加入到堆中&quot;&quot;&quot;
        self.list.append(item)
        self.size += 1
        self.perc_up(self.size)

    def findMin(self):
        &quot;&quot;&quot;返回堆中的最小项，最小项仍保留在堆中&quot;&quot;&quot;
        return self.list[1]

    def delMin(self):
        &quot;&quot;&quot;返回堆中的最小项，同时从堆中删除&quot;&quot;&quot;
        retval = self.list[1]
        self.list[1] = self.list[-1]
        self.size -=1
        self.list.pop()
        self.perc_down(1)

        return retval


    def perc_down(self, i):
        &quot;&quot;&quot;
        Percolate the root node  down the tree
        &quot;&quot;&quot;
        while i*2 &lt;= self.size:
            if i*2+1 &gt; self.size:
                self.list[i*2], self.list[i] = self.list[i], self.list[i*2]
                i = i*2
            else:
                if self.list[i*2] &gt; self.list[i*2+1]:
                    self.list[i*2+1], self.list[i] =  self.list[i], self.list[i*2+1]
                    i = i*2+1
                else:
                    self.list[i*2], self.list[i] = self.list[i], self.list[i*2]
                    i = i*2


    def isEmpty(self):
        &quot;&quot;&quot;返回堆是否为空&quot;&quot;&quot;
        return self.size == 0

    def __len__(self):
        &quot;&quot;&quot;返回堆中元素的个数&quot;&quot;&quot;
        return self.size

    def buildHeap(self,alist):
        &quot;&quot;&quot;从一个包含元素的列表创建新堆&quot;&quot;&quot;
        self.size = len(alist)
        self.list.extend(alist)
        i = self.size//2
        while i &gt;0:
            self.perc_down(i)
            i -= 1

</code></pre>

<h2 id="toc_11">分析树</h2>

<p><strong>分析树</strong>(Parse Tree)是一个反映某种形式语言字符串的语法关系的有根有序树, 常常用于真实世界的结构表示，例如句子或数学表达式。</p>

<p>下图是\( ((7+3)*(5−2))\) 的分析树, 树的层级结构帮我们理解了整个表达式的运算顺序。在计算最顶上的乘法运算前，我们先要计算子树中的加法和减法运算。左子树的加法运算结果为\(10\)，右子树的减法运算结果为\(3\)。利用树的层级结构，一旦我们计算出了子节点中表达式的结果，我们能够将整个子树用一个节点来替换。</p>

<p><img src="media/14973171257726/14974242592531.jpg" alt=""/></p>

<p>建立分析树的第一步是将表达式字符串分解成符号保存在列表里。有四种符号需要考虑：<strong>左括号</strong>，<strong>右括号</strong>，<strong>操作符</strong>和<strong>操作数</strong>。当读到一个左括号时，将开始一个新的表达式，因此需要创建一个子树来对应这个新的表达式。相反，每当读到一个右括号，就得结束这个表达式。另外，操作数将成为叶节点和他们所属的操作符的子节点。最后，每个操作符都应该有一个左子节点和一个右子节点。通过上面的分析我们定义以下四条规则：</p>

<ul>
<li>如果当前读入的字符是<code>(</code>，添加一个新的节点作为当前节点的左子节点，并下降到左子节点处。</li>
<li>如果当前读入的字符在列表[<code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>]中，将当前节点的根值设置为当前读入的字符。添加一个新的节点作为当前节点的右子节点，并下降到右子节点处。</li>
<li>如果当前读入的字符是一个数字，将当前节点的根值设置为该数字，并返回到它的父节点。</li>
<li>如果当前读入的字符是<code>)</code>，返回当前节点的父节点。</li>
</ul>

<p>利用<code>get_left_child</code>和<code>get_right_child</code>方法可以获得子节点的方法。<strong>利用栈跟踪父节点</strong>：当要下降到当前节点的子节点时，将当前节点压入栈；当要返回当前节点的父节点时，从栈中弹出该父节点。</p>

<p>所以使用栈和二叉树来创建分析树，代码如下：</p>

<pre><code class="language-python">from stack import Stack
from binary_tree2 import BinaryTree
import operator

def build_parse_tree(fp_exp):
    fp_list = fp_exp.split()
    p_stack = Stack()
    e_tree = BinaryTree(&#39;&#39;)
    p_stack.push(e_tree)
    current_tree = e_tree

    for i in fp_list:
        if i == &#39;(&#39;:
            current_tree.insert_left(&#39;&#39;)
            p_stack.push(current_tree)
            current_tree = current_tree.get_left_child()
        elif i not in [&#39;+&#39;,&#39;-&#39;,&#39;*&#39;,&#39;/&#39;,&#39;)&#39;]:
            current_tree.set_root_val(int(i))
            parent = p_stack.pop()
            current_tree = parent
        elif i in [&#39;+&#39;,&#39;-&#39;,&#39;*&#39;,&#39;/&#39;]:
            current_tree.set_root_val(i)
            current_tree.insert_right(&#39;&#39;)
            p_stack.push(current_tree)
            current_tree = current_tree.get_right_child()
        elif i == &#39;)&#39;:
            current_tree = p_stack.pop()
        else:
            raise ValueError

    return e_tree

def postorder_eval(tree):
    opers = {&#39;+&#39;:operator.add, &#39;-&#39;:operator.sub, &#39;*&#39;:operator.mul, &#39;/&#39;: operator.truediv}
    res1 = None
    res2 = None

    if tree:
        res1 = postorder_eval(tree.get_left_child())
        res2 = postorder_eval(tree.get_right_child())
        if res1 and res2:
            return opers[tree.get_root_val()](res1, res2)
        else:
            return tree.get_root_val()

pt = build_parse_tree(&quot;( ( 10 + 5 ) * 3 )&quot;)

print(&#39;result = %d&#39; %postorder_eval(pt))
</code></pre>

<h2 id="toc_12">树的遍历</h2>

<p>对树中所有节点的访问称为<strong>遍历</strong>(traversal)。按照节点的访问方式不同，树的遍历模式可分为 3 种。这三种方式常被用于访问树的节点，它们之间的不同在于访问每个节点的次序不同。这三种遍历分别叫做<strong>先序遍历</strong>(preorder)，<strong>中序遍历</strong>(inorder)和<strong>后序遍历</strong>(postorder)。具体定义为：</p>

<ul>
<li><p><strong>先序遍历</strong> 先访问根节点，然后递归使用先序遍历访问左子树，再递归使用先序遍历访问右子树。</p></li>
<li><p><strong>中序遍历</strong> 递归使用中序遍历访问左子树，然后访问根节点，最后再递归使用中序遍历访问右子树。</p></li>
<li><p><strong>后序遍历</strong> 先递归使用后序遍历访问左子树和右子树，最后访问根节点。</p></li>
</ul>

<p>三种遍历模式的代码已经包括在<code>BinaryTree</code>类中（参见<code>节点和引用</code>一节）。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[魔法方法(一)：自定义序列]]></title>
    <link href="http://larryim.cc/14973620419454.html"/>
    <updated>2017-06-13T21:54:01+08:00</updated>
    <id>http://larryim.cc/14973620419454.html</id>
    <content type="html"><![CDATA[
<p>Python中的魔法方法可以理解为对类中的内置方法的重载。</p>

<h2 id="toc_0">自定义序列</h2>

<p>有许多办法可以让Python类表现得像是内建序列类型(字典，元组，列表，字符串等)。</p>

<h3 id="toc_1">预备知识</h3>

<p>协议类似某些语言中的接口，里面包含的是一些必须实现的方法。在Python中，协议完全是非正式的，也不需要显式的声明，事实上，它们更像是一种参考标准。</p>

<p>在Python中实现自定义容器类型需要用到一些协议。首先，不可变容器类型有如下协议：想实现一个不可变容器，你需要定义 <code>__len__</code> 和 <code>__getitem__</code> (后面会具体说明）。可变容器的协议除了上面提到的两个方法之外，还需要定义 <code>__setitem__</code> 和 <code>__delitem__</code> 。最后，如果你想让你的对象可以迭代，你需要定义 <code>__iter__</code> ，这个方法返回一个迭代器。迭代器必须遵守迭代器协议，需要定义 <code>__iter__</code> （返回它自己）和 <code>next</code> 方法。</p>

<h3 id="toc_2">容器背后的魔法方法</h3>

<ul>
<li><p><code>__len__(self)</code><br/>
返回容器的长度，可变和不可变类型都需要实现。</p></li>
<li><p><code>__getitem__(self, key)</code><br/>
定义对容器中某一项使用 self[key] 的方式进行读取操作时的行为。这也是可变和不可变容器类型都需要实现的一个方法。它应该在键的类型错误式产生 <code>TypeError</code> 异常，同时在没有与键值相匹配的内容时产生 <code>KeyError</code> 异常。</p></li>
<li><p><code>__setitem__(self, key)</code><br/>
定义对容器中某一项使用 self[key] 的方式进行赋值操作时的行为。它是可变容器类型必须实现的一个方法，同样应该在合适的时候产生 <code>KeyError</code> 和 <code>TypeError</code> 异常。</p></li>
<li><p><code>__iter__(self, key)</code><br/>
它应该返回当前容器的一个迭代器。迭代器以一连串内容的形式返回，最常见的是使用<code>iter()</code>函数调用，以及在类似 for x in container: 的循环中被调用。迭代器是他们自己的对象，需要定义 <code>__iter__</code>方法并在其中返回自己。</p></li>
<li><p><code>__reversed__(self)</code><br/>
定义了对容器使用<code>reversed()</code>内建函数时的行为。它应该返回一个反转之后的序列。当你的序列类是有序时，类似列表和元组，再实现这个方法，</p></li>
<li><p><code>__contains__(self, item)</code><br/>
<code>__contains__</code>定义了使用<code>in</code>和<code>not in</code>进行成员测试时类的行为。你可能好奇为什么这个方法不是序列协议的一部分，原因是，如果<code>__contains__</code>没有定义，Python就会迭代整个序列，如果找到了需要的一项就返回<code>True</code>。</p></li>
<li><p><code>__missing__(self ,key)</code><br/>
<code>__missing__</code>在字典的子类中使用，它定义了当试图访问一个字典中不存在的键时的行为（目前为止是指字典的实例，例如我有一个字典 d ， “george” 不是字典中的一个键，当试图访问 d[“george’] 时就会调用 d.__missing__(“george”))。</p></li>
</ul>

]]></content>
  </entry>
  
</feed>
