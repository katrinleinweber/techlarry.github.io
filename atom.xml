<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[techlarry]]></title>
  <link href="http://larryim.cc/atom.xml" rel="self"/>
  <link href="http://larryim.cc/"/>
  <updated>2018-01-04T18:49:59+08:00</updated>
  <id>http://larryim.cc/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Python源代码对应的汇编代码]]></title>
    <link href="http://larryim.cc/python_assembly_code.html"/>
    <updated>2018-01-03T01:45:38+08:00</updated>
    <id>http://larryim.cc/python_assembly_code.html</id>
    <content type="html"><![CDATA[
<p>学完了汇编语言之后，非常好奇Python程序产生的汇编代码。其实Python作为一种解释语言，其源代码是直接被<code>CPython</code>编译器编译成字节码(<code>btyecode</code>)的；然后在虚拟机中依次解释执行字节码所对应的机器码(<code>machine code</code>)。当需要重用时，字节码以<code>.pyc</code>和<code>.pyo</code>文件存在。当再次运行代码时，虚拟机直接运行<code>.pyc</code>和<code>.pyo</code>文件，省去了重新编译的过程。</p>

<p>Python提供了<code>dis</code>模块，在代码运行时加入<code>-m dis</code>就可以得到源代码对应的汇编代码。其实<code>dis</code>在这里反汇编了字节码。</p>

<p>也可以在源代码中直接调用<code>dis</code>模块：</p>

<pre><code class="language-python">import dis
def f(x):
    return 1 &lt; x ** 2 &lt; 100

dis.dis(f)
</code></pre>

<p>得到的字节码指令(<code>byte code instruction</code>)如下所示：</p>

<pre><code>   4           0 LOAD_CONST               1 (1)
              3 LOAD_FAST                0 (x)
              6 LOAD_CONST               2 (2)
              9 BINARY_POWER
             10 DUP_TOP
             11 ROT_THREE
             12 COMPARE_OP               0 (&lt;)
             15 JUMP_IF_FALSE_OR_POP    25
             18 LOAD_CONST               3 (100)
             21 COMPARE_OP               0 (&lt;)
             24 RETURN_VALUE
        &gt;&gt;   25 ROT_TWO
             26 POP_TOP
             27 RETURN_VALUE
</code></pre>

<p>字节码指令的含义可以通过<a href="https://docs.python.org/2/library/dis.html#bytecodes">官方文件</a>查找。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[目标文件]]></title>
    <link href="http://larryim.cc/15148364443259.html"/>
    <updated>2018-01-02T03:54:04+08:00</updated>
    <id>http://larryim.cc/15148364443259.html</id>
    <content type="html"><![CDATA[
<p><code>UNIX</code>系统提供了一系列命令帮助理解和处理目标文件。这些工具包括：</p>

<p><code>ar</code> ：创建静态库，插入、删除、列出和提取成员；<br/>
STRINGS ：列出目标文件中所有可以打印的字符串；<br/>
STRIP ：从目标文件中删除符号表信息；<br/>
NM ：列出目标文件符号表中定义的符号；<br/>
SIZE ：列出目标文件中节的名字和大小；<br/>
READELF ：显示一个目标文件的完整结构，包括ELF 头中编码的所有信息。<br/>
OBJDUMP ：显示目标文件的所有信息，最有用的功能是反汇编.text节中的二进制指令。<br/>
LDD ：列出可执行文件在运行时需要的共享库。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[gdb]]></title>
    <link href="http://larryim.cc/gdb_tool_gnu.html"/>
    <updated>2018-01-01T04:54:40+08:00</updated>
    <id>http://larryim.cc/gdb_tool_gnu.html</id>
    <content type="html"><![CDATA[
<p><code>gdb</code>（GNU Debugger）作为一个调试工具，其功能强大。它可以调试断点、查看反汇编代码、指令级单步执行、查看寄存器、检查内存/栈，是程序员的得力助手。</p>

<h3 id="toc_0">调试信息</h3>

<p>要调试C/C++的程序，首先在编译时，我们必须要把调试信息(debugging symbols)加到可执行文件中。使用编译器（cc/gcc/g++）的 <code>-g</code> 参数(Generate source-level debug information)可以做到这一点。</p>

<pre><code>g++ -g HelloWorld.cpp -o HelloWorld
</code></pre>

<h3 id="toc_1">常用命令</h3>

<ul>
<li><code>break &lt;location&gt;</code>

<ul>
<li>Stop execution at function name or address </li>
<li>Reset breakpoints when restarting gdb </li>
</ul></li>
<li><code>run &lt;args&gt;</code> 

<ul>
<li>Run program with args <args> </li>
<li>Convenient for specifying text file with answers</li>
</ul></li>
<li><code>disas &lt;fun&gt;</code>, but not dis </li>
<li><p><code>stepi</code> / <code>nexti</code> </p>

<ul>
<li>Steps / does not step through function calls</li>
</ul></li>
<li><p><code>info registers</code> </p>

<ul>
<li>Print hex values in every register </li>
</ul></li>
<li><p><code>print (/x or /d) $eax</code> - Yes, use $ </p>

<ul>
<li>Print hex or decimal contents of %eax </li>
</ul></li>
<li><p><code>x $register</code>, <code>x 0xaddress</code> </p>

<ul>
<li>Prints what’s in the register / at the given address</li>
<li>By default, prints one word (4 bytes) </li>
<li>Specify format: /s, /[num][size][format] *

<ul>
<li> x/8a 0x15213 *</li>
<li> x/4wd 0xdeadbeef</li>
</ul></li>
</ul></li>
<li><p><code>list</code>: view source code</p></li>
</ul>

<h3 id="toc_2">远程调试</h3>

<p>有时候需要调试的程序并不在本机上，<code>gdb</code>是支持远程调试的，具体命令如下：</p>

<pre><code>(gdb) target remote IP:PORT
</code></pre>

<p>这时<code>gdb</code>可以远程连接到被调试机器上，对程序进行调试。前提是在远端的机器上，必须要启动好<code>gdb</code>服务端程序。</p>

<h2 id="toc_3">TUI</h2>

<p>gdb tui（TextUser Interface）为dgb调试的文本用户界面，可以方便地显示源代码、汇编和寄存器文本窗口，tui使用效果如下图所示。</p>

<p><img src="media/15147536807060/gdb-tui.png" alt="gdb-tui"/></p>

<p>gdb tui可以直接运行<code>gdbtui</code>或者在gdb中用<code>ctrl-c, ctrl-a</code>打开。</p>

<p>上图中是打开了汇编窗口的，可通过命令<code>layout split</code>显示源代码和汇编窗口。其他常见的窗口显示命令为：</p>

<ul>
<li><code>layout src/asm/regs</code>：显示源代码/汇编/寄存器窗口</li>
<li><code>layout split</code>：显示源代码和汇编窗口</li>
<li><code>focus cmd/src/asm/regs</code>: 聚焦命令/源代码/汇编/寄存器窗口</li>
</ul>

<h2 id="toc_4">命令行参数</h2>

<p>很多程序在运行时都需要参数。例如下面C程序：</p>

<pre><code class="language-C">#include &lt;stdio.h&gt;
int main(int argc,char *argv[])
{
    int i = argc;
    printf(&quot;argc=%d\n&quot;,i);
        for(i = 0;i &lt; argc;i++)
        printf(&quot;argv[%d]=%s\n&quot;,i,argv[i]);
        return 1;
}
</code></pre>

<pre><code> ./demo_get_opt a b c
argc = 4
argv[0] = ./demo_get_opt
argv[1] = a
argv[2] = b
argv[3] = c
</code></pre>

<p>运行gbb时一共有三种方法可以指定参数。</p>

<p>第一种是在用<code>set args</code>指定参数</p>

<ul>
<li><code>set args</code> 可指定运行时参数。（如：<code>set args a b c</code>或者<code>set args -f 20 -t 40</code>）</li>
<li><code>show args</code> 命令可以查看设置好的运行参数。</li>
</ul>

<pre><code>(gdb) set args a b c
(gdb) r
Starting program: /home/vagrant/demo_get_opt a b c
argc = 4
argv[0] = /home/vagrant/demo_get_opt
argv[1] = a
argv[2] = b
argv[3] = c
</code></pre>

<p>第二种是在运行时设定参数</p>

<ul>
<li><code>r/run args</code> (如 <code>r a b c</code>)</li>
</ul>

<pre><code>(gdb) r a b c
argc = 4
argv[0] = /home/vagrant/demo_get_opt
argv[1] = a
argv[2] = b
argv[3] = c
</code></pre>

<p>第三种是在gdb启动时加上<code>--args</code>参数</p>

<pre><code>gdb --args  ./demo_get_opt a b c
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[x86-64汇编]]></title>
    <link href="http://larryim.cc/15146536465849.html"/>
    <updated>2017-12-31T01:07:26+08:00</updated>
    <id>http://larryim.cc/15146536465849.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">汇编代码格式</h2>

<p>现在主要存在<code>ATT</code>和<code>Intel</code>两种汇编代码格式。<code>ATT</code>格式是<code>GCC</code>, <code>OBJDUMP</code>常用工具的默认格式。其他的诸如Microsoft的工具和来自Intel的文档都是<code>Intel</code>格式的。本文使用<code>ATT</code>格式。</p>

<p><code>ATT</code>汇编格式的注释格式有两种</p>

<pre><code># this is a comment
/* this is a comment */
</code></pre>

<h2 id="toc_1">寄存器</h2>

<p><code>x86-64</code>体系结构广泛存在于个人电脑中。它拥有16个整数寄存器，分别存储64位的值。这些寄存器可以存储地址或整数数据，其分布如下：</p>

<p><img src="media/15146536465849/sfd.png" alt="sfd"/></p>

<p>根据惯例，寄存器%rbx, %rbp和%r12~%r15被划分为<strong>被调用者保存寄存器</strong>。所有其他的寄存器，除了栈指针%rsp都分类为<strong>调用者保存寄存器</strong>。在函数被调用时，不能改变这些<strong>被</strong>调用者寄存器；如果要改变的话，只能把<strong>被</strong>调用者寄存器的值压入栈中，在使用后，从栈中恢复<strong>被</strong>调用者寄存器。</p>

<h3 id="toc_2">rip 寄存器</h3>

<p>%rip 的名称来自于(instruction pointer register,指令指针寄存器)。%rip其实就是程序计数器(Program Counter, PC), 存放着下一条指令的地址。不可以直接修改%rip。</p>

<p>-&gt; <code>instruction pointer = program counter = %rip</code></p>

<p>%rip的其他很重要的一个用法就是rip相对寻址(rip relative addressing)。即<code>%rip + displacement</code>的用法。</p>

<p>例如，</p>

<pre><code class="language-assembly">mov    0x202a62(%rip),%rdi        # 6044d0 &lt;infile&gt;  rdi = infile
</code></pre>

<p>表示传输%rip+0x202a62的地址对应的内存上的内容到%rdi。</p>

<h2 id="toc_3">指令</h2>

<p>指令主要有<code>mov</code>数据传送指令，<code>push</code>、<code>pop</code>压入和压出栈数据，<code>add</code>,<code>sub</code>等算数操作指令，<code>ret</code>, <code>call</code>等转移控制指令。</p>

<h3 id="toc_4">ret, call指令</h3>

<p>在x86-64上，ret指令，相当于从栈中弹出地址A，然后把PC设置为A。<br/>
<code>pop %rip</code><br/>
而call指令，刚好相反，把%rip 压入栈中，然后跳到函数对应的地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[tmux]]></title>
    <link href="http://larryim.cc/tmux_tool_linux.html"/>
    <updated>2017-12-25T21:45:39+08:00</updated>
    <id>http://larryim.cc/tmux_tool_linux.html</id>
    <content type="html"><![CDATA[
<p><code>tmux</code>有两个主要功能：</p>

<ul>
<li>Split窗口。可以在一个terminal下打开多个会话</li>
<li>避免网络不稳定。由于网络不稳定导致的SSH断开，在重新连接后，可以直接回到原来的工作环境。</li>
</ul>

<p><strong>安装</strong>: 在<code>mac</code>上可以通过<code>Homebrew</code>安装。</p>

<p><strong>运行</strong>:在终端下直接敲入<code>tmux</code>，就开启了一个<code>tmux</code>会话。</p>

<h2 id="toc_0">常用按键</h2>

<p>这里需要说明一点的是，<code>tmux</code>的任何指令，都包含一个前缀，也就是说，你按了前缀(一组按键， 默认是<code>Ctrl+b</code>)以后，系统才知道你接下来的指令是发送给<code>tmux</code>的。</p>

<ul>
<li><code>C-b ?</code> 显示快捷键帮助</li>
<li><code>C-b C-o</code> 调换窗口位置，类似与vim 里的C-w</li>
<li><code>C-b space</code> 采用下一个内置布局</li>
<li><code>C-b !</code> 把当前窗口变为新窗口</li>
<li><code>C-b “</code> 横向分隔窗口</li>
<li><code>C-b %</code> 纵向分隔窗口</li>
<li><code>C-b q</code> 显示分隔窗口的编号</li>
<li><code>C-b o</code> 跳到下一个分隔窗口</li>
<li><code>C-b 上下键</code> 上一个及下一个分隔窗口</li>
<li><code>C-b C-方向键</code> 调整分隔窗口大小</li>
<li><code>C-b c</code> 创建新窗口</li>
<li><code>C-b 0~9</code> 选择几号窗口</li>
<li><code>C-b c</code> 创建新窗口</li>
<li><code>C-b n</code> 选择下一个窗口</li>
<li><code>C-b l</code> 切换到最后使用的窗口</li>
<li><code>C-b p</code> 选择前一个窗口</li>
<li><code>C-b w</code> 以菜单方式显示及选择窗口</li>
<li><code>C-b t</code> 显示时钟</li>
<li><code>C-b ;</code> 切换到最后一个使用的面板</li>
<li><code>C-b x</code> 关闭面板</li>
<li><code>C-b &amp;</code> 关闭窗口</li>
<li><code>C-b s</code> 以菜单方式显示和选择会话</li>
<li><code>C-b d</code> 退出<code>tumx</code>，并保存当前会话，这时，<code>tmux</code>仍在后台运行，可以通过<code>tmux attach</code>进入 到指定的会话 </li>
</ul>

<h2 id="toc_1">配置</h2>

<p>与<code>vim</code>等其他工具一样，一旦配置好了<code>tmux</code>，使用起来就将会非常顺手。<code>tmux</code>的默认配置文件是<code>~/.tmux.conf</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OS161]]></title>
    <link href="http://larryim.cc/15142076431845.html"/>
    <updated>2017-12-25T21:14:03+08:00</updated>
    <id>http://larryim.cc/15142076431845.html</id>
    <content type="html"><![CDATA[
<p><a href="http://os161.eecs.harvard.edu">OS161</a>是哈佛大学推出的一款用于教学的操作系统。它运行在一个模拟器上，与BSD类似。目前的版本是2.x版本，支持多处理器和其他现代特性。</p>

<p><a href="http://os161.eecs.harvard.edu/resources/layout.html">OS161 layout</a></p>

<h2 id="toc_0">用gdb调试内核</h2>

<p>首先运行<code>kernel</code></p>

<pre><code>sys161 kernel
</code></pre>

<p>像正常一样运行<code>gdb</code></p>

<pre><code>gdb kernel
</code></pre>

<p>在完成加载后，在<code>gdb</code>中输入以下内容使其连接到<code>System/161</code></p>

<pre><code>target remote unix:.sockets/gdb
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ Ostream]]></title>
    <link href="http://larryim.cc/C_plus_plus_ostream.html"/>
    <updated>2017-12-16T16:31:39+08:00</updated>
    <id>http://larryim.cc/C_plus_plus_ostream.html</id>
    <content type="html"><![CDATA[
<ul>
<li>设定输出域宽度: <code>setw</code></li>
</ul>

<pre><code class="language-C++">// 设定域的输出长度为8，而实际字符串长度为4，所有前面补四个空格。
cout &lt;&lt; &quot;[&quot; &lt;&lt; setw(8) &lt;&lt; &quot;AAAA&quot; &lt;&lt; &quot;]&quot;;        // [    AAAA]
</code></pre>

<p>如果<code>setw</code>的数值小于实际数据长度，<code>setw</code>的值无效，比如上述例子：</p>

<pre><code class="language-C++">//因为3小于实际字符串长度4，最终输出整个字符串。
cout &lt;&lt; &quot;[&quot; &lt;&lt; setw(3) &lt;&lt; &quot;AAAA&quot; &lt;&lt; &quot;]&quot;         // [AAAA]
</code></pre>

<ul>
<li>对齐方式：<code>left</code>/<code>right</code>/<code>internal</code></li>
</ul>

<p>在设定了输出域的宽度<code>setw</code>后，如果设置对齐方式，左对齐还是右对齐(缺省是右对齐(<code>right</code>))</p>

<pre><code class="language-C++"> cout &lt;&lt; &quot;[&quot; &lt;&lt; setw(8) &lt;&lt; left &lt;&lt; &quot;AAAA&quot; &lt;&lt; &quot;]&quot;;       // [AAAA    ]
 cout &lt;&lt; &quot;[&quot; &lt;&lt; setw(8) &lt;&lt; right &lt;&lt; &quot;AAAA&quot; &lt;&lt; &quot;]&quot;;      // [    AAAA]
 cout &lt;&lt; &quot;[&quot; &lt;&lt; setw(8) &lt;&lt; &quot;AAAA&quot; &lt;&lt; &quot;]&quot;;                    // [    AAAA]
</code></pre>

<ul>
<li>填充字符: <code>setfill</code></li>
</ul>

<p>域宽度不够时，还可以指定，用来代替缺省的空格</p>

<pre><code class="language-C++">//使用字符&#39;0&#39;作为填充
 cout &lt;&lt; &quot;[&quot; &lt;&lt; setw(8) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; &quot;AAAA&quot; &lt;&lt; &quot;]&quot;; // [0000AAAA]
 cout &lt;&lt; &quot;[&quot; &lt;&lt; setw(8) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; left &lt;&lt; &quot;AAAA&quot; &lt;&lt; &quot;]&quot;;    // [AAAA0000]
</code></pre>

<ul>
<li>输出正负号: <code>showpos</code></li>
</ul>

<pre><code class="language-C++"> cout &lt;&lt; &quot;[&quot; &lt;&lt; showpos &lt;&lt; 123 &lt;&lt; &quot;]&quot;;   // [+123]
 cout &lt;&lt; &quot;[&quot; &lt;&lt; showpos &lt;&lt; -456 &lt;&lt; &quot;]&quot;;  // [-456]
 cout &lt;&lt; &quot;[&quot; &lt;&lt; showpos &lt;&lt; 0 &lt;&lt; &quot;]&quot;;     // [+0]
</code></pre>

<ul>
<li>输出16进制数字值: <code>hex</code></li>
</ul>

<pre><code class="language-C++">cout &lt;&lt; &quot;[&quot; &lt;&lt; hex &lt;&lt; 20  &lt;&lt; &quot;]&quot;;   //  [14]
</code></pre>

<ul>
<li>可以加前缀<code>0x</code>: <code>showbase</code></li>
</ul>

<pre><code class="language-C++">cout &lt;&lt; &quot;[&quot; &lt;&lt; showbase &lt;&lt; hex &lt;&lt; setw(2) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; 5  &lt;&lt; &quot;]&quot;;  // [0x5]
</code></pre>

<ul>
<li>16进制值(A-F)大写: <code>uppercase</code></li>
</ul>

<pre><code class="language-C++">cout &lt;&lt; &quot;[&quot; &lt;&lt; hex &lt;&lt; uppercase &lt;&lt; setw(2) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; 10  &lt;&lt; &quot;]&quot;;  // [0A]
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CMU 15-213 Introduction to Computer Systems]]></title>
    <link href="http://larryim.cc/introduction_to_computer_system_CMU.html"/>
    <updated>2017-12-14T13:22:02+08:00</updated>
    <id>http://larryim.cc/introduction_to_computer_system_CMU.html</id>
    <content type="html"><![CDATA[
<p>CMU 15-213 <code>Introduction to Computer Systems</code>是最受欢迎的计算机课之一。与这门课对应的课本CSAPP被各大名校所采用，也被无数学生拜读。课程内容涉及广泛、由浅入深，是进入计算机科学的最佳课程，也是各种击破BAT笔试题的必备良药(<a href="https://book.douban.com/review/5627139/">这篇帖子描述了笔试题所对应的章节</a>)。</p>

<p>非常幸运的是，CMU在网上分享了几乎所有课程资料，想学习课程的同学几乎可以和CMU学生一样学习该课程。</p>

<p>课程资料：</p>

<ul>
<li><a href="https://scs.hosted.panopto.com/Panopto/Pages/Sessions/List.aspx#folderID=%22b96d90ae-9871-4fae-91e2-b1627b43e25e%22&amp;sortColumn=0&amp;sortAscending=true">课程视频</a></li>
<li><a href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/schedule.html">课程主页</a>，包括了PPT，代码</li>
<li><a href="http://csapp.cs.cmu.edu">课本CSAPP主页</a>，包括了Lab资源。</li>
</ul>

<p>Lab攻略:</p>

<ul>
<li><a href="http://larryim.cc/wiki/2017/12/30/CSAPP-Attack-Lab/">Lab3 Attack Lab</a></li>
<li><a href="http://larryim.cc/wiki/2017/12/30/CSAPP-Cache-Lab/">Lab4 Cache Lab</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nand2Tetris: The elements of computing systems]]></title>
    <link href="http://larryim.cc/nand2tetris.html"/>
    <updated>2017-12-09T14:45:42+08:00</updated>
    <id>http://larryim.cc/nand2tetris.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">1.布尔逻辑 Boolean Logic</a>
</li>
<li>
<a href="#toc_1">2.布尔运算 Boolean Arithmetic</a>
</li>
<li>
<a href="#toc_2">3.时序逻辑 Sequential Logic</a>
</li>
<li>
<a href="#toc_3">4.机器语言 Machine Language</a>
</li>
<li>
<a href="#toc_4">5.计算机体系结构 Computer Architecture</a>
</li>
</ul>


<p><code>Nand2Tetris 计算机系统要素</code>是一门教你从零开始构建现代计算机的课程。该课程已经在Coursera上开设(分为上下两门课程)，有免费的课本和课程需要的代码，也有专门的论坛来交流学习，课程相关资源如下：</p>

<ul>
<li><a href="https://www.coursera.org/learn/build-a-computer">Coursera Course Part1</a></li>
<li><a href="https://www.coursera.org/learn/nand2tetris2">Coursera Course Part2</a></li>
<li><a href="http://nand2tetris.org">Nand2Tetris Project Homepage</a></li>
<li><a href="http://nand2tetris-questions-and-answers-forum.32033.n3.nabble.com">Nand2Tetris Questions and Answer Forum</a></li>
<li><a href="https://book.douban.com/subject/1998645/">Textbook: The elements of computing system</a></li>
</ul>

<p>该课程适合学生掌握了计算机入门课程和数据结构以后学习，课程涉及布尔逻辑及运算、机器语言、计算机体系结构、汇编、虚拟机、编译器、操作系统。课程内容与CMU的深入理解计算机系统不一样，个人感觉涉及面更广、更加注重实战。</p>

<p>下面是课程的简单总结：</p>

<h2 id="toc_0">1.布尔逻辑 Boolean Logic</h2>

<p><strong>多通道/多位Multiplexor</strong>: 一个拥有m个通道、每个通道数据宽度为n位的multiplexor选择器，将m个n位输入变量中选择一个并从其单一的n位输出总线上输出。可以用k个控制位来指定这个选择(\(k=\log_2 m\))。</p>

<p><strong>例</strong>：4通道16位的multiplexor(4-way Multiplexor):</p>

<p><img src="media/15128019428341/4-way%20multiplexor.png" alt="4-way multiplexo"/></p>

<p><strong>多通道/多位Demultiplexor</strong>: m通道、n位的demult<br/>
iplexor从m个可能的n位输出通道中选择一个n位的输入变量。可以用k个控制位来指定这个选择(\(k=\log_2 m\))。</p>

<p><strong>例</strong>：4-way Demultiplexor:</p>

<p><img src="media/15128019428341/4-way%20demultiplexor.png" alt="4-way demultiplexo"/></p>

<pre><code>/**
 * 4-way demultiplexor:
 * {a, b, c, d} = {in, 0, 0, 0} if sel == 00
 *                {0, in, 0, 0} if sel == 01
 *                {0, 0, in, 0} if sel == 10
 *                {0, 0, 0, in} if sel == 11
 */

CHIP DMux4Way {
    IN in, sel[2];
    OUT a, b, c, d;

    PARTS:
    DMux(in=in, sel=sel[1], a=c1, b=c2);
    DMux(in=c1, sel=sel[0], a=a, b=b);
    DMux(in=c2, sel=sel[0], a=c, b=d);

}
</code></pre>

<h2 id="toc_1">2.布尔运算 Boolean Arithmetic</h2>

<p>半加器(Half Adder): 进行二进制数加法的第一步就是要能够对两个二进制位进行相加。我们把结果的LSB(Least Significant Bit)称为sum，MSB(Most Significant Bit)称为carry。</p>

<p><img src="media/15128019428341/Half%20Adder.png" alt="Half Adde"/></p>

<p>HDL语言：</p>

<pre><code>CHIP HalfAdder {
    IN a, b;    // 1-bit inputs
    OUT sum,    // Right bit of a + b 
        carry;  // Left bit of a + b

    PARTS:
    And(a=a, b=b, out=carry);
    Xor(a=a, b=b, out=sum);
}
</code></pre>

<p>全加器：用来对三个位相加。</p>

<p><img src="media/15128019428341/Full%20Adder.png" alt="Full Adde"/></p>

<p>HDL 语言：</p>

<pre><code>CHIP FullAdder {
    IN a, b, c;  // 1-bit inputs
    OUT sum,     // Right bit of a + b + c
        carry;   // Left bit of a + b + c

    PARTS:
    HalfAdder(a=a, b=b, sum=sum1, carry=carry1);
    HalfAdder(a=c, b=sum1, sum=sum, carry=carry2);
    Or(a=carry1, b=carry2, out=carry);
}
</code></pre>

<p>加法器(Adder): 存储器和寄存器电路用n位的形式来表示整数，n可以是16、32、64等等, 这依赖于所在的计算机平台。进行n位加法的芯片称为多位加法器(multi-bit adder),或者简称为加法器。下图为16位加法器</p>

<p><img src="media/15128019428341/16-bits%20Adder.png" alt="16-bits Adde"/></p>

<p>HDL:</p>

<pre><code>CHIP Add16 {
    IN a[16], b[16];
    OUT out[16];

    PARTS:
   HalfAdder(a=a[0], b=b[0], carry=carry1, sum=out[0]);
   FullAdder(a=a[1], b=b[1], c=carry1, carry=carry2, sum=out[1]);
   FullAdder(a=a[2], b=b[2], c=carry2, carry=carry3, sum=out[2]);
   FullAdder(a=a[3], b=b[3], c=carry3, carry=carry4, sum=out[3]);
   FullAdder(a=a[4], b=b[4], c=carry4, carry=carry5, sum=out[4]);
   FullAdder(a=a[5], b=b[5], c=carry5, carry=carry6, sum=out[5]);
   FullAdder(a=a[6], b=b[6], c=carry6, carry=carry7, sum=out[6]);
   FullAdder(a=a[7], b=b[7], c=carry7, carry=carry8, sum=out[7]);
   FullAdder(a=a[8], b=b[8], c=carry8, carry=carry9, sum=out[8]);
   FullAdder(a=a[9], b=b[9], c=carry9, carry=carry10, sum=out[9]);
   FullAdder(a=a[10], b=b[10], c=carry10, carry=carry11, sum=out[10]);
   FullAdder(a=a[11], b=b[11], c=carry11, carry=carry12, sum=out[11]);
   FullAdder(a=a[12], b=b[12], c=carry12, carry=carry13, sum=out[12]);
   FullAdder(a=a[13], b=b[13], c=carry13, carry=carry14, sum=out[13]);
   FullAdder(a=a[14], b=b[14], c=carry14, carry=carry15, sum=out[14]);
   FullAdder(a=a[15], b=b[15], c=carry15, carry=carry, sum=out[15]);

}
</code></pre>

<p>算数逻辑单元(Arithmetic Logic Unit, ALU): 计算一组固定的函数\(out=f_i(x,y)\),这里\(x\)和\(y\)是芯片的两个16位输入，\(out\)是芯片的16位输出, \(f_i\)是位于一个函数表中的函数，该函数表通过6个控制位(control bit)的输入位(zx, nx, zy, ny, f, no)来告诉ALU用哪一个函数来进行何种计算。</p>

<p><img src="media/15128019428341/ALU.png" alt="ALU"/></p>

<p>HDL:</p>

<pre><code>*
 * The ALU (Arithmetic Logic Unit).
 * Computes one of the following functions:
 * x+y, x-y, y-x, 0, 1, -1, x, y, -x, -y, !x, !y,
 * x+1, y+1, x-1, y-1, x&amp;y, x|y on two 16-bit inputs, 
 * according to 6 input bits denoted zx,nx,zy,ny,f,no.
 * In addition, the ALU computes two 1-bit outputs:
 * if the ALU output == 0, zr is set to 1; otherwise zr is set to 0;
 * if the ALU output &lt; 0, ng is set to 1; otherwise ng is set to 0.
 */

// Implementation: the ALU logic manipulates the x and y inputs
// and operates on the resulting values, as follows:
// if (zx == 1) set x = 0        // 16-bit constant
// if (nx == 1) set x = !x       // bitwise not
// if (zy == 1) set y = 0        // 16-bit constant
// if (ny == 1) set y = !y       // bitwise not
// if (f == 1)  set out = x + y  // integer 2&#39;s complement addition
// if (f == 0)  set out = x &amp; y  // bitwise and
// if (no == 1) set out = !out   // bitwise not
// if (out == 0) set zr = 1
// if (out &lt; 0) set ng = 1

CHIP ALU {
    IN  
        x[16], y[16],  // 16-bit inputs        
        zx, // zero the x input?
        nx, // negate the x input?
        zy, // zero the y input?
        ny, // negate the y input?
        f,  // compute out = x + y (if 1) or x &amp; y (if 0)
        no; // negate the out output?

    OUT 
        out[16], // 16-bit output
        zr, // 1 if (out == 0), 0 otherwise
        ng; // 1 if (out &lt; 0),  0 otherwise

    PARTS:
    // if (zx==1) set x = 0
    Mux16(a=x,b=false,sel=zx,out=zxout);

    // if (zy==1) set y = 0
    Mux16(a=y,b=false,sel=zy,out=zyout); 

    // if (nx==1) set x = ~x
    // if (ny==1) set y = ~y  
    Not16(in=zxout,out=notx);
    Not16(in=zyout,out=noty);
    Mux16(a=zxout,b=notx,sel=nx,out=nxout); 
    Mux16(a=zyout,b=noty,sel=ny,out=nyout);

    // if (f==1)  set out = x + y 
    // if (f==0)  set out = x &amp; y
    Add16(a=nxout,b=nyout,out=addout);
    And16(a=nxout,b=nyout,out=andout);
    Mux16(a=andout,b=addout,sel=f,out=fout);
    
    // if (no==1) set out = ~out
    // 1 if (out&lt;0),  0 otherwise
    Not16(in=fout,out=nfout);
    Mux16(a=fout,b=nfout,sel=no,out=out,out[0..7]=zr1,out[8..15]=zr2,out[15]=ng);
    
    //if (out==0), zr=1
    Or8Way(in=zr1,out=or1);
    Or8Way(in=zr2,out=or2);
    Or(a=or1,b=or2,out=or3);
    Not(in=or3,out=zr);

}
</code></pre>

<h2 id="toc_2">3.时序逻辑 Sequential Logic</h2>

<p>时钟(Clock)：在大多数计算机里，时间的流逝是用主时钟(master clock)来表示的，它提供连续的交变信号序列。其精确的硬件实现通常基于振荡器(oscillator),其在两个信号值0-1之间交替变化。两个响铃的时间间隔称为时钟的周期。</p>

<p>触发器(Flip-Flop): 计算机里最基本的时序单元，有多个变种。数据触发器(Data Flip-Flop, <code>DFF</code>)，其接口包含1比特位输入和1比特位输出。 <u>DFF简单地将前一个时间周期的输入值作为当前周期的输出</u> 。</p>

<p><img src="media/15128019428341/flip-flop.png" alt="flip-flop"/></p>

<p>寄存器(Registers): 具有记忆功能的设备，能“存储”某一时刻的值，实现经典的存储行为<code>out(t)=out(t-1)</code>。从另一个方面来说，DFF仅能够输出它前一时钟周期的输入，也就是<code>out(t)=in(t-1)</code>。寄存器分为地址寄存器(address register), 数据寄存器(data register), 程序计数器(program counter).</p>

<p><img src="media/15128019428341/registers.png" alt="registers"/></p>

<p>1-位寄存器:</p>

<pre><code class="language-hdl">/**
 * 1-bit register:
 * If load[t] == 1 then out[t+1] = in[t]
 *                 else out does not change (out[t+1] = out[t])
 */

CHIP Bit {
    IN in, load;
    OUT out;

    PARTS:
    Mux(a= out1, b=in,  sel=load, out=out2);
    DFF(in=out2, out=out1, out=out);
}
</code></pre>

<p><strong>寄存器</strong>：由1-位寄存器来构建w-位寄存器是非常简单的。所需要做的就是构建一组w比特门，然后将寄存器的load输入赋予每个门。</p>

<pre><code>CHIP Register {
    IN in[16], load;
    OUT out[16];

    PARTS:
    Bit(in=in[0], load=load, out=out[0]);
    Bit(in=in[1], load=load, out=out[1]);
    Bit(in=in[2], load=load, out=out[2]);
    Bit(in=in[3], load=load, out=out[3]);
    Bit(in=in[4], load=load, out=out[4]);
    Bit(in=in[5], load=load, out=out[5]);
    Bit(in=in[6], load=load, out=out[6]);
    Bit(in=in[7], load=load, out=out[7]);
    Bit(in=in[8], load=load, out=out[8]);
    Bit(in=in[9], load=load, out=out[9]);
    Bit(in=in[10], load=load, out=out[10]);
    Bit(in=in[11], load=load, out=out[11]);
    Bit(in=in[12], load=load, out=out[12]);
    Bit(in=in[13], load=load, out=out[13]);
    Bit(in=in[14], load=load, out=out[14]);
    Bit(in=in[15], load=load, out=out[15]);
}
</code></pre>

<p><strong>内存</strong>(Memories):可以通过将寄存器堆叠起来形成 <u>随机存取存储器</u> (random access memory, <code>RAM</code>)。在RAM上能够随机访问被选择的字而不会受限于访问顺序，即随机存取存储器中的任何字都能以相等的速度被直接访问。</p>

<p><img src="media/15128019428341/RAM.png" alt="RA"/></p>

<p>RAM8:</p>

<pre><code class="language-hdl">/**
 * Memory of 8 registers, each 16 bit-wide. Out holds the value
 * stored at the memory location specified by address. If load==1, then 
 * the in value is loaded into the memory location specified by address 
 * (the loaded value will be emitted to out from the next time step onward).
 */

CHIP RAM8 {
    IN in[16], load, address[3];
    OUT out[16];

    PARTS:
    // Put your code here:
    DMux8Way(in=load, sel=address, a=loada, b=loadb, c=loadc, d=loadd, e=loade, f=loadf, g=loadg, h=loadh);
    Register(in=in, load=loada, out=outa);
    Register(in=in, load=loadb, out=outb);
    Register(in=in, load=loadc, out=outc);
    Register(in=in, load=loadd, out=outd);
    Register(in=in, load=loade, out=oute);
    Register(in=in, load=loadf, out=outf);
    Register(in=in, load=loadg, out=outg);
    Register(in=in, load=loadh, out=outh);
    Mux8Way16(a=outa, b=outb, c=outc, d=outd, e=oute, f=outf, g=outg, h=outh, sel=address, out=out);
}
</code></pre>

<p>RAM64:</p>

<pre><code>/**
 * Memory of 64 registers, each 16 bit-wide. Out holds the value
 * stored at the memory location specified by address. If load==1, then 
 * the in value is loaded into the memory location specified by address 
 * (the loaded value will be emitted to out from the next time step onward).
 */

CHIP RAM64 {
    IN in[16], load, address[6];
    OUT out[16];

    PARTS:
    DMux8Way(in=load, sel=address[3..5], a=loada, b=loadb, c=loadc, d=loadd, e=loade, f=loadf, g=loadg, h=loadh);
    RAM8(in=in, load=loada, address=address[0..2], out=outa);
    RAM8(in=in, load=loadb, address=address[0..2], out=outb);
    RAM8(in=in, load=loadc, address=address[0..2], out=outc);
    RAM8(in=in, load=loadd, address=address[0..2], out=outd);
    RAM8(in=in, load=loade, address=address[0..2], out=oute);
    RAM8(in=in, load=loadf, address=address[0..2], out=outf);
    RAM8(in=in, load=loadg, address=address[0..2], out=outg);
    RAM8(in=in, load=loadh, address=address[0..2], out=outh);
    Mux8Way16(a=outa, b=outb, c=outc, d=outd, e=oute, f=outf, g=outg, h=outh, sel=address[3..5], out=out);  
}
</code></pre>

<p>计算机芯片分为两种：组合芯片(<code>combinational chip</code>)和时序芯片(<code>sequential chip</code> or <code>clocked chip</code>时钟芯片)。组合芯片的操作具有即时性(<code>instantaneous</code>)。时序芯片的操作受时钟控制，输入的改变只有在下一个时钟周期才反应到芯片的输出管脚上: <code>out(t)=out(t-1)</code>。</p>

<p><img src="media/15128019428341/combintional%20chip%20and%20sequential%20chip.png" alt="combintional chip and sequential chip"/></p>

<p>计数器(Counter): 计数器是一种时序芯片，它的状态是证书，每经过一个时间周期，该整数就增加1个单位，执行函数<code>out(t)=out(t-1)+c</code>，这里就是1。典型的CPU包括一个程序计数器(program couter, <code>PC</code>)，它的输出是当前程序中下一步将要执行的指令地址。</p>

<p>w-位计数器包含两个主要部分：一个常规的w-位寄存器和组合逻辑。组合逻辑用来：(a)执行计数功能；(b)根据控制位的3种不同的命令值，将计数器置于正确的操作模式。</p>

<p><img src="media/15128019428341/PC.png" alt="PC"/></p>

<pre><code>/**
 * A 16-bit counter with load and reset control bits.
 * if      (reset[t] == 1) out[t+1] = 0
 * else if (load[t] == 1)  out[t+1] = in[t]
 * else if (inc[t] == 1)   out[t+1] = out[t] + 1  (integer addition)
 * else                    out[t+1] = out[t]
 */
 
CHIP PC {
    IN in[16],load,inc,reset;
    OUT out[16];

    PARTS:
    Inc16(in=regout, out=plusone);
    Mux16(a=false, b=plusone, sel=inc, out=incout);
    Mux16(a=incout, b=in, sel=load, out=loadout);
    Mux16(a=loadout, b=false, sel=reset, out=toload);
    Or(a=load, b=reset, out=loadorreset);
    Or(a=loadorreset, b=inc, out=loadflag);
    Register(in=toload, load=loadflag, out=regout);
    Or16(a=regout, b=regout, out=out);
}
</code></pre>

<p>存储器层次结构(<a href="https://en.wikipedia.org/wiki/Memory_hierarchy">memory hierarchy</a>):</p>

<p><img src="media/15128019428341/memory%20hierarchy.png" alt="memory hierarchy"/></p>

<p><img src="media/15128019428341/15128077150126.png" alt=""/></p>

<h2 id="toc_3">4.机器语言 Machine Language</h2>

<p>机器语言用来对底层程序进行编码，从而形成一系列机器指令。应用这些指令，程序员可以命令处理器执行算数和逻辑餐座，在内存中进行存取操作，让数据在寄存器之间传递，验证布尔表达式的值，等等。机器语言的设计目标是直接运行在指定的硬件平台上，能够对这个平台进行全面操控；与机器语言相反，高级语言具有通用性和较强的表达能力。</p>

<p>机器语言是整个计算机题系统意义最深奥的接口 -- 它也是硬件和软件相接的中间线。因此，既可以将机器语言看作编程工作，也可以将其看作硬件平台内部不可分割的一部分。</p>

<h2 id="toc_4">5.计算机体系结构 Computer Architecture</h2>

<p>存储程序的概念：指令没有被嵌入到硬件中，而是被存储在计算机的存储设备(memory)里，当计算机载入不同的程序指令时，同样的硬件平台可以实现不同的功能。</p>

<p>冯·诺伊曼体系结构(概念上的):冯·诺伊曼体系结构的基础是一个中央处理单元(CPU),它与内存进行交互，负责从输入设备接收数据，向输出设备发送数据。</p>

<p><img src="media/15128019428341/%E5%86%AF%E8%AF%BA%E4%BC%8A%E6%9B%BC.png" alt="冯诺伊曼"/></p>

<p>RAM: RAM不光存储数据和指令，还可以通过 <u>内存映像</u> (Memory Maps) 在CPU和计算机输入/输出设备之间充当借口。下图中屏幕和键盘都通过内存映像与计算机平台进行接口。</p>

<p><img src="media/15128019428341/memory.png" alt="memory"/></p>

<pre><code>CHIP Memory {
    IN in[16], load, address[15];
    OUT out[16];

    PARTS:

    DMux4Way(in=load, sel=address[13..14], a=ram1, b=ram2, c=screen, d=kbd);
    Or(a=ram1, b=ram2, out=ram);
    RAM16K(in=in, load=ram, address=address[0..13], out=ramout);
    Screen(in=in, load=screen, address=address[0..12], out=scrout);
    Keyboard(out=kbout);
    Mux4Way16(a=ramout, b=ramout, c=scrout, d=kbout, sel=address[13..14], out=out);
}
</code></pre>

<p>CPU包括执行指令的ALU、一组寄存器和一些用于取指令和对指令解码的控制逻辑(上上图)。用来执行下面的任务：</p>

<ul>
<li>指令解码(Instruction decoding):解析出指令所代表意思(指令的功能)。</li>
<li>指令执行(Instruction execution):发信号指示计算机的各个部分应该做什么工作来执行指令（指令的功能）。</li>
<li>读取下一条指令(Next instruction fetching):指出下一步执行哪一条指令（指令的功能以及ALU的输出）。</li>
</ul>

<p><img src="media/15128019428341/CPU_in_out.png" alt="CPU_in_out"/></p>

<pre><code>
CHIP CPU {

    IN  inM[16],         // M value input  (M = contents of RAM[A])
        instruction[16], // Instruction for execution
        reset;           // Signals whether to re-start the current program
                         // (reset == 1) or continue executing the current
                         // program (reset == 0).

    OUT outM[16],        // M value output
        writeM,          // Write into M? 
        addressM[15],    // RAM address (of M)
        pc[15];          // ROM address (of next instruction)

    PARTS:
    // get type of instruction
    Not(in=instruction[15], out=Ainstruction);
    Not(in=Ainstruction, out=Cinstruction);
    
    And(a=Cinstruction, b=instruction[5], out=ALUtoA);    // C-inst and dest to A-reg?
    Mux16(a=instruction, b=ALUout, sel=ALUtoA, out=Aregin);
    
    Or(a=Ainstruction, b=ALUtoA, out=loadA);    // load A if A-inst or C-inst&amp;dest to A-reg
    ARegister(in=Aregin, load=loadA, out=Aout);
    
    Mux16(a=Aout, b=inM, sel=instruction[12], out=AMout);   // select A or M based on a-bit

    And(a=Cinstruction, b=instruction[4], out=loadD);
    DRegister(in=ALUout, load=loadD, out=Dout);    // load the D register from ALU
    
    ALU(x=Dout, y=AMout, zx=instruction[11], nx=instruction[10], 
        zy=instruction[9], ny=instruction[8], f=instruction[7],
        no=instruction[6], out=ALUout, zr=ZRout, ng=NGout); // calculate
        
    // Set outputs for writing memory
    Or16(a=false, b=Aout, out[0..14]=addressM);
    Or16(a=false, b=ALUout, out=outM);
    And(a=Cinstruction, b=instruction[3], out=writeM);
    
    // calc PCload &amp; PCinc - whether to load PC with A reg
    And(a=ZRout, b=instruction[1], out=jeq);    // is zero and jump if zero
    And(a=NGout, b=instruction[2], out=jlt);    // is neg and jump if neg
    Or(a=ZRout, b=NGout, out=zeroOrNeg);
    Not(in=zeroOrNeg, out=positive);            // is positive (not zero and not neg)
    And(a=positive, b=instruction[0], out=jgt); // is pos and jump if pos
    Or(a=jeq, b=jlt, out=jle);
    Or(a=jle, b=jgt, out=jumpToA);              // load PC if cond met and jump if cond
    And(a=Cinstruction, b=jumpToA, out=PCload); // Only jump if C instruction
    Not(in=PCload, out=PCinc);                  // only inc if not load
    PC(in=Aout, inc=PCinc, load=PCload, reset=reset, out[0..14]=pc);
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PCA基础及在Spark中的应用]]></title>
    <link href="http://larryim.cc/PCA.html"/>
    <updated>2017-11-28T22:32:35+08:00</updated>
    <id>http://larryim.cc/PCA.html</id>
    <content type="html"><![CDATA[
<p>主成分分析(Principal Component Analysis, PCA)主要是用来可视化数据和数据压缩。</p>

<p>PCA的目的是找到一组可以代表原始数据的低维数据。设原始数据为\(X\in \mathbf{R}^{n\times d}\)，有\(d\)个特征。压缩后的数据为\(\mathbf{Z=XP} \in \mathbf{R}^{n\times k}\), 有\(k\)个特征(feature)。</p>

<p>那么找到的这\(k\)个特征，有什么好的约束呢？<br/>
（Variance/Covariance constraints）</p>

<ul>
<li>这k个特征无关，也就是说协相关矩阵除对角线以外的元素全部为0</li>
<li>应该根据特征的方差(variance)选择，越大越好。因为variance越大，越能代表feature。也就是说应该选择协相关矩阵对角元素大的feature。</li>
</ul>

<p>所以 \(\mathbf{P}\)应该等于X的协方差矩阵的最大\(k\)个特征向量。</p>

<p>协方差矩阵的分布式求解方法见本博客<a href="http://larryim.cc/covariance_spark.html">Covariance Matrix and its solution in Spark</a></p>

<p>下面是特征分解的基础知识，可以在线性代数课本上找到：</p>

<p>特征分解(Eigendecomposition)是将矩阵分解为由特征值和特征向量表示矩阵之积的方法。</p>

<p>令 \(A\)是一个\(N\times N\)的方阵，且有\(N\)个线性无关的特征向量\(q_i(i=1,...,N)\)。这样，A可以被分解为<br/>
\[\mathbf{A=Q\Lambda Q}^{-1}\]<br/>
其中\(\mathbf{Q}\)是\(N\times N\)的方阵，且其第\(i\)列为\(A\)的特征向量\(q_i\)。\(\mathbf{\Lambda}\)是对角矩阵，其对角线上的元素为对应的特征值，也即\(\Lambda_{ii}=\lambda_i\).</p>

<p>那么，怎么样选择\(k\)的大小呢？一般认为保留99%或95%的variance. 由于协方差矩阵的对角元素就是对应特征向量的特征值，又是variance，所以我们选择k个对角元素，保留所要求的variance:</p>

<p>\[\text{find} \min k \quad \text{s.t.} \frac{\sum^k_{i=1}\lambda_i}{\sum^k_{i=1}\lambda_i} &gt; 99\%\]</p>

<h2 id="toc_0">PCA in Spark</h2>

<p>在python 中使用 <code>numpy.linalg.eigh</code>计算特征值和特征向量.</p>

<p>基本步骤如下：</p>

<ul>
<li>计算协方差矩阵 <code>estimateCovariance()</code></li>
<li>计算主成分和对应方差 <code>pca()</code></li>
<li>计算保留的成分比例<code>varianceExplained()</code></li>
</ul>

<pre><code class="language-Python">def estimateCovariance(data):
    &quot;&quot;&quot;Compute the covariance matrix for a given rdd.

    Args:
        data (RDD of np.ndarray):  An `RDD` consisting of NumPy arrays.

    Returns:
        np.ndarray: A multi-dimensional array where the number of rows and columns both equal the
            length of the arrays in the input `RDD`.
    &quot;&quot;&quot;
    mean = data.mean()
    normalized = data.map(lambda x: x-mean)
    return normalized.map(lambda x: np.outer(x, x)).sum()/data.count()
    
def pca(data, k=2):
    &quot;&quot;&quot;Computes the top `k` principal components, corresponding scores, and all eigenvalues.


    Args:
        data (RDD of np.ndarray): An `RDD` consisting of NumPy arrays.
        k (int): The number of principal components to return.

    Returns:
        tuple of (np.ndarray, RDD of np.ndarray, np.ndarray): A tuple of (eigenvectors, `RDD` of
            scores, eigenvalues).  Eigenvectors is a multi-dimensional array where the number of
            rows equals the length of the arrays in the input `RDD` and the number of columns equals
            `k`.  The `RDD` of scores has the same number of rows as `data` and consists of arrays
            of length `k`.  Eigenvalues is an array of length d (the number of features).
    &quot;&quot;&quot;
    cov = estimateCovariance(data)
    eigVals, eigVecs = eigh(cov)
    inds = np.argsort(eigVals)[::-1]
    topkComponent = eigVecs[:,inds[0:k]]
    scores = data.map(lambda x: np.dot(x, topkComponent))
    # Return the `k` principal components, `k` scores, and all eigenvalues
    return (topkComponent, scores, eigVals[inds])
    
    
def varianceExplained(data, k=1):
    &quot;&quot;&quot;Calculate the fraction of variance explained by the top `k` eigenvectors.

    Args:
        data (RDD of np.ndarray): An RDD that contains NumPy arrays which store the
            features for an observation.
        k: The number of principal components to consider.

    Returns:
        float: A number between 0 and 1 representing the percentage of variance explained
            by the top `k` eigenvectors.
    &quot;&quot;&quot;
    components, scores, eigenvalues = pca(data)
    return sum(eigenvalues[0:k])/sum(eigenvalues)
</code></pre>

<h2 id="toc_1">应用</h2>

<p>斑马鱼(zebrafish)大脑的响应<a href="http://larryim.cc/ML_lab5_pca_student.html">可视化</a>。</p>

<h2 id="toc_2">Reference</h2>

<ol>
<li>Machine Learning Course from Coursera. Andrew Ng</li>
<li>CS190: Scalable Machine Learning</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Covariance Matrix and its solution in Spark]]></title>
    <link href="http://larryim.cc/covariance_spark.html"/>
    <updated>2017-12-05T21:31:54+08:00</updated>
    <id>http://larryim.cc/covariance_spark.html</id>
    <content type="html"><![CDATA[
<p>A <code>covariance matrix</code>(协方差矩阵, 离差矩阵) is a matrix whose element in the \(i,j\) position is the covariance between the \(i^{th}\) and \(j^{th}\) elements of a <code>random vector</code>(随机向量,多元随机变量). Each element of a random vector is a scalar <code>random variable</code>(随机变量).</p>

<p>Because the covariance of the \(i^{th}\) random variable with itself is simply that random variable&#39;s variance, each element on the principal diagonal of the covariance matrix is the variance of one of the random variables:</p>

<p>The covariance between random variables \(X, Y\):</p>

<p>\[\text{cov}(X,Y)=\text{E}[(X-E[X])(Y-E[Y])]\]</p>

<p>Then the covariance matrix \(\sum\) is the matrix whose \((i,j)\) is the covariance</p>

<p>\[\sum(i,j) =\text{cov}(X_i,X_j)=\text{E}[(X_i-E[X_i])(Y_i-E[Y_i])]\]</p>

<p>where \(X=[X_1,...,X_n]\)</p>

<h2 id="toc_0">Distributed Computing: Spark</h2>

<p>Setup: Raw data \(\mathbf{P} \in \mathbb{R}^{n \times d}\)</p>

<ul>
<li>Step 1: Zero Mean Data \(X=\text{E}(P)\)

<ul>
<li>Compute \(d\) feature means, \(m\in \mathbf{R}^d\)</li>
<li>Communication \(m\) to all workers</li>
<li>Subtract \(m\) from each data point</li>
</ul></li>
<li>Step 2: Compute Covariance Matrix \( \mathbf{C}_{\mathbf X} = \frac{1}{n} \mathbf{X}^\top \mathbf{X} \,.\)

<ul>
<li>compute the outer product of each data point, </li>
<li>add together these outer products, and divide by the number of data points</li>
</ul></li>
</ul>

<p><img src="media/15124807146530/compute_covariance_matrix.png" alt="compute_covariance_matrix"/></p>

<p><u>Spark Code in Python</u>:</p>

<pre><code class="language-python">def estimateCovariance(data):
    &quot;&quot;&quot;Compute the covariance matrix for a given rdd.
   
    Args:
        data (RDD of np.ndarray):  An `RDD` consisting of NumPy arrays.

    Returns:
        np.ndarray: A multi-dimensional array where the number of rows and columns both equal the length of the arrays in the input `RDD`.
    &quot;&quot;&quot;
    mean = data.mean()
    normalized = data.map(lambda x: x-mean)
    return normalized.map(lambda x: np.outer(x, x)).sum()/data.count()
</code></pre>

<h2 id="toc_1">Reference</h2>

<ol>
<li><a href="https://en.wikipedia.org/wiki/Covariance_matrix">Covariance matrix from wikipedia</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Data Science Competition]]></title>
    <link href="http://larryim.cc/data_science_competition.html"/>
    <updated>2017-11-23T22:40:12+08:00</updated>
    <id>http://larryim.cc/data_science_competition.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">real-world application v. s.competition</h2>

<p><img src="media/15114480120681/real%20machine%20learning.png" alt="real machine learning"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MongoDB]]></title>
    <link href="http://larryim.cc/15114445635476.html"/>
    <updated>2017-11-23T21:42:43+08:00</updated>
    <id>http://larryim.cc/15114445635476.html</id>
    <content type="html"><![CDATA[
<p><code>NoSQL</code>(<code>Not Only Sql</code>，非关系型数据库)，最初是为了大规模web应用，具有分布式、开源、可水平扩展等特点。它满足了对数据库高并发读写、对海量数据的高效率存储和访问、对数据库的高扩展性和高可用性的需求。</p>

<h2 id="toc_0">数据逻辑结构</h2>

<p><code>MongoDB</code>的逻辑结构主要由文档(<code>document</code>)、集合(<code>collection</code>)、数据库(<code>database</code>)这三部分组成的。</p>

<h2 id="toc_1">replica set</h2>

<p><code>Replica sets</code> distribute data across two or more machines for redundancy and automate failover in the event of server and network outages. <u>if the primary node fails, the cluster will pick a secondary node and automatically promote it to primary. When the former primary comes back online, it’ll do so as a secondary.</u></p>

<p><img src="media/15114445635476/replica%20set.png" alt="replica set"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[`Filter`, `Map`, `Reduce`]]></title>
    <link href="http://larryim.cc/15108229432607.html"/>
    <updated>2017-11-16T17:02:23+08:00</updated>
    <id>http://larryim.cc/15108229432607.html</id>
    <content type="html"><![CDATA[
<pre><code class="language-python">&gt;&gt;&gt; foo = [2, 18, 9, 22, 17, 24, 8, 12, 27]
&gt;&gt;&gt; print filter(lambda x: x % 3 == 0, foo)
[18, 9, 24, 12, 27]
&gt;&gt;&gt; 
&gt;&gt;&gt; print map(lambda x: x * 2 + 10, foo)
[14, 46, 28, 54, 44, 58, 26, 34, 64]
&gt;&gt;&gt; 
&gt;&gt;&gt; print reduce(lambda x, y: x + y, foo)
139
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CS190: Scalable Machine Learning]]></title>
    <link href="http://larryim.cc/scalable%20machine%20learning.html"/>
    <updated>2017-11-16T14:52:20+08:00</updated>
    <id>http://larryim.cc/scalable%20machine%20learning.html</id>
    <content type="html"><![CDATA[
<p>see <a href="http://larryim.cc/notebook.html">Labs here</a></p>

<h3 id="toc_0">Distributing Computing</h3>

<p>Need more hardware to store/process modern data</p>

<p>Scale-up(one big machine)</p>

<ul>
<li>Can be very fast for medium scale problems</li>
<li>Expensive, specialized hardware</li>
<li>Eventually hit a wall</li>
</ul>

<p>Scale-out (many small machine, i.e., distributed)</p>

<ul>
<li>Commodity hardware, scales to massive problems</li>
<li>Need to deal with network communication</li>
<li>Added software complexity</li>
</ul>

<p>Apache Spark is a general, open-source cluster computing engine.</p>

<p>Well-suited for machine learning</p>

<ul>
<li>Fast iterative computations</li>
<li>Efficient communication primitives</li>
<li>Simple and expressive: APIs in Scala, Java, Python, R</li>
<li>Integrated higher-level libraries (<code>MLlib</code>, Spark SQL, Spark Streaming, GraphX)</li>
</ul>

<h3 id="toc_1">Typical Supervised Learning Pipeline</h3>

<ul>
<li>Obtain Raw Data</li>
<li>Feature Extraction</li>
<li>Supervised Learning</li>
<li>Evaluation</li>
<li>Predict</li>
</ul>

<p><img src="media/15108151409015/Typical%20Supervised%20Learning%20Pipeline.png" alt="Typical Supervised Learning Pipeline"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[`MLlib`: Machine Learning in Apache Spark]]></title>
    <link href="http://larryim.cc/15108128842368.html"/>
    <updated>2017-11-16T14:14:44+08:00</updated>
    <id>http://larryim.cc/15108128842368.html</id>
    <content type="html"><![CDATA[
<p>[<a href="https://arxiv.org/pdf/1505.06807.pdf">https://arxiv.org/pdf/1505.06807.pdf</a>]</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction to big data]]></title>
    <link href="http://larryim.cc/introdution_to_big_data.html"/>
    <updated>2017-10-31T19:52:26+08:00</updated>
    <id>http://larryim.cc/introdution_to_big_data.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Characteristics of Big data</h2>

<p>3 V: Volume, Variety, Velocity</p>

<p>Most now agree with the characterization of big data using the 3 V’s coined by Doug Laney of Gartner:</p>

<p>·<code>Volume</code>: This refers to the vast amounts of data that is generated every second/minute/hour/day in our digitized world.</p>

<p>· <code>Velocity</code>: This refers to the speed at which data is being generated and the pace at which data moves from one point to the next.</p>

<p>· <code>Variety</code>: This refers to the ever-increasing different forms that data can come in, e.g., text, images, voice, geospatial.</p>

<p>A fourth V is now also sometimes added:</p>

<p>· <code>Veracity</code>: This refers to the quality of the data, which can vary greatly.</p>

<p>There are many other V&#39;s that gets added to these depending on the context. For our specialization, we will add:</p>

<p>· <code>Valence</code>: This refers to how big data can bond with each other, forming connections between otherwise disparate datasets.</p>

<p>The above V’s are the dimensions that characterize big data, and also embody its challenges: We have huge amounts of data, in different formats and varying quality, that must be processed quickly.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spark]]></title>
    <link href="http://larryim.cc/Spark_introduction.html"/>
    <updated>2017-10-29T10:53:40+08:00</updated>
    <id>http://larryim.cc/Spark_introduction.html</id>
    <content type="html"><![CDATA[
<p><code>Spark</code>是一个用来实现快速而通用的集群计算的平台。<code>Spark</code>扩展了广泛使用的<code>MapReduce</code>计算模型，而且高效地支持更多计算模式，包括交互式查询和流处理。</p>

<h2 id="toc_0">Reference</h2>

<ul>
<li>Holden Karau, Andy Konwinski, Patrick Wendell, et al. 2015. Learning Spark: Lightning-Fast Big Data Analysis. O&#39;Reilly Media</li>
<li></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hardware/Software Interface]]></title>
    <link href="http://larryim.cc/hardware_software_interface.html"/>
    <updated>2017-10-26T18:49:41+08:00</updated>
    <id>http://larryim.cc/hardware_software_interface.html</id>
    <content type="html"><![CDATA[
<p><code>Hardware/Software Interface</code>是由华盛顿大学在Coursera上开设的课程，与华盛顿大学CSE351课程保持一致。虽然目前这门课已经在Coursera下线，但完整视频、作业、实验仍旧在华盛顿大学<a href="https://courses.cs.washington.edu/courses/cse351/17sp/videos.html">CSE351课程主页</a>上可以观看和下载。</p>

<p>完成课程实验需要用到特定的环境，不然配置起来及其繁琐。幸好，可以下载已经配置好的虚拟机进行实验。虚拟机的地址目前仍旧有效，点击<a href="https://spark-public.s3.amazonaws.com/hardware/VM.7z">这里</a>下载(<code>MD5: 9A2A35B58FF716A84F17610FDEC972EC</code>)。</p>

<p>课程所用教科书是<code>CSAPP</code>(Computer System: A programmer&#39;s Perspective)第二版。非常幸运，教科书、作业和实验内容以及答案已经有人专门整理，并放在Github上了，可以直接<a href="https://github.com/ldfaiztt/CSE351">点击</a>下载。</p>

<p>下载完所有资料后，尽情的学习吧！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[计算机内存概览]]></title>
    <link href="http://larryim.cc/Computer_memory.html"/>
    <updated>2017-10-25T16:07:52+08:00</updated>
    <id>http://larryim.cc/Computer_memory.html</id>
    <content type="html"><![CDATA[
<ul>
<li>memory hierarchy</li>
<li>virtual memory</li>
<li>stack frame</li>
<li>heap</li>
</ul>

<p>本文概览了内存有关的概念。</p>

<h2 id="toc_0">存储器层次结构 Memory Hierarchy</h2>

<p>一般而言，从高层往低层走，存储设备变得更慢、更便宜和更大。</p>

<p><img src="media/15128019428341/15128077150126.png" alt="存储器层次结构"/></p>

<h2 id="toc_1">虚拟内存 Virtual Memory</h2>

<p>虚拟内存(<code>Virtual Memory</code>)是一个抽象概念。它为每个进程提供了假象，即每个进程都在独占地使用内存。每个进程看到的内存都是一致的，称为虚拟地址空间<code>Virtual Address Space</code>.</p>

<p>虚拟内存在不同操作系统上有区别，下面以Linux系统为例。</p>

<p><img src="media/15089188725996/linux_virtual_memory.png" alt="linux_virtual_memory"/></p>

<p>虚拟地址空间由如下几部分组成：</p>

<ul>
<li>代码（<code>.text</code>）: 这里存放的是CPU要执行的指令。代码段是可共享的，相同的代码在内存中只会有一个拷贝，同时这个段是只读的，防止程序由于错误而修改自身的指令。</li>
<li>初始化数据段（<code>.data</code>）: 这里存放的是程序中需要明确赋初始值的变量，例如位于所有函数之外的全局变量：<code>int val=&quot;100</code>。需要强调的是，以上两段都是位于程序的可执行文件中，内核在调用<code>exec</code>函数启动该程序时从源程序文件中读入。</li>
<li>未初始化数据段（<code>.bss</code>）: 位于这一段中的数据，内核在执行该程序前，将其初始化为0或者<code>null</code>。例如出现在任何函数之外的全局变量：int sum;</li>
<li>堆（<code>Heap</code>）: 这个段用于在程序中进行动态内存申请，例如经常用到的<code>malloc</code>，<code>new</code>系列函数就是从这个段中申请内存。</li>
<li>共享库(<code>Shared Library</code>): 用来存放像C标准库和数学哭这样的共享库的代码和数据的区域。</li>
<li>栈（<code>Stack</code>）: 函数中的局部变量以及在函数调用过程中产生的临时变量都保存在此段中，具体见下面一节。</li>
<li>内核虚拟内存：包含内核中的代码和数据结构。</li>
</ul>

<p>注意：</p>

<ul>
<li>底部内存地址是最小的，越往上地址越大。</li>
<li>堆(正向增长)和栈(反向增长)的生长方向(箭头➡️所指方向)是相反的。</li>
</ul>

<p>下面是程序示意：</p>

<pre><code class="language-C"> #include&lt;stdio.h&gt;    
 #include &lt;malloc.h&gt;    
     
 void print(char *,int);    
 int main()    
{    
      char *s1 = &quot;abcde&quot;;  //&quot;abcde&quot;作为字符串常量存储在常量区 s1、s2、s5拥有相同的地址  
      char *s2 = &quot;abcde&quot;;    
      char s3[] = &quot;abcd&quot;;    
      long int *s4[100];    
      char *s5 = &quot;abcde&quot;;    
      int a = 5;    
      int b =6;//a,b在栈上，&amp;a&gt;&amp;b地址反向增长    
     
     printf(&quot;variables address in main function: s1=%p  s2=%p s3=%p s4=%p s5=%p a=%p b=%p \n&quot;,     
             s1,s2,s3,s4,s5,&amp;a,&amp;b);   
     printf(&quot;variables address in processcall:n&quot;);    
        print(&quot;ddddddddd&quot;,5);//参数入栈从右至左进行,p先进栈,str后进 &amp;p&gt;&amp;str    
     printf(&quot;main=%p print=%p \n&quot;,main,print);    
     //打印代码段中主函数和子函数的地址，编译时先编译的地址低，后编译的地址高main&lt;print    
 }    
  
 void print(char *str,int p)    
{    
     char *s1 = &quot;abcde&quot;;  //abcde在常量区，s1在栈上    
     char *s2 = &quot;abcde&quot;;  //abcde在常量区，s2在栈上 s2-s1=6可能等于0，编译器优化了相同的常量，只在内存保存一份    
     //而&amp;s1&gt;&amp;s2    
     char s3[] = &quot;abcdeee&quot;;//abcdeee在常量区，s3在栈上，数组保存的内容为abcdeee的一份拷贝    
     long int *s4[100];    
     char *s5 = &quot;abcde&quot;;    
     int a = 5;    
     int b =6;    
     int c;    
     int d;           //a,b,c,d均在栈上，&amp;a&gt;&amp;b&gt;&amp;c&gt;&amp;d地址反向增长    
     char *q=str;   
     int m=p;           
     char *r=(char *)malloc(1);    
     char *w=(char *)malloc(1) ;  // r&lt;w 堆正向增长    
    
     printf(&quot;s1=%p s2=%p s3=%p s4=%p s5=%p a=%p b=%p c=%p d=%p str=%p q=%p p=%p m=%p r=%p w=%p \n&quot;,    
            s1,s2,s3,s4,s5,&amp;a,&amp;b,&amp;c,&amp;d,&amp;str,q,&amp;p,&amp;m,r,w);   
     /* 栈和堆是在程序运行时候动态分配的，局部变量均在栈上分配。 
        栈是反向增长的，地址递减；malloc等分配的内存空间在堆空间。堆是正向增长的，地址递增。   
        r,w变量在栈上(则&amp;r&gt;&amp;w)，r,w所指内容在堆中(即r&lt;w)。*/   
 }    
   
</code></pre>

<h2 id="toc_2">x86-­64/Linux Stack 栈</h2>

<p>在函数调用时，往往使用了栈(<code>Stack</code>)这一数据结构。当x86-64过程需要的存储空间超出寄存器能够存放的大小时(意味着其实很多函数根本不需要帧栈)，就会在栈上分配空间，称为帧栈(stack frame)。</p>

<p>Current Stack Frame (“Top” to Bottom) contains:</p>

<ul>
<li>Argument build(参数构造区):

<ul>
<li>Parameters for function about to call</li>
<li>可以通过寄存器最多传递6个整形参数，超出6个部分就要通过栈来传递</li>
</ul></li>
<li>Local variables(局部变量):

<ul>
<li>寄存器不足够存放所有的本地数据</li>
<li>使用地址运算符&amp;，必须能够产生一个地址</li>
</ul></li>
<li>Saved register context(被保存的寄存器)

<ul>
<li>保存寄存器的值到栈中</li>
</ul></li>
<li>Old frame pointer (optional)</li>
</ul>

<p><img src="media/15139898460910/procedure.png" alt="procedure"/></p>

<h2 id="toc_3">参考资料</h2>

<p>Randal E B, David O H. 2015. Computer Systems: A programmer&#39;s Perspective, 3rd.</p>

]]></content>
  </entry>
  
</feed>
