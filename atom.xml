<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[techlarry]]></title>
  <link href="http://larryim.cc/atom.xml" rel="self"/>
  <link href="http://larryim.cc/"/>
  <updated>2017-08-03T12:34:17+08:00</updated>
  <id>http://larryim.cc/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Character encoding]]></title>
    <link href="http://larryim.cc/15017330279879.html"/>
    <updated>2017-08-03T12:03:47+08:00</updated>
    <id>http://larryim.cc/15017330279879.html</id>
    <content type="html"><![CDATA[
<p>A <code>character encoding</code> (字符编码) is used to represent a repertoire of characters by some kind of encoding system.</p>

<h2 id="toc_0">Terminology</h2>

<ul>
<li><code>character</code>: a minimal unit of text that has semantic value.</li>
<li><code>character set</code>: a collection of characters that might be used by multiple languages.</li>
<li><code>coded character set</code>: a character set in which each character corresponds to a unique number.</li>
<li><code>code unit</code>: a bit sequence used to encode each character of a repertoire within a given encoding form.</li>
<li><code>code point</code>(码位): any legal value in the character set.</li>
<li><code>character repertoire</code>(字符集): an abstract list of more than one million characters found in a wide variety of scripts including <em>Latin</em>, <em>Cyrillic</em>, <em>Chinese</em>, <em>Korean</em>, <em>Japanese</em>, <em>Hebrew</em>, and <em>Aramaic</em>.</li>
</ul>

<h2 id="toc_1">Unicode</h2>

<p><code>unicode</code> is a computing industry standard for the consistent encoding, representation, and handling of text expressed in most of the world&#39;s writing systems. The Unicode standard defines <code>UTF-8</code>, <code>UTF-16</code>, and <code>UTF-32</code>, and several other encodings are in use.</p>

<h3 id="toc_2">UTF-8</h3>

<p><code>UTF-8</code>, the most widely used by websites. The encoding is variable-length and uses 8-bit code units. UTF-8 encodes each of the 1,112,064 valid code points in Unicode using 1 to 4 8 bit bytes.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL]]></title>
    <link href="http://larryim.cc/15016407791054.html"/>
    <updated>2017-08-02T10:26:19+08:00</updated>
    <id>http://larryim.cc/15016407791054.html</id>
    <content type="html"><![CDATA[
<p>MySQL is an open source, multithread, relational database management system.</p>

<h2 id="toc_0">client and server</h2>

<p>The <code>server</code> maintains, controls and protects your data, storing it in files on the computer where the server is running in various formats. It listens for requests from <code>client</code>.</p>

<p>For MySQL, <code>mysqld</code>(the <em>d</em> stands for <em>daemon</em>) is the server. <code>mysql</code> is a standard MySQL client. With its text-based interface, a user can log in and execute SQL queries.</p>

<h2 id="toc_1">basic command</h2>

<ul>
<li>The <code>mysql_safe</code> script is the most common way to start <code>mysqld</code>, because this script can restart the daemon if it crashes.</li>
<li>The <code>mysqlaccess</code> tool creates user accounts and sets their privileges.</li>
<li>The<code>mysqladmin</code> utility can be used to manage the database server itself from the command-line. </li>
<li>The <code>mysqlshow</code> tool may be used to examine a server’s status, as well as information about databases and tables.</li>
<li>The <code>mysqldump</code> utility is the most popular one for exporting data and table structures to a plain-text file, known as a <code>dump</code> file. </li>
<li>The command <code>mysql -u root -p</code> is usually used to start the client <code>mysql</code>, after which the passport should be filled.</li>
<li>The command <code>mysql -u root -p -e &quot;SELECT User,Host FROM mysql.user;&quot;</code> gives a list of username and host combination on the server.</li>
</ul>

<h2 id="toc_2">GUI</h2>

<p><a href="https://sequelpro.com">Sequel Pro</a> is a fast, easy-to-use Mac database management application for working with MySQL databases. see <a href="https://segmentfault.com/a/1190000006255923">detail in Chinese</a></p>

<p><a href="https://www.mysql.com/products/workbench">WorkBench</a> provides data modeling, SQL development, and comprehensive administration tools for server configuration, user administration, backup, and much more.</p>

<p>Although GUIs are easy-to-use, in the long run they&#39;re not useful. The text-based <code>mysql</code> client causes you to think and remember more, and it&#39;s not that difficult to use or confusing. And the command-line method of using <code>mysql</code> allows you to interact with the server without much overhead.</p>

<h2 id="toc_3">Starting to Explore Databases</h2>

<p>For each of SQL statements, we heave to specify the database name. If you will be working mainly in one database, you can set the default database so that you don&#39;t have to specify the database each time:</p>

<pre><code class="language-SQL">USE database_name
</code></pre>

<h3 id="toc_4">Python</h3>

<p>To use Python with MySQL, you can use the MySQL Connector/Python (<a href="https://dev.mysql.com/downloads/connector/python/">Download Here</a>). For those with anaconda, just install with <code>conda</code>:</p>

<pre><code>conda install -c anaconda mysql-connector-python 
</code></pre>

<p>MySQL Connector/Python includes support for:</p>

<ul>
<li>Almost all features provided by MySQL Server.</li>
<li>Converting parameter values back and forth between Python and MySQL data types.</li>
<li>All MySQL extensions to standard SQL syntax.</li>
</ul>

<pre><code class="language-python">import re
import mysql.connector

# establishes the connection to MySQL.
cnx = mysql.connector.connect(user=&#39;root&#39;, password=&#39;8032804254qq&#39;,
                              host=&#39;127.0.0.1&#39;, database=&#39;rookery&#39;, port=&#39;3306&#39;)

# creates a cursor object (cur) to use for executing queries on the database.


cur = cnx.cursor(buffered=True)

# query mysql database for list of user accounts
sql_stmnt =  &quot;SELECT DISTINCT User, Host FROM mysql.db &quot;
sql_stmnt += &quot;WHERE Db IN(&#39;rookery&#39;,&#39;birdwatchers&#39;) &quot;
sql_stmnt += &quot;ORDER BY User, Host&quot;
cur.execute(sql_stmnt)

# loop through list of user accounts
for user_accounts in cur.fetchall() :
    user_name = user_accounts[0]
    host_address = user_accounts[1]
    user_account = &quot;&#39;&quot; + user_name + &quot;&#39;@&#39;&quot; + host_address + &quot;&#39;&quot;

# display user account heading
print (&#39;User Account:&#39;,(user_name, host_address))
print (&quot;------------------------------------------&quot;)

# query mysql for grants for user account
sql_stmnt = &quot;show grants for&quot; + str(user_account)
cur.execute(sql_stmnt)

# loop through grant entries for user account
for grants in cur.fetchall():
     # skip &#39;usage&#39; entry
    if re.search(&#39;USAGE&#39;, grants[0]) :
        continue
    # extract name of database and table
    dbtb = re.search(&#39;ON\s(.*)\.+?(.+?)\sTO&#39;, grants[0])
    db = dbtb.group(1)
    tb = dbtb.group(2)

    # change wildcard for tables to &#39;all&#39;
    if re.search(&#39;\*&#39;, tb) : tb = &quot;all&quot;

    # display database and table name for privileges
    print &quot;database: %s; table: %s&quot; % (db,tb)

    # extract and display privileges for user account # for database and table
    privs = re.search(&#39;GRANT\s(.+?)\sON&#39;, grants[0])
    print(&#39;privileges: &#39;, privs.group(1))

cur.close()
cnx.close()
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Greedy algorithm (2): A Scheduling Application]]></title>
    <link href="http://larryim.cc/15015745849061.html"/>
    <updated>2017-08-01T16:03:04+08:00</updated>
    <id>http://larryim.cc/15015745849061.html</id>
    <content type="html"><![CDATA[
<p><strong>Problem Statement</strong>: You want to schedule jobs (processes) on a processor. Each job has properties:</p>

<ul>
<li>weight \(w_j\) (“priority”) </li>
<li>length \(l_j\)</li>
</ul>

<p>The <code>completion time</code> \(C_j\) of job \(j\) is Sum of job lengths up to and including job \(j\).</p>

<p>The goal is to <strong>Minimize weighted sum of completion times</strong>, i.e.</p>

<p>\[\sum_{j=1}^n w_j*C_j\]</p>

<h2 id="toc_0">Algorithm</h2>

<p>Order jobs by decreasing value of \(\frac{w_j}{l_j}\), i.e. jobs have larger weight and shorter length execute earlier.</p>

<h3 id="toc_1">Greedy Exchange</h3>

<p><code>Greedy Exchange</code> is one of the techniques used in proving the correctness of greedy algorithms. The idea of a greedy exchange proof is to morph a solution produced by an optimal algorithm into the solution produced by your greedy algorithm. This shows that any optimal solution is no better than the greedy solution, which proves that greedy does in fact return an optimal solution.</p>

<h3 id="toc_2">Proof</h3>

<h4 id="toc_3">Step1: label algorithm&#39;s solution and an optimal solution</h4>

<p>Let \(\sigma\) be greedy schedule, and \(\sigma^*\) be optimal schedule. </p>

<h4 id="toc_4">Step2: Compare greedy with optimal</h4>

<p>Greedy schedule \(\sigma\) is just \(1,2,3,...,n\). And if optimal schedule \(\sigma^* \ne \sigma \), then \(\exists\) consecutive jobs \(i,j\), which \(i&gt;j\).</p>

<h4 id="toc_5">Step3: Exchange</h4>

<p>Suppose we exchange order of \(i,j\) in \(\sigma\):</p>

<ul>
<li>the cost of exchange \(w_jl_j\)</li>
<li>the benefit of exchange is \(w_jl_i\)</li>
</ul>

<p>Note: <br/>
\[i &gt;j \rightarrow w_i/l_i \le wj/lj \rightarrow w_il_j \le w_jl_i \]<br/>
Exchanging \(i,j\) in \(\sigma^*\) has net benefit of \(w_jl_i-w_il_j \ge0\).</p>

<p>\(\rightarrow\) After at most \(C_n^2\) such exchanges, \(\sigma^*\) can transform into \(\sigma\)<br/>
\(\rightarrow \sigma \) at least as good as \(\sigma^*\)<br/>
 \(\rightarrow \) Greedy is optimal.</p>

<h2 id="toc_6">Implemenation</h2>

<pre><code class="language-python">import numpy as np
import unittest

class JobSchedule:
    &quot;&quot;&quot;
    greedy algorithm that schedules jobs in decreasing order of ratio (weight/length)
    &quot;&quot;&quot;
    def __init__(self):
        self.job_num = 0 # the number of jobs
        self.job_weight = []
        self.job_length = []
        self.schedule_time = None
        self.order = None # the ordering of jobs

    def buildjobs(self, textfile):
        &quot;&quot;&quot;
        build jobs from a text file

        The file describes a set of jobs with positive and integral weights and lengths.
        It has the format
        [number_of_jobs]
        [job_1_weight] [job_1_length]

        &quot;&quot;&quot;
        count = 0
        with open(textfile) as infile:
            for line in infile.readlines():
                line = line.strip(&#39;\n&#39;)
                if count == 0:
                    self.job_num = int(line)
                else:
                    job_weight, job_length = (int(num) for num in line.split())
                    self.job_weight.append(job_weight)
                    self.job_length.append(job_length)
                count += 1

        if count-1 != self.job_num:
            raise ValueError

    def scheduling(self):
        &quot;&quot;&quot;
        return the sum of weighted completion times of the resulting schedule
        &quot;&quot;&quot;
        # ratios of weight and length for every job
        ratios = [self.job_weight[i]/self.job_length[i] for i in range(self.job_num)]
        self.order = np.lexsort((self.job_length, ratios))
        self.order=self.order[::-1]
        print([ (self.job_weight[i], self.job_length[i],self.job_weight[i]/self.job_length[i]) for i in self.order])
        # calculating the sum of weighted completion times of the resulting schedule
        count = 0
        job_length = 0
        for job_ind in self.order:
            job_length = job_length + self.job_length[job_ind]
            count += self.job_weight[job_ind]*job_length
        self.schedule_time = count
        return self.schedule_time


class TestJobSchedule(unittest.TestCase):

    def testcase1(self):
        jobs_to_schedule = JobSchedule()
        jobs_to_schedule.buildjobs(&#39;testcase1.txt&#39;)
        assert jobs_to_schedule.scheduling() == 16

    def testcase2(self):
        jobs_to_schedule = JobSchedule()
        jobs_to_schedule.buildjobs(&#39;testcase2.txt&#39;)
        assert jobs_to_schedule.scheduling() == 67247


if __name__ == &quot;__main__&quot;:
    unittest.main()
</code></pre>

<h2 id="toc_7">References</h2>

<ol>
<li><a href="http://www.cs.cornell.edu/courses/cs482/2003su/handouts/greedy_exchange.pdf">Greedy exchange</a></li>
<li><a href="https://www.coursera.org/learn/algorithms-greedy/">Algorithms Specialization</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Minimum Spanning Tree]]></title>
    <link href="http://larryim.cc/15015713574907.html"/>
    <updated>2017-08-01T15:09:17+08:00</updated>
    <id>http://larryim.cc/15015713574907.html</id>
    <content type="html"><![CDATA[
<p>Let \(G=(V, E)\) be a connected, undirected graph with a real-valued weight function \(w\) defined on \(E\). If an acyclic subset \(T\in E\) that connects all of the vertices and whose total weight \(w(T)=\sum_{(u,v)\in T}w(u,v)\) is minimized, \(T\) forms a <code>Minimum Spanning Tree</code>.</p>

<h2 id="toc_0">Concepts</h2>

<ul>
<li><code>safe edge</code>: An edge that may be added to \(A\) without violating the invariant that \(A\) is a subset of some <code>minimum spanning tree</code>.</li>
<li><code>cut</code>: A <code>cut</code> \((S, V-S)\) of an undirected graph \(G=(V,E)\) is a partition of \(V\).</li>
<li><code>cross</code>: We say that an edge \((u,v)\in E\) <code>crosses</code> the cut \((S,V-S)\) if one of its endpoints is in \(S\) and the other is in \(V-S\).</li>
<li><code>respect</code>: If no edge in \(A\) (a subset of some <code>minimum spanning tree</code>) <code>crosses</code> the cut, the cut <code>respects</code> a set \(A\) of edges.</li>
<li><code>light edge</code>: An edge is a <code>light edge</code> crossing a cut if its weight is the minimum of any edge crossing the cut. </li>
</ul>

<h2 id="toc_1">Prim&#39;s algorithm</h2>

<p>Total running time = \(O(V \log(V) + E \log(V)) = O(E \log(V))\)</p>

<h3 id="toc_2">Implementation</h3>

<pre><code class="language-python">from priorityqueue import PriorityQueue
from graph import Graph
import unittest
import sys


def prim(agraph, start):
    &quot;&quot;&quot;
    Prim&#39;s algorithm for minimum spanning tree
    Using min-heap data structure

    return the overall cost of a minimum spanning tre
    &quot;&quot;&quot;
    pq = PriorityQueue()
    total_cost = 0
    for v in agraph:
        v.setDistance(sys.maxsize)
        v.setPred(None)
    start.setDistance(0)
    pq.buildHeap([(v.getDistance(), v) for v in agraph])
    while not pq.isEmpty():
        cost, u = pq.delMin()
        total_cost += cost
        for adjacent in u.getConnections():
          newcost = u.getWeight(adjacent)
          if adjacent in pq and newcost &lt; adjacent.getDistance():
              adjacent.setPred(u)
              adjacent.setDistance(newcost)
              pq.decreaseKey(adjacent, newcost)

    return total_cost


class TestPrim(unittest.TestCase):

    def setUp(self):
        pass

    def test_big(self):
        agraph = Graph()
        count = 0
        with open(&#39;edges.txt&#39;) as infile:
            for line in infile:
                if count == 0:
                    pass
                else:
                    from_v, to_u, cost = [int(number) for number in line.split()]
                    agraph.addEdge(from_v, to_u, cost)
                    agraph.addEdge(to_u, from_v, cost)
                count += 1

        self.assertEqual(prim(agraph, agraph.getVertex(1)), -3612829)

    def test_small(self):
        agraph = Graph()
        count = 0
        with open(&#39;testcase1_prim.txt&#39;) as infile:
            for line in infile:
                if count == 0:
                    pass
                else:
                    from_v, to_u, cost = [int(number) for number in line.split()]
                    agraph.addEdge(from_v, to_u, cost)
                    agraph.addEdge(to_u, from_v, cost)
                count += 1

        self.assertEqual(prim(agraph, agraph.getVertex(1)), 14)


if __name__ == &quot;__main__&quot;:
    unittest.main()
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Greedy algorithm (1): Introduction]]></title>
    <link href="http://larryim.cc/greedy_algorithm_1.html"/>
    <updated>2017-07-31T15:34:06+08:00</updated>
    <id>http://larryim.cc/greedy_algorithm_1.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">Definition</a>
</li>
<li>
<a href="#toc_1">Contrast with Divide &amp; Conquer</a>
</li>
</ul>
</li>
<li>
<a href="#toc_2">Examples</a>
<ul>
<li>
<a href="#toc_3">The Optimal Caching Algorithm</a>
</li>
<li>
<a href="#toc_4">A Scheduling Problem</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">Reference</a>


<h3 id="toc_0">Definition</h3>

<p>A <code>greedy algorithm</code> always makes the choice that looks best at the moment. That is, it makes a locally optimal choice in the hope that this choice will lead to a globally optimal solution. (Cormen et al., 2009)</p>

<h3 id="toc_1">Contrast with Divide &amp; Conquer</h3>

<ol>
<li>Easy to propose multiple greedy algorithms for many problems. </li>
<li>Easy running time analysis. (Contrast with Master method etc.)</li>
<li>Hard to establish correctness.
(Contrast with straightforward inductive correctness proofs.)</li>
</ol>

<p><strong>DANGER: Most greedy algorithms are NOT correct. (Even if your intuition says otherwise!)</strong></p>

<h2 id="toc_2">Examples</h2>

<h3 id="toc_3">The Optimal Caching Algorithm</h3>

<p>Theorem: [Bélády&#39;s 1960s] <code>Farthest-in-Future</code> is the optimal algorithm that minimizes the number of cache misses.</p>

<p><code>Bélády&#39;s Algorithm</code>:</p>

<p>When \(d_i\) is requested but not in the cache,<br/>
evict the cache item that will next be used farthest into the future.</p>

<h3 id="toc_4">A Scheduling Problem</h3>

<p>Assume: Each job has a:</p>

<ul>
<li>weight \(w_j\) (“priority”) </li>
<li>length \(l_j\)</li>
</ul>

<p>The completion time \(C_j\) of job \(j\) = Sum of job lengths up to and including \(j\).</p>

<p>Goal: Minimize the weighted sum of completion times: \(\min \sum ^n_j= w_jC_j\)</p>

<h2 id="toc_5">Reference</h2>

<ol>
<li>Cormen, Leiserson, Rivest, and Stein. 2009. Introduction to Algorithms (3rd edition)</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Generator]]></title>
    <link href="http://larryim.cc/generator.html"/>
    <updated>2017-07-23T18:24:09+08:00</updated>
    <id>http://larryim.cc/generator.html</id>
    <content type="html"><![CDATA[
<p>Any function that contains a <code>yield</code> statement is called a <code>generator</code>.</p>

<h3 id="toc_0">yield statement</h3>

<p>Each time a value is yielded (with <code>yield</code>), the function freezes; that is, it stops its execution at exactly that point and waits to be reawakened.</p>

<h3 id="toc_1">generator comprehension</h3>

<p><code>Generator comprehension</code> works in the same way as <code>list comprehension</code>, except that a list isn&#39;t constructed. Instead, a <code>generator</code> is returned.</p>

<pre><code class="language-python">&gt;&gt;&gt; h = (i for i in range(10))
&gt;&gt;&gt; h
&lt;generator object &lt;genexpr&gt; at 0x104d76ba0&gt;
&gt;&gt;&gt; list(h)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>

<p>When using <code>generator comprehension</code>, if there already exists parentheses, you don&#39;t need to add another pair.</p>

<pre><code class="language-python">&gt;&gt;&gt; sorted(100-i for i in range(10))
[91, 92, 93, 94, 95, 96, 97, 98, 99, 100]
</code></pre>

<h3 id="toc_2">Recursive generator</h3>

<p><code>generators</code> are ideal for complex recursive algorithms that gradually build a result. </p>

<p>A <code>recursive generator</code> could be used to flatten a nested list.</p>

<pre><code class="language-python">def flatten(nested):
    &quot;&quot;&quot;
    When flatten is called, you have two possibilites: the base case and the recursive case.

    In the base case, the function is told to flatten a single element.
    In the recursive case, flatten it.

    &gt;&gt;&gt; list(flatten([[[1], 2], 3, 4, [5, [6, 7]], 8]))
    [1, 2, 3, 4, 5, 6, 7, 8]
    &gt;&gt;&gt; list(flatten([&#39;foo&#39;, [&#39;bar&#39;, [&#39;baz&#39;]]]))
    [&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;]
    &quot;&quot;&quot;
    try:
        try:
            nested + &#39; &#39;
        except TypeError:
            pass
        else:
            raise TypeError
        
        for sublist in nested:
            for element in flatten(sublist):
                yield element

    except TypeError:
        yield nested


if __name__ == &quot;__main__&quot;:
    import doctest
    doctest.testmod(verbose=True)
</code></pre>

<p>An <code>inorder traversal</code> (also <code>postoder traversal</code> and <code>preorder traversal</code>) of a <code>binary search tree</code> might use the <code>recursive generator</code>, detailed code here <a href="http://larryim.cc/binary_search_tree.html">Binary Search Tree</a></p>

<h3 id="toc_3">Generator methods</h3>

<p>We may supply generators with values after they have started running, by using a communications channel between the <code>generator</code> and the “outside world,” with the following two end points:</p>

<ul>
<li><p>The outside world has access to a method on the generator called <code>send</code>, which works just like <code>next</code>, except that it takes a single argument (the “message” to send—an arbitrary object).</p></li>
<li><p>Inside the suspended generator, <strong><code>yield</code> may now be used as an <code>expression</code>, rather than a <code>statement</code></strong>. In other words, when the generator is resumed, yield returns a value—the value sent from the outside through <code>send</code>. If <code>next</code> was used, <code>yield</code> returns <code>None</code>.</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Iterators]]></title>
    <link href="http://larryim.cc/15008043857420.html"/>
    <updated>2017-07-23T18:06:25+08:00</updated>
    <id>http://larryim.cc/15008043857420.html</id>
    <content type="html"><![CDATA[
<p>An object that implements the <code>__iter__</code> method is <code>iterable</code>, and the object implementing <code>next</code> is the <code>iterator</code>.</p>

<p>Why Iterator?<br/>
<strong>not overkill, and more general, simpler, elegant</strong></p>

<p>It is recommended that iterators implement an <code>__iter__</code>method of their own in addition (returning self), so they themselves can be used directly in <code>for</code> loops.</p>

<p>Here an example of Fibonacci numbers.</p>

<pre><code class="language-python">
class Fibs:
    &quot;&quot;&quot;
    Fibonacci numbers
    &quot;&quot;&quot;

    def __init__(self):
        self.a = 0
        self.b = 1

    def __next__(self):
        self.a, self.b = self.b, self.a + self.b
        if self.a &gt; 1000:
            raise StopIteration
        return self.a

    def __iter__(self):
        return self

if __name__ == &quot;__main__&quot;:
    fibs = Fibs()
    for f in fibs:
        print(f)
</code></pre>

<h3 id="toc_0">iterable to iterator</h3>

<p>The built-in function <code>iter</code> can be used to get an iterator from an <code>iterable</code> object.</p>

<pre><code class="language-python">&gt;&gt;&gt; iterable = [1,2,3]
&gt;&gt;&gt; iterator = iter(iterable)
&gt;&gt;&gt; next(iterator)
1
</code></pre>

<h3 id="toc_1">iterator to sequence</h3>

<p>Using the <code>list</code> constructor, an iterator can be easily converted to a sequence.</p>

<hr/>

<pre><code class="language-python">&gt;&gt;&gt; h = Fibs
&gt;&gt;&gt; h = Fibs()
&gt;&gt;&gt; list(h)
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987]
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hashing (4): Universal Hashing]]></title>
    <link href="http://larryim.cc/hashing_4.html"/>
    <updated>2017-07-23T11:07:33+08:00</updated>
    <id>http://larryim.cc/hashing_4.html</id>
    <content type="html"><![CDATA[
<p>Let \(H\) be a finite collection of hash functions that map a given universe \(U\) of keys into the range \(\{0,1,...,m-1\}\). Such a collection is said to be <code>universal</code> if for each pair of distinct keys \(k,l \in U\), the number of <code>hash function</code> \(h \in H\) for which \(h(k) = h(l)\) is at most \(\frac{|H|}{m}\), i.e.</p>

<p>\[ \forall k,l \in U, k\ne l: \Pr_{h\in H }[h(x)=h(y)]\le \frac{1}{m}  \]</p>

<h2 id="toc_0">Why Universal Hashing?</h2>

<p>Some malicious adversary might chooses the keys which all hash to the same slot, yielding an average retrieval time of \(\Theta(n)\). Instead of fixed hash functions, randomly chosen hash functions can yield good performance on average.</p>

<h2 id="toc_1">Designing a universal class of hash functions</h2>

<p>In short, you can generate family of hash functions using following simple equation:</p>

<pre><code class="language-python">h(x,a,b) = ((ax+b) mod p) mod m
</code></pre>

<p>\(x\) is key you want to hash<br/>
\(a\) is any number you can choose between \(1\) to \(p-1\) inclusive.<br/>
\(b\) is any number you can choose between \(0\) to \(p-1\) inclusive.<br/>
\(p\) is a prime number that is greater than max possible value of \(x\)<br/>
\(m\) is a max possible value you want for hash code + 1<br/>
By selecting different values of \(a\) and \(b\) you can generate many hash codes that are independent of each other.</p>

<h2 id="toc_2">Implementation</h2>

<pre><code class="language-python">import random


class UniversalHash:
    &quot;&quot;&quot;
    &gt;&gt;&gt; h=UniversalHash()
    &gt;&gt;&gt; h[54]=&quot;cat&quot;
    &gt;&gt;&gt; h[26]=&quot;dog&quot;
    &gt;&gt;&gt; h[93]=&quot;lion&quot;
    &gt;&gt;&gt; h[77]=&quot;bird&quot;
    &gt;&gt;&gt; h[31]=&quot;cow&quot;
    &gt;&gt;&gt; h[44]=&quot;goat&quot;
    &gt;&gt;&gt; 54 in h
    True
    &quot;&quot;&quot;
    def __init__(self):
        self.size = 100
        self.slots = [None] * self.size
        self.data = [None] * self.size
        (self.p, self.a, self.b) = self.generate_hash_constants()


    def generate_hash_constants(self):
        &quot;&quot;&quot;
        generate a, b, p for universal hashing
        &quot;&quot;&quot;
        p = self._get_prime()  # set p a  random prime number
        a = random.randint(1, p - 1)  # A has a random value between 1 and p - 1.
        b = random.randint(1, p - 1)  # B has a random value between 1 and p - 1
        return p, a, b

    def put(self, key, data):
        hash_value = self.hash_function(key)
        if self.slots[hash_value] is None:
            self.slots[hash_value] = key
            self.data[hash_value] = data
        elif self.slots[hash_value] == key:
            self.data[hash_value] = data
        else:
            # rehash
            next_slot = self.rehash(hash_value, len(self.slots))
            while self.slots[next_slot] is not None and self.slots[next_slot] != key:
                next_slot = self.rehash(hash_value, len(self.slots))

            if self.slots[next_slot] is None:
                self.slots[next_slot] = key
                self.data[hash_value] = data
            else:
                self.data[hash_value] = data

    def hash_function(self, key):
        &quot;&quot;&quot;
        hash_function implements the simple remainder method
        &quot;&quot;&quot;
        return round(self.a * key + self.b) % self.p % self.size

    def rehash(self, old_hash, size):
        &quot;&quot;&quot;
        linear probing with a plus 1
        &quot;&quot;&quot;
        return (old_hash+1) % size

    def get(self, key):
        start_slot = self.hash_function(key)
        data = None
        stop = False
        found = False
        position = start_slot
        while self.slots[position] is not None and \
                not found and not stop:
            if self.slots[position] == key:
                found = True
                data = self.data[position]
            else:
                position = self.rehash(position, len(self.slots))
            if position == start_slot:
                stop = True
        return data

    def _is_prime(self,n):
        if n &lt;= 2 or n%2 == 0:
            return False

        return not any((n%i == 0 for i in range(3, n-1)))

    def _get_prime(self, p=0):
        &quot;&quot;&quot;
        get a prime number
        &quot;&quot;&quot;
        if p == 0:
            p = random.randint(1000000,10000000)
        while not self._is_prime(p):
            p += 1

        return p

    def __getitem__(self, key):
        return self.get(key)

    def __setitem__(self, key, data):
        self.put(key, data)

    def __len__(self):
        &quot;&quot;&quot;
        return length
        &quot;&quot;&quot;
        count = 0
        for item in self.slots:
            if item is not None:
                count += 1

        return count

    def __contains__(self, item):
        &quot;&quot;&quot;
        定义了使用in和not in进行成员测试时类的行为
        &quot;&quot;&quot;
        return self.get(item) is not None

    def __iter__(self):
        &quot;&quot;&quot;
        iterator
        &quot;&quot;&quot;
        for item in self.slots:
            if item is not None:
                yield item

if __name__ == &quot;__main__&quot;:
    import doctest
    doctest.testmod(verbose=True)

</code></pre>

<h2 id="toc_3">Resources</h2>

<ol>
<li><a href="https://www.cse.iitb.ac.in/%7Esri/cs213/lec-Hashing.pdf">Hash Functions and Hash Tables</a></li>
<li>Cormen, Leiserson, Rivest, and Stein, Introduction to Algorithms (3rd edition)</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hashing (3): A variant of 2-Sum Algorithm]]></title>
    <link href="http://larryim.cc/hashing_3.html"/>
    <updated>2017-07-23T10:52:25+08:00</updated>
    <id>http://larryim.cc/hashing_3.html</id>
    <content type="html"><![CDATA[
<p>The goal of the arcticle is to implement a variant of the <code>2-SUM algorithm</code>.</p>

<p>The file contains 1 million integers, both positive and negative (repetitions exists!). This is your array of integers, with the \(i\)th row of the file specifying the \(i\)th entry of the array.</p>

<p>The task is to compute the number of target values \(t\) in the interval \([-10000,10000]\)(inclusive) such that there are distinct numbers \(x,y\) in the input file that satisfy \(x+y=t\). </p>

<h2 id="toc_0">Implementation</h2>

<p>The key process lies in the <code>hash function</code>, which might be set to appropriate small value based on the origin value:<br/>
\[\text{hash_function}= \frac{\text{number}}{\text{factor}}\]</p>

<p>The <code>factor</code> is selected based on the number of <code>slots</code> needed in the algorithm. i.e.<br/>
\[\frac{\text{the range of keys}}{\text{factor}}\approx \text{the number of slots} &lt; \text{the number of keys}\]</p>

<p>There, factor is \(\frac{\text{the number of key}}{2}\)</p>

<pre><code class="language-python">class HashTable(object):

    def __init__(self):

        self.size = 5000000
        self.slots = [set() for i in range(self.size)]
        self.data = set()

    def put(self, key, data):

        hash_value = self.hash_function(key)
        self.slots[hash_value].add(data)
        self.data.add(data)

    def hash_function(self, key):

        return key//(self.size//2)

    def get(self, key):
        &quot;&quot;&quot;
        there key == data
        &quot;&quot;&quot;
        slot = self.hash_function(key)
        if key in self.slots[slot]:
            return key
        else:
            return None

    def buildfromfile(self, textfile):

        with open(text_file, &#39;r&#39;) as infile:
            for line in infile.readlines():
                self.put(int(line), int(line))

    def two_sum_count(self):
        &quot;&quot;&quot;
        Compute the number of target values t in the interval[low, high] (inclusive),
        such that there are distinct numbers x, y that satisfy x+y = t
        &quot;&quot;&quot;
        sums = set()

        for key1 in self.data:
            left = self.hash_function(-key1-10000)
            right = self.hash_function(-key1+10000)

            for slot in self.slots[left:right+1]:

                for key2 in slot:

                    if 10000 &gt; key1 + key2 &gt; -10000:
                        sums.add(key1+key2)

        return len(sums)


if __name__ == &quot;__main__&quot;:

    # target files for counting
    text_file = &#39;two_sum.txt&#39;

    hashnumber = HashTable()
    hashnumber.buildfromfile(text_file)
    print(hashnumber.two_sum_count())
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Heap (2): Median Maintenance]]></title>
    <link href="http://larryim.cc/heap_median_maintenance.html"/>
    <updated>2017-07-21T14:58:43+08:00</updated>
    <id>http://larryim.cc/heap_median_maintenance.html</id>
    <content type="html"><![CDATA[
<p><strong>Problem Statement</strong>: The goal of the problem is to implement the <code>Median Maintenance</code> algorithm. The text file contains a list of the integers; you should treat this as a stream of numbers, arriving one by one. Letting \(x_i\) denote the \(i\)th number of the file, the \(k\)th median \(m_k\) is defined as the median of the numbers \(x_1,…,x_k\). (So, if \(k\) is odd, then \(m_k\) is \(((k+1)/2)\)th smallest number among \(x_1,…,x_k\); if \(k\) is even, then \(m_k\) is the \((k/2)\)th smallest number among \(x_1,…,x_k\).)</p>

<h1 id="toc_0">Solution</h1>

<p>We might use a max heap to represent elements that are less than the median, and a min heap to represent elements that are greater than the median.</p>

<p>After balancing the heaps, the number of elements in two heaps differs at most by 1. </p>

<pre><code class="language-python">Step 1: Add next item to one of the heaps

   if next item &lt; maxHeap root:
        add it to maxHeap
   else:
        add it to minHeap

Step 2: Balance the heaps (after this step heaps will be either balanced or
   one of them will contain 1 more item)

   if number of elements in one of the heaps &gt; the other by
   more than 1:
        remove the root element from the one containing more elements 
        and add to the other one

Step 3: Calculate the median:

   if the heaps contain equal amount of elements:
        median = root of maxHeap
   else:
        median = root of the heap with more elements
</code></pre>

<h2 id="toc_1">Implementation</h2>

<pre><code class="language-python">import doctest
import sys

class MinHeap(object):
    &quot;&quot;&quot;
    Min Heap
    &gt;&gt;&gt; bh = MinHeap()
    &gt;&gt;&gt; bh.buildHeap([9,5,14,18,-17,27,33,19,11,21])
    &gt;&gt;&gt; bh.findMin()
    -17
    &gt;&gt;&gt; bh.delMin()
    -17
    &gt;&gt;&gt; bh.list[1:]
    [5, 9, 14, 11, 21, 27, 33, 19, 18]
    &gt;&gt;&gt; bh.insert(-100)
    &gt;&gt;&gt; bh.delMin()
    -100
    &quot;&quot;&quot;

    def __init__(self):
        &quot;&quot;&quot;
        add self.list 0 with initialization in order to divide
        &quot;&quot;&quot;
        self.list = [-sys.maxsize]
        self.size = 0


    def insert(self, k):
        &quot;&quot;&quot;
        Insert element to the MinBinaryHeap
        &quot;&quot;&quot;
        self.list.append(k)
        self.size += 1
        self.perc_up(self.size)


    def findMin(self):
        &quot;&quot;&quot;
        Find the min element and return it
        &quot;&quot;&quot;
        return self.list[1]


    def delMin(self):
        &quot;&quot;&quot;
        Delete the min element
        and return it
        &quot;&quot;&quot;
        retrival = self.list[1]
        self.size -= 1
        self.list[1] = self.list[-1]
        self.list.pop()
        self.perc_down(1)

        return retrival


    def isEmpty(self):
        &quot;&quot;&quot;
        Return if the MinBinaryHeap is empty
        &quot;&quot;&quot;
        return self.size == 0

    def __len__(self):
        &quot;&quot;&quot;
        Magic Method: return the length of MinBinaryHeap
        &quot;&quot;&quot;
        return self.size


    def buildHeap(self, alist):
        &quot;&quot;&quot;
        Build a MinBinaryHeap from alist which is a collection of data
        &quot;&quot;&quot;
        self.list.extend(alist)
        self.size = len(alist)

        i = self.size//2
        while i &gt; 0:
            self.perc_down(i)
            i -= 1

    def perc_up(self, i):
        &quot;&quot;&quot;&quot;
        perc_up i
        &quot;&quot;&quot;
        while i//2&gt;0:
            if self.list[i] &lt; self.list[i // 2]:
                self.list[i], self.list[i // 2] = self.list[i // 2], self.list[i]
            i = i // 2

    def perc_down(self, i):
        &quot;&quot;&quot;
        perc down i
        &quot;&quot;&quot;
        while (i * 2) &lt;= self.size:
            mc = self.minChild(i)
            if self.list[i] &gt; self.list[mc]:
                self.list[i], self.list[mc] = self.list[mc], self.list[i]
            i = mc

    def minChild(self, i):
        &quot;&quot;&quot;
        find the min child
        &quot;&quot;&quot;
        if i * 2 + 1 &gt; self.size:
            return i * 2
        else:
            if self.list[i * 2] &lt; self.list[i * 2 + 1]:
                return i * 2
            else:
                return i * 2 + 1

    def __iter__(self):
        return iter(self.list[1:])


class MaxHeap(object):
    &quot;&quot;&quot;
    Max Heap
    &gt;&gt;&gt; bh = MaxHeap()
    &gt;&gt;&gt; bh.buildHeap([9,5,14,18,-17,27,33,19,11,21])
    &gt;&gt;&gt; bh.delMax()
    33
    &gt;&gt;&gt; bh.insert(100)
    &gt;&gt;&gt; bh.delMax()
    100
    &gt;&gt;&gt; len(bh)
    9
    &quot;&quot;&quot;

    def __init__(self):
        self.heap = MinHeap()

    def insert(self, k):
        self.heap.insert(-k)

    def delMax(self):
        return -self.heap.delMin()

    def buildHeap(self, alist):
        for i in range(len(alist)):
            alist[i] = -alist[i]
        self.heap.buildHeap(alist)

    def findMax(self):
        return -self.heap.findMin()

    def __len__(self):
        return self.heap.size

    def __iter__(self):
        for i in range(1, self.heap.size+1):
            yield -self.heap.list[i]


def median_maintenance(textfile):

    min_heap = MinHeap()  # &gt; medium
    max_heap = MaxHeap()  # &lt; medium

    medians = []
    count = 0

    with open(textfile) as infile:
        for line in infile:
            item = int(line)
            count += 1

            # Step 1: Add next item to one of the hepas
            # special case: initialize
            if count == 1:
                max_heap.insert(item)
            else:
                if item &lt; max_heap.findMax():
                    max_heap.insert(item)
                else:
                    min_heap.insert(item)

            # Step2: Balance the heap
            if abs(len(max_heap) - len(min_heap)) &gt; 1:
                if len(max_heap) &gt; len(min_heap):
                    min_heap.insert(max_heap.delMax())
                else:
                    max_heap.insert(min_heap.delMin())

            # Step3: calculate median
            if len(max_heap) == len(min_heap):
                median = max_heap.findMax()
            else:
                if len(max_heap) &gt; len(min_heap):
                    median = max_heap.findMax()
                else:
                    median = min_heap.findMin()

            medians.append(median)

            # test
            #for element in max_heap:
            #    print(element, end=&#39; &#39;)
            #for element in min_heap:
            #    print(element, end=&#39; &#39;)
            #print(&#39;total elem:&#39;,len(max_heap)+len(min_heap))


    return medians

if __name__ == &#39;__main__&#39;:
    # doctest.testmod(verbose=True)
    #textfile = &#39;SmallTest.txt&#39;
    textfile = &#39;Median.txt&#39;
    medians = median_maintenance(textfile)
    answer = sum(medians)%10000
    print(answer)
</code></pre>

<h2 id="toc_2">Resources</h2>

<ol>
<li><a href="https://stackoverflow.com/questions/14189540/python-topn-max-heap-use-heapq-or-self-implement">max heap implementation</a></li>
<li><a href="https://stackoverflow.com/questions/10657503/find-running-median-from-a-stream-of-integers">median maintenance</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python树(三)：Binary Search Tree]]></title>
    <link href="http://larryim.cc/binary_search_tree.html"/>
    <updated>2017-06-14T16:13:11+08:00</updated>
    <id>http://larryim.cc/binary_search_tree.html</id>
    <content type="html"><![CDATA[
<p>A <code>binary search tree</code>  is a tree that keys that are less than the parent are found in the left subtree, and keys that are greater than the parent are found in the right subtree.</p>

<p>Let \(x\) be a node in a binary search tree. If \(y\) is a node in the left subtree of \(x\), then \(y.key\le x.key\). If \(y\) is a node in the right subtree of \(x\), then \(y.key\le x.key\).</p>

<h2 id="toc_0">Implementation</h2>

<ul>
<li><code>Map()</code> Create a new, empty map.</li>
<li><code>put(key,val)</code> Add a new key-value pair to the map. If the key is already in the map then replace the old value with the new value.</li>
<li><code>get(key)</code> Given a key, return the value stored in the map or <code>None</code> otherwise.</li>
<li><code>del</code> Delete the key-value pair from the map using a statement of the form <code>del map[key]</code>.</li>
<li><code>len()</code> Return the number of key-value pairs stored in the map.</li>
<li><code>in</code> Return <code>True</code> for a statement of the form <code>key in map</code>, if the given key is in the map.</li>
</ul>

<p>To implement the binary search tree,  the method of <code>the nodes and references approached</code> similar to <code>binary tree</code>(<a href="http://larryim.cc/tree_2.html">Link</a>) The <code>BinarySearchTree</code> class has a reference to the <code>TreeNode</code> that is the root of the binary search tree. </p>

<h3 id="toc_1"><code>delete</code> method</h3>

<p>Once we’ve found the node containing the key we want to delete, there are three cases that we must consider:</p>

<ul>
<li>The node to be deleted has no children.</li>
<li>The node to be deleted has only one child.</li>
<li>The node to be deleted has two children.</li>
</ul>

<p>The first case is straightforward. If the current node has no children all we need to do is delete the node and remove the reference to this node in the parent. The code for this case is shown in here.</p>

<p>The second case is only slightly more complicated. If a node has only a single child, then we can simply promote the child to take the place of its parent. The code for this case is shown in the next listing. As you look at this code you will see that there are six cases to consider. Since the cases are symmetric with respect to either having a left or right child we will just discuss the case where the current node has a left child. The decision proceeds as follows:</p>

<ul>
<li>If the current node is a left child then we only need to update the parent reference of the left child to point to the parent of the current node, and then update the left child reference of the parent to point to the current node’s left child.</li>
<li>If the current node is a right child then we only need to update the parent reference of the left child to point to the parent of the current node, and then update the right child reference of the parent to point to the current node’s left child.</li>
<li>If the current node has no parent, it must be the root. In this case we will just replace the key, payload, leftChild, and rightChild data by calling the <code>replaceNodeData</code> method on the root.</li>
</ul>

<p>The third case is the most difficult case to handle. If a node has two children, then it is unlikely that we can simply promote one of them to take the node’s place. We can, however, search the tree for a node that can be used to replace the one scheduled for deletion. What we need is a node that will preserve the binary search tree relationships for both of the existing left and right subtrees. The node that will do this is the node that has the next-largest key in the tree. We call this node the <code>successor</code>, and we will look at a way to find the successor shortly. The successor is guaranteed to have no more than one child, so we know how to remove it using the two cases for deletion that we have already implemented. Once the successor has been removed, we simply put it in the tree in place of the node to be deleted.</p>

<h3 id="toc_2"><code>successor</code> Method</h3>

<p>The code to find the successor is a method of the <code>TreeNode</code> class. This code makes use of the same properties of binary search trees that cause an <code>inorder traversal</code> to print out the nodes in the tree from smallest to largest. There are three cases to consider when looking for the successor:</p>

<ul>
<li>If the node has a right child, then the successor is the smallest key in the right subtree.</li>
<li>If the node has no right child and is the left child of its parent, then the parent is the successor.</li>
<li>If the node is the right child of its parent, and itself has no right child, then the successor to this node is the successor of its parent, excluding this node.</li>
</ul>

<pre><code class="language-python">
class BinarySearchTree(object):

    def __init__(self):
        self.root = None
        self.size = 0

    def put(self, key, val):
        if self.root:
            self._put(key, val, self.root)
        else:
            self.root = TreeNode(key, val)
        self.size = self.size + 1

    def _put(self, key, val, currentNode):
        if key &lt; currentNode.key:
            if currentNode.hasLeftChild():
                self._put(key, val, currentNode.leftChild)
            else:
                currentNode.leftChild = TreeNode(key, val, parent=currentNode)
        else:
            if currentNode.hasRightChild():
                self._put(key, val, currentNode.rightChild)
            else:
                currentNode.rightChild = TreeNode(key, val, parent=currentNode)

    def __setitem__(self, k, v):
        self.put(k, v)

    def get(self, key):
        if self.root:
            res = self._get(key, self.root)
            if res:
                return res.payload
            else:
                return None
        else:
            return None

    def _get(self, key, currentNode):
        if not currentNode:
            return None
        elif currentNode.key == key:
            return currentNode
        elif key &lt; currentNode.key:
            return self._get(key, currentNode.leftChild)
        else:
            return self._get(key, currentNode.rightChild)

    def __getitem__(self, key):
        res = self.get(key)
        if res:
            return res
        else:
            raise KeyError(&#39;Error, key not in tree&#39;)

    def __contains__(self, key):
        if self._get(key, self.root):
            return True
        else:
            return False

    def length(self):
        return self.size

    def __len__(self):
        return self.size

    def __iter__(self):
        return self.root.__iter__()

    def delete(self, key):
        if self.size &gt; 1:
            nodeToRemove = self._get(key, self.root)
            if nodeToRemove:
                self.remove(nodeToRemove)
                self.size = self.size - 1
            else:
                raise KeyError(&#39;Error, key not in tree&#39;)
        elif self.size == 1 and self.root.key == key:
            self.root = None
            self.size = self.size - 1
        else:
            raise KeyError(&#39;Error, key not in tree&#39;)

    def __delitem__(self, key):
        self.delete(key)

    def remove(self, currentNode):
        if currentNode.isLeaf():  # leaf
            if currentNode == currentNode.parent.leftChild:
                currentNode.parent.leftChild = None
            else:
                currentNode.parent.rightChild = None
        elif currentNode.hasBothChildren():  # interior
            succ = currentNode.findSuccessor()
            succ.spliceOut()
            currentNode.key = succ.key
            currentNode.payload = succ.payload
        else:  # this node has one child
            if currentNode.hasLeftChild():
                if currentNode.isLeftChild():
                    currentNode.leftChild.parent = currentNode.parent
                    currentNode.parent.leftChild = currentNode.leftChild
                elif currentNode.isRightChild():
                    currentNode.leftChild.parent = currentNode.parent
                    currentNode.parent.rightChild = currentNode.leftChild
                else:
                    currentNode.replaceNodeData(currentNode.leftChild.key,
                                                currentNode.leftChild.payload,
                                                currentNode.leftChild.leftChild,
                                                currentNode.leftChild.rightChild)
            else:
                if currentNode.isLeftChild():
                    currentNode.rightChild.parent = currentNode.parent
                    currentNode.parent.leftChild = currentNode.rightChild
                elif currentNode.isRightChild():
                    currentNode.rightChild.parent = currentNode.parent
                    currentNode.parent.rightChild = currentNode.rightChild
                else:
                    currentNode.replaceNodeData(currentNode.rightChild.key,
                                                currentNode.rightChild.payload,
                                                currentNode.rightChild.leftChild,
                                                currentNode.rightChild.rightChild)

    def inorder(self):
        self._inorder(self.root)

    def _inorder(self, tree):
        if tree != None:
            self._inorder(tree.leftChild)
            print(tree.key)
            self._inorder(tree.rightChild)

    def postorder(self):
        self._postorder(self.root)

    def _postorder(self, tree):
        if tree:
            self._postorder(tree.rightChild)
            self._postorder(tree.leftChild)
            print(tree.key)

    def preorder(self):
        self._preorder(self, self.root)

    def _preorder(self, tree):
        if tree:
            print(tree.key)
            self._preorder(tree.leftChild)
            self._preorder(tree.rightChild)


class TreeNode:
    def __init__(self, key, val, left=None, right=None, parent=None):
        self.key = key
        self.payload = val
        self.leftChild = left
        self.rightChild = right
        self.parent = parent
        self.balanceFactor = 0

    def hasLeftChild(self):
        return self.leftChild

    def hasRightChild(self):
        return self.rightChild

    def isLeftChild(self):
        return self.parent and self.parent.leftChild == self

    def isRightChild(self):
        return self.parent and self.parent.rightChild == self

    def isRoot(self):
        return not self.parent

    def isLeaf(self):
        return not (self.rightChild or self.leftChild)

    def hasAnyChildren(self):
        return self.rightChild or self.leftChild

    def hasBothChildren(self):
        return self.rightChild and self.leftChild

    def replaceNodeData(self, key, value, lc, rc):
        self.key = key
        self.payload = value
        self.leftChild = lc
        self.rightChild = rc
        if self.hasLeftChild():
            self.leftChild.parent = self
        if self.hasRightChild():
            self.rightChild.parent = self

    def findSuccessor(self):
        succ = None
        if self.hasRightChild():
            succ = self.rightChild.findMin()
        else:
            if self.parent:
                if self.isLeftChild():
                    succ = self.parent
                else:
                    self.parent.rightChild = None
                    succ = self.parent.findSuccessor()
                    self.parent.rightChild = self
        return succ

    def spliceOut(self):
        if self.isLeaf():
            if self.isLeftChild():
                self.parent.leftChild = None
            else:
                self.parent.rightChild = None
        elif self.hasAnyChildren():
            if self.hasLeftChild():
                if self.isLeftChild():
                    self.parent.leftChild = self.leftChild
                else:
                    self.parent.rightChild = self.leftChild
                self.leftChild.parent = self.parent
            else:
                if self.isLeftChild():
                    self.parent.leftChild = self.rightChild
                else:
                    self.parent.rightChild = self.rightChild
                self.rightChild.parent = self.parent

    def findMin(self):
        current = self
        while current.hasLeftChild():
            current = current.leftChild
        return current

    def __iter__(self):
        &quot;&quot;&quot;The standard inorder traversal of a binary tree.&quot;&quot;&quot;
        if self:
            if self.hasLeftChild():
                for elem in self.leftChild:
                    yield elem
            yield self.key
            if self.hasRightChild():
                for elem in self.rightChild:
                    yield elem
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python树(二)：二叉树的实现]]></title>
    <link href="http://larryim.cc/tree_2.html"/>
    <updated>2017-07-19T09:58:11+08:00</updated>
    <id>http://larryim.cc/tree_2.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">嵌套列表表示树</a>
</li>
<li>
<a href="#toc_1">节点和引用</a>
</li>
<li>
<a href="#toc_2">优先队列和二叉堆</a>
<ul>
<li>
<a href="#toc_3">列表与完全二叉树</a>
</li>
<li>
<a href="#toc_4">二叉堆的操作与实现</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">分析树</a>
</li>
<li>
<a href="#toc_6">树的遍历</a>
</li>
</ul>


<p>树可以具有以下方法：</p>

<ul>
<li><code>BinaryTree()</code> creates a new instance of a binary tree.</li>
<li><code>get_left_child()</code> returns the binary tree corresponding to the left child of the current node</li>
<li><code>get_right_child()</code> return the binary tree corresponding to the right child of the current node</li>
<li><code>set_root_val(val)</code> stores the object stored in the current node</li>
<li><code>get_root_val()</code> returns the object stored in the current node</li>
<li><code>insert_left(val)</code> creates a new binary tree and installs it as the left child of the current node</li>
<li><code>insert_right(val)</code> creates a new binary tree and installs it as the right child of the current node</li>
</ul>

<h2 id="toc_0">嵌套列表表示树</h2>

<p>在列表实现树时，我们将存储根节点作为列表的第一个元素的值。列表的第二个元素的本身是一个表示左子树的列表。这个列表的第三个元素表示在右子树的另一个列表。</p>

<pre><code class="language-python"># coding: utf-8


def BinaryTree(r):
    &quot;&quot;&quot;
    creates a new instance of a binary tree.
    &quot;&quot;&quot;
    return [r,[],[]]


def get_left_child(root):
    &quot;&quot;&quot;
    returns the binary tree corresponding to the left child of the current node
    &quot;&quot;&quot;
    return root[1]


def get_right_child(root):
    &quot;&quot;&quot;
    return the binary tree corresponding to the right child of the current node
    &quot;&quot;&quot;
    return  root[2]


def set_root_val(root, val):
    &quot;&quot;&quot;stores the object stored in the current node
    &quot;&quot;&quot;
    root[0] = val



def get_root_val(root):
    &quot;&quot;&quot;
    returns the object stored in the current node
    &quot;&quot;&quot;
    return root[0]

def insert_left(root, new_branch):
    &quot;&quot;&quot;
    creates a new binary tree and installs it as the left child of the current node

    插入一个左子节点，首先获取对应于当前左子节点的列表（可能是空的）。
    然后，添加新的左子节点，将原来的左子节点作为新节点的左子节点。
    这使我们能够将新节点插入到树中的任何位置.
    &quot;&quot;&quot;
    if root[1]:
        root[1] = [new_branch,root[1], []]
    else:
        root[1] = [new_branch, [], []]
    return root



def insert_right(root, new_branch):
    &quot;&quot;&quot;
    creates a new binary tree and installs it as the right child of the current node
    &quot;&quot;&quot;
    if root[2]:
        root[2] = [new_branch, [], root[2]]
    else:
        root[2] = [new_branch, [], []]
    return root


if __name__ == &quot;__main__&quot;:
    r = BinaryTree(3)
    insert_left(r,4)
    insert_left(r,5)
    insert_right(r,6)
    insert_right(r,7)
    l = get_left_child(r)
    print(l)

    set_root_val(l,9)
    print(r)
    insert_left(l,11)
    print(r)
    print(get_right_child(get_right_child(r)))

# result
#[5, [4, [], []], []]
#[3, [9, [4, [], []], []], [7, [], [6, [], []]]]
#[3, [9, [11, [4, [], []], []], []], [7, [], [6, [], []]]]
#[6, [], []]

</code></pre>

<h2 id="toc_1">节点和引用</h2>

<p>节点和引用方法，定义一个类，具有根、以及左、右子树属性。这种表示更紧密地结合了面向对象的方式。树的结构类似于下图所示。</p>

<p><img src="media/14973171257726/14974056999880.jpg" alt="binary tree"/></p>

<p>左右子树是其他二叉树实例的引用。例如，当插入一个新的左子节点到树上时，即创建了二叉树的另一个实例，并修改了根节点的<code>self.left_child</code>使之指向新的树。</p>

<pre><code class="language-python">
import doctest


class BinaryTree(object):
    &quot;&quot;&quot;
    &gt;&gt;&gt; r = BinaryTree(&#39;a&#39;)
    &gt;&gt;&gt; r.get_root_val()
    &#39;a&#39;
    &gt;&gt;&gt; r.get_left_child()

    &gt;&gt;&gt; r.insert_left(&#39;b&#39;)
    &gt;&gt;&gt; r.get_left_child().get_root_val()
    &#39;b&#39;
    &gt;&gt;&gt; r.insert_right(&#39;c&#39;)
    &gt;&gt;&gt; r.get_right_child().get_root_val()
    &#39;c&#39;
    &gt;&gt;&gt; r.get_right_child().set_root_val(&#39;hello&#39;)
    &gt;&gt;&gt; r.get_right_child().get_root_val()
    &#39;hello&#39;
    &quot;&quot;&quot;
    
    def __init__(self, root):
        self.key = root
        self.left_child = None
        self.right_child = None

    def insert_left(self, item):
        &quot;&quot;&quot;
        creates a new binary tree and installs it as the left child of the current node
        &quot;&quot;&quot;
        if self.left_child:
            self.left_child = BinaryTree(item)
        else:
            t = self.left_child
            self.left_child = BinaryTree(item)
            self.left_child.left_child = t

    def insert_right(self, item):
        &quot;&quot;&quot;
        creates a new binary tree and installs it as the right child of the current node
        &quot;&quot;&quot;
        if self.right_child:
            self.right_child = BinaryTree(item)
        else:
            t = self.right_child
            self.right_child = BinaryTree(item)
            self.right_child.right_child = t

    def get_right_child(self):
        &quot;&quot;&quot;
        return the binary tree corresponding to the right child of the current node
        &quot;&quot;&quot;
        return self.right_child

    def get_left_child(self):
        &quot;&quot;&quot;
        return the binary tree corresponding to the left child of the current node
        &quot;&quot;&quot;
        return self.left_child

    def set_root_val(self, root):
        &quot;&quot;&quot;
        stores the object stored in the current node
        &quot;&quot;&quot;
        self.key = root

    def get_root_val(self):
        &quot;&quot;&quot;
        returns the object stored in the current node
        &quot;&quot;&quot;
        return self.key

    def pre_order(self, root):
        &quot;&quot;&quot;
        preorder traversal
        &quot;&quot;&quot;
        print(root.key, end=&#39; &#39;)
        if root.left_child:
            root.pre_order(root.left_child)
        if root.right_child:
            root.pre_order(root.right_child)

    def post_order(self, root):
        &quot;&quot;&quot;
        postorder traversal
        &quot;&quot;&quot;
        if root is not None:
            self.post_order(root.left_child)
            self.post_order(root.right_child)
            print(root.key, end=&#39; &#39;)

    def pre_order(self, root):
        &quot;&quot;&quot;
        Preorder traversal
        &quot;&quot;&quot;
        print(root.key, end=&#39; &#39;)
        if root.left_child:
            self.pre_order(root.left_child)
        if root.right_child:
            self.pre_order(root.right_child)

    def in_order(self, root):
        &quot;&quot;&quot;
        postorder traversal
        &quot;&quot;&quot;
        if root is not None:
            self.post_order(root.left_child)
            print(root.key, end=&#39; &#39;)
            self.post_order(root.right_child)

if __name__ == &quot;__main__&quot;:
    doctest.testmod(verbose=True)

</code></pre>

<h2 id="toc_2">优先队列和二叉堆</h2>

<p><strong>优先队列</strong>(Priority Queues)是一类抽象数据类型。优先队列中的每个元素都有各自的优先级，优先级最高的元素最先得到服务；优先级相同的元素按照其在优先队列中的顺序得到服务。在优先队列的内部，元素的次序是由“优先级”来决定：高优先级的元素排在队首，而低优先级的元素则排在后面。</p>

<p>实现优先队列的经典方法是采用<strong>二叉堆</strong>(Binary Heap)。因为使用二叉堆能将优先队列的入队和出队复杂度都保持在\(O(\log n)\)。 二叉堆有两种：键值总是最小的排在队首称为<strong>最小堆</strong>(min heap)，反之，键值总是最大的排在队首称为<strong>最大堆</strong>(max heap)。</p>

<p>储存元素要满足<strong>堆次序</strong>，即堆中任何一个节点\(x\)，其父节点\(p\)的键值均小于或等于\(x\)的键值。下图所示是具备堆次序性质的完全二叉树。</p>

<h3 id="toc_3">列表与完全二叉树</h3>

<p><strong>不需要使用节点，引用或嵌套列表，用单个列表就能代表完全二叉树</strong>。因为对于完全二叉树，如果节点在列表中的下标为\(p\)，那么其左子节点下标为\(2p\)，右节点为\(2p+1\)。当我们要找任何节点的父节点时，可以直接使用 python 的整除。如果节点在列表中下标为\(n\)，那么父节点下标为\(n//2\)（参考下图）。使用列表, 能够使用简单的数学方法高效地遍历一棵完全二叉树，这也导致了二叉堆的高效实现。</p>

<p><img src="media/14973171257726/14974117374605.jpg" alt=""/></p>

<h3 id="toc_4">二叉堆的操作与实现</h3>

<ul>
<li><code>BinaryHeap()</code>：创建一个新的、空的二叉堆对象</li>
<li><code>insert(k)</code>：把新元素加入到堆中</li>
<li><code>findMin()</code>：返回堆中的最小项，最小项仍保留在堆中</li>
<li><code>delMin()</code>：返回堆中的最小项，同时从堆中删除</li>
<li><code>isEmpty()</code>：返回堆是否为空</li>
<li><code>size()</code>：返回堆中元素的个数</li>
<li><code>buildHeap(list)</code>：从一个包含元素的列表创建新堆</li>
</ul>

<p>有两个关键的操作：<br/>
1. <code>insert</code>方法。首先，为了满足“完全二叉树”的性质，新键值应该添加到列表的末尾。然而新键值简单地添加在列表末尾，显然无法满足堆次序。所以要通过比较父节点和新加入的元素的方法来重新满足堆次序。如果新加入的元素比父节点要小，可以与父节点互换位置；不断交换，直到到达树的顶端。下图所示一系列交换操作来使新加入元素“上浮”到正确的位置。</p>

<p><img src="media/14973171257726/14974156268132.jpg" alt=""/></p>

<p>2.<code>delMin</code>方法 移走根节点的元素后如何保持堆结构和堆次序: 首先，用最后一个节点来代替根节点, 移走最后一个节点保持了堆结构的性质。这么简单的替换，还是会破坏堆次序。第二步，将新节点“下沉”来恢复堆次序。下图所示的是一系列交换操作来使新节点“下沉”到正确的位置。</p>

<p><img src="media/14973171257726/14974156980805.jpg" alt=""/></p>

<pre><code class="language-python">class BinHeap(object):
    &quot;&quot;&quot;
    创建一个新的、空的二叉堆对象
    &quot;&quot;&quot;
    def __init__(self):
        self.list = [0]
        self.size = 0

    def perc_up(self,i):
        &quot;&quot;&quot;
        Percolate the new node into proper position
        &quot;&quot;&quot;
        while i//2&gt;0: 
            if self.list[i] &lt; self.list[i//2]:
                self.list[i], self.list[i//2] = self.list[i//2], self.list[i]
            i = i//2
    
    def insert(self, item):
        &quot;&quot;&quot;把新元素加入到堆中&quot;&quot;&quot;
        self.list.append(item)
        self.size += 1
        self.perc_up(self.size)

    def findMin(self):
        &quot;&quot;&quot;返回堆中的最小项，最小项仍保留在堆中&quot;&quot;&quot;
        return self.list[1]

    def delMin(self):
        &quot;&quot;&quot;返回堆中的最小项，同时从堆中删除&quot;&quot;&quot;
        retval = self.list[1]
        self.list[1] = self.list[-1]
        self.size -=1
        self.list.pop()
        self.perc_down(1)

        return retval


    def perc_down(self, i):
        &quot;&quot;&quot;
        Percolate the root node  down the tree
        &quot;&quot;&quot;
        while (i * 2) &lt;= self.currentSize:
            mc = self.minChild(i)
            if self.heapList[i] &gt; self.heapList[mc]:
                tmp = self.heapList[i]
                self.heapList[i] = self.heapList[mc]
                self.heapList[mc] = tmp
            i = mc
            
    def minChild(self, i):
        &quot;&quot;&quot;
        find the min child
        &quot;&quot;&quot;
        if i * 2 + 1 &gt; self.currentSize:
            return i * 2
        else:
            if self.heapList[i * 2] &lt; self.heapList[i * 2 + 1]:
                return i * 2
            else:
                return i * 2 + 1

    def isEmpty(self):
        &quot;&quot;&quot;返回堆是否为空&quot;&quot;&quot;
        return self.size == 0

    def __len__(self):
        &quot;&quot;&quot;返回堆中元素的个数&quot;&quot;&quot;
        return self.size

    def buildHeap(self,alist):
        &quot;&quot;&quot;从一个包含元素的列表创建新堆&quot;&quot;&quot;
        self.size = len(alist)
        self.list.extend(alist)
        i = self.size//2
        while i &gt;0:
            self.perc_down(i)
            i -= 1

</code></pre>

<h2 id="toc_5">分析树</h2>

<p><strong>分析树</strong>(Parse Tree)是一个反映某种形式语言字符串的语法关系的有根有序树, 常常用于真实世界的结构表示，例如句子或数学表达式。</p>

<p>下图是\( ((7+3)*(5−2))\) 的分析树, 树的层级结构帮我们理解了整个表达式的运算顺序。在计算最顶上的乘法运算前，我们先要计算子树中的加法和减法运算。左子树的加法运算结果为\(10\)，右子树的减法运算结果为\(3\)。利用树的层级结构，一旦我们计算出了子节点中表达式的结果，我们能够将整个子树用一个节点来替换。</p>

<p><img src="media/14973171257726/14974242592531.jpg" alt=""/></p>

<p>建立分析树的第一步是将表达式字符串分解成符号保存在列表里。有四种符号需要考虑：<strong>左括号</strong>，<strong>右括号</strong>，<strong>操作符</strong>和<strong>操作数</strong>。当读到一个左括号时，将开始一个新的表达式，因此需要创建一个子树来对应这个新的表达式。相反，每当读到一个右括号，就得结束这个表达式。另外，操作数将成为叶节点和他们所属的操作符的子节点。最后，每个操作符都应该有一个左子节点和一个右子节点。通过上面的分析我们定义以下四条规则：</p>

<ul>
<li>如果当前读入的字符是<code>(</code>，添加一个新的节点作为当前节点的左子节点，并下降到左子节点处。</li>
<li>如果当前读入的字符在列表[<code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>]中，将当前节点的根值设置为当前读入的字符。添加一个新的节点作为当前节点的右子节点，并下降到右子节点处。</li>
<li>如果当前读入的字符是一个数字，将当前节点的根值设置为该数字，并返回到它的父节点。</li>
<li>如果当前读入的字符是<code>)</code>，返回当前节点的父节点。</li>
</ul>

<p>利用<code>get_left_child</code>和<code>get_right_child</code>方法可以获得子节点的方法。<strong>利用栈跟踪父节点</strong>：当要下降到当前节点的子节点时，将当前节点压入栈；当要返回当前节点的父节点时，从栈中弹出该父节点。</p>

<p>所以使用栈和二叉树来创建分析树，代码如下：</p>

<pre><code class="language-python">from stack import Stack
from binary_tree2 import BinaryTree
import operator

def build_parse_tree(fp_exp):
    fp_list = fp_exp.split()
    p_stack = Stack()
    e_tree = BinaryTree(&#39;&#39;)
    p_stack.push(e_tree)
    current_tree = e_tree

    for i in fp_list:
        if i == &#39;(&#39;:
            current_tree.insert_left(&#39;&#39;)
            p_stack.push(current_tree)
            current_tree = current_tree.get_left_child()
        elif i not in [&#39;+&#39;,&#39;-&#39;,&#39;*&#39;,&#39;/&#39;,&#39;)&#39;]:
            current_tree.set_root_val(int(i))
            parent = p_stack.pop()
            current_tree = parent
        elif i in [&#39;+&#39;,&#39;-&#39;,&#39;*&#39;,&#39;/&#39;]:
            current_tree.set_root_val(i)
            current_tree.insert_right(&#39;&#39;)
            p_stack.push(current_tree)
            current_tree = current_tree.get_right_child()
        elif i == &#39;)&#39;:
            current_tree = p_stack.pop()
        else:
            raise ValueError

    return e_tree

def postorder_eval(tree):
    opers = {&#39;+&#39;:operator.add, &#39;-&#39;:operator.sub, &#39;*&#39;:operator.mul, &#39;/&#39;: operator.truediv}
    res1 = None
    res2 = None

    if tree:
        res1 = postorder_eval(tree.get_left_child())
        res2 = postorder_eval(tree.get_right_child())
        if res1 and res2:
            return opers[tree.get_root_val()](res1, res2)
        else:
            return tree.get_root_val()

pt = build_parse_tree(&quot;( ( 10 + 5 ) * 3 )&quot;)

print(&#39;result = %d&#39; %postorder_eval(pt))
</code></pre>

<h2 id="toc_6">树的遍历</h2>

<p>对树中所有节点的访问称为<strong>遍历</strong>(traversal)。按照节点的访问方式不同，树的遍历模式可分为 3 种。这三种方式常被用于访问树的节点，它们之间的不同在于访问每个节点的次序不同。这三种遍历分别叫做<strong>先序遍历</strong>(preorder)，<strong>中序遍历</strong>(inorder)和<strong>后序遍历</strong>(postorder)。具体定义为：</p>

<ul>
<li><p><strong>先序遍历</strong> 先访问根节点，然后递归使用先序遍历访问左子树，再递归使用先序遍历访问右子树。</p></li>
<li><p><strong>中序遍历</strong> 递归使用中序遍历访问左子树，然后访问根节点，最后再递归使用中序遍历访问右子树。</p></li>
<li><p><strong>后序遍历</strong> 先递归使用后序遍历访问左子树和右子树，最后访问根节点。</p></li>
</ul>

<p>三种遍历模式的代码已经包括在<code>BinaryTree</code>类中（参见<code>节点和引用</code>一节）。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Magic Methods: Item Access]]></title>
    <link href="http://larryim.cc/magic_method_item_access.html"/>
    <updated>2017-07-18T12:54:51+08:00</updated>
    <id>http://larryim.cc/magic_method_item_access.html</id>
    <content type="html"><![CDATA[
<p>Useful magic methods allows you to create objects that behave like sequences or mappings.</p>

<h2 id="toc_0">Sequence and Mapping Protocol</h2>

<p><code>protocol</code> in Python usually describe the rules governing some form of behavior. The <code>protocol</code> states which methods you should implement and what those methods should do. So, to be a sequence means,  to follow the sequence protocol.</p>

<ul>
<li><code>__len__(self)</code>: This method should return the number of items contained in the collection. For a sequence, this would simply be the number of elements. For a mapping, it would be the number of key-value pairs. If <code>__len__</code> returns zero (and you don’t implement <code>__nonzero__</code>, which overrides this behavior), the object is treated as false in a Boolean context (as with empty lists, tuples, strings, and dictionaries).</li>
<li><code>__getitem__(self, key)</code>: This should return the value corresponding to the given key. For a sequence, the key should be an integer from \(0\) to \(n–1\) (or, it could be negative, as noted later), where \(n\) is the length of the sequence. For a mapping, you could really have any kind of keys.</li>
<li><code>__setitem__(self, key, value)</code>: This should store value in a manner associated with key, so it can later be retrieved with <code>__getitem__</code>. Of course, you define this method only for mutable objects.</li>
<li><code>__delitem__(self, key)</code>: This is called when someone uses the <code>del</code> statement on a part of the object, and should delete the element associated with key. Again, only mutable objects (and not all of them—only those for which you want to let items be removed) should define this method.</li>
</ul>

<h2 id="toc_1">Example</h2>

<pre><code class="language-python">def checkIndex(key):
    &quot;&quot;&quot;
    Is the given key an acceptable index?
    To be acceptable, the key should be a non-negative integer. If it
    is not an integer, a TypeError is raised; if it is negative, an
    IndexError is raised (since the sequence is of infinite length).
    &quot;&quot;&quot;
    if not isinstance(key, int):
        raise TypeError
    if key &lt; 0:
        raise IndexError


class ArithmeticSequence:
    def __init__(self, start=0, step=1):
        &quot;&quot;&quot;
        Initialize the arithmetic sequence.
        start   - the first value in the sequence
        step    - the difference between two adjacent values
        changed - a dictionary of values that have been modified by the user
        &quot;&quot;&quot;
        self.start = start
        self.step = step
        self.changed = {}

    def __getitem__(self, key):
        &quot;&quot;&quot;
        Get an item from the arithmetic sequence.
        &quot;&quot;&quot;
        checkIndex(key)
        try:
            return self.changed[key]
        except KeyError:
            return self.start + key*self.step
    # Store the start value
    # Store the step value
    # No items have been modified
    # Modified?
    # otherwise...
    # ...calculate the value

    def __setitem__(self, key, value):
        &quot;&quot;&quot;
        Change an item in the arithmetic sequence.
        &quot;&quot;&quot;
        checkIndex(key)
        self.changed[key] = value                 # Store the changed value

    def __delitem__(self, key):
        &quot;&quot;&quot;
        Delete the key provided from sequence
        &quot;&quot;&quot;
        checkIndex(key)
        del self.changed[key]



if __name__ == &quot;__main__&quot;:
    s = ArithmeticSequence(1, 2)
    print(s[4])
    s[4]=3
    print(s[4])
    del s[4]
    print(s[4])
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Database System Concept (2): Introduction to Relational Model]]></title>
    <link href="http://larryim.cc/15002606936534.html"/>
    <updated>2017-07-17T11:04:53+08:00</updated>
    <id>http://larryim.cc/15002606936534.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Database System Concept (1): Introduction]]></title>
    <link href="http://larryim.cc/15002564768282.html"/>
    <updated>2017-07-17T09:54:36+08:00</updated>
    <id>http://larryim.cc/15002564768282.html</id>
    <content type="html"><![CDATA[
<p>A <code>database-management system</code> (DBMS，数据库管理系统) is a collection of interrelated data and a set of programs to access those data.  The collection of data, usually referred to as the <code>database</code>. The primary goal of a DBMS is to provide a way to store and retrieve database information that is both <code>convenient</code> and <code>efficient</code>.</p>

<h2 id="toc_0">Purpose of Database System</h2>

<p>Keeping organizational information in a file-processing system has a number of major disadvantages:</p>

<ul>
<li>Data redundancy and inconsistency

<ul>
<li>Users of one program may be unaware of potentially useful data held by other programs.</li>
</ul></li>
<li>Difficulty in accessing data

<ul>
<li>Programs are written to satisfy particular functions.<br/></li>
<li>Any new requirement needs a new program.</li>
</ul></li>
<li>Data isolation

<ul>
<li>Same data is held by different programs </li>
<li>Each program maintains its own set of data</li>
</ul></li>
<li>Integrity problems</li>
<li>Atomicity problems</li>
<li>Concurrent-access anomalies</li>
<li>Security problems</li>
</ul>

<h2 id="toc_1">View of data</h2>

<h3 id="toc_2">Data Abstraction</h3>

<p>The need for efficiency has led designers to use complex data structures to represent data in the database.</p>

<ul>
<li><code>Physical level</code>. The lowest level of abstraction <em>how</em> the data are actually stored</li>
<li><code>Logical level</code>. The next-higher level of abstraction describes <em>what</em> data are stored in the database, and what relationships exist among those data. Each record is described by a type definition, and the interrelationship of these record types is defined as well.</li>
<li><code>View level</code>. The highest level of abstraction describes only part of the entire data. The system may provide many views for the same database. Computer users see a set of application programs that hide details of the data types.</li>
</ul>

<p><img src="media/15002564768282/Screen%20Shot%202017-07-17%20at%2010.08.36%20AM.png" alt="The three views of data abstraction"/></p>

<h3 id="toc_3">Instances and Schemas</h3>

<ul>
<li><code>Instance</code>: the collection of information stored in the database at a particular moment</li>
<li><code>schema</code>: the overall design of the database.</li>
</ul>

<p>Database systems have several schemas, partitioned according to the levels of abstraction. The <code>Physical schema</code> describes the database design at the physical level, while the <code>logical schema</code> describes the database design at the logical level.</p>

<p>Applications programs are said to exhibit <code>physical data independence</code> if they do not depend on the <code>physical schema</code>, and thus need not be rewritten if the physical schema changes.</p>

<h3 id="toc_4">Data Models</h3>

<p><code>Data Model</code>(数据库): a collection of conceptual tools for describing data, data relationships, data semantics, and consistency constraints.</p>

<ul>
<li><code>Relational Model</code>(关系数据库)</li>
<li><code>Entity-Relationship Model</code> (实体对象模型)</li>
<li><code>Object-Based Data Model</code> (基于对象的数据模型)</li>
<li><code>Semistructed Data Model</code></li>
</ul>

<h2 id="toc_5">Database Language</h2>

<p>A database system provides a <code>data-definition language</code>(DDL) to specify the database schema and a <code>data-manipulation language</code>(DML) to express database queries and updates.</p>

<h2 id="toc_6">Data Storage and Querying</h2>

<p>A database system is partitioned into modules that deal with each of the responsibilities of the overall system. The functional components of a database system can be broadly divided into the <code>storage manager</code> and the <code>query processor</code></p>

<p>The <code>storage manager</code> is the component of a database system that provides the interface between the low-level data stored in the database and the application programs and queries submitted to the system. it is responsible for storing, retrieving, and updating data in the database. The storage manager translates the various DML statement into low-level file-system commands.</p>

<p>The <code>query processor</code> includes:</p>

<ul>
<li><code>DDL interpreter</code>, which interprets DDL statements and records the definitions in the data dictionary.</li>
<li><code>DML compiler</code>, which translates DML statements in a query language into an evaluation plan consisting of low-level instructions that the query evaluation engine understands.</li>
<li><code>Query evaluation engine</code>, which executes low-level instructions generated by the DML compiler.</li>
</ul>

<h2 id="toc_7">Transaction management</h2>

<p><code>Transaction management</code> ensures that the database remains in a consistent (correct) state despite system failures. The transaction manager ensures that concurrent transaction executions proceed without conflicting.</p>

<h2 id="toc_8">Database Architecture</h2>

<p>The architecture of a database system is greatly influenced by the underlying computer system on which the database system runs. Database system can be centralized, or client-server, where one server machine executes work on behalf of multiple client machines.</p>

<p><img src="media/15002564768282/Screen%20Shot%202017-07-17%20at%2010.55.20%20AM.png" alt="System Structure"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Recursion Iteration Performace]]></title>
    <link href="http://larryim.cc/recursion_iteration.html"/>
    <updated>2017-07-16T09:45:43+08:00</updated>
    <id>http://larryim.cc/recursion_iteration.html</id>
    <content type="html"><![CDATA[
<p>The performance of <code>Recursion</code> v.s. <code>Iteration</code> depends on the language being used.</p>

<p>In Java, C, and Python, <code>recursion</code> is fairly expensive compared to <code>iteration</code> (in general) because it requires the allocation of a new <code>stack frame</code>. In some C compilers, one can use a compiler flag to eliminate this overhead, which transforms certain types of recursion (actually, certain types of tail calls) into jumps instead of function calls.</p>

<h2 id="toc_0">Stack Frame</h2>

<p>When a function is called in Python, a <code>stack frame</code> is allocated to handle the local variables of the function. When the function returns, the return value is left on the top of the stack for the calling function to access.</p>

<p>The stack frame provide a <code>scope</code> for the variables used by the function. Even though we are calling the same function over and over, each call creates a new scope for the variables that are local to the function.</p>

<h3 id="toc_1">Get Stack Frame</h3>

<p>The <code>inspect</code> module in <code>python</code> provides several useful functions to help get information about live objects such as modules, classes, methods, functions, tracebacks, <code>frame objects</code>, and code objects.</p>

<pre><code class="language-python">import inspect

def f1():
    names = []
    # inpect.currentframe
    # Return the frame object for the caller’s stack frame.
    frame = inspect.currentframe()
  
    ## Keep moving to next outer frame
    while True:
        try:
            frame = frame.f_back # next outer frame object (this frame’s caller)
            name = frame.f_code.co_name # name with which this code object was defined
            names.append(name)
        except:
            break
    return names
    
def f2():
   return f1()

def f3():
   return f2()

def f4():
   return f3()

print(f4())
</code></pre>

<p>The results shows:</p>

<pre><code class="language-python">[&#39;f2&#39;, &#39;f3&#39;, &#39;f4&#39;, &#39;&lt;module&gt;&#39;]
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hashing (2): Using hashing to implement Map ADT]]></title>
    <link href="http://larryim.cc/hash_table_2.html"/>
    <updated>2017-07-17T09:00:36+08:00</updated>
    <id>http://larryim.cc/hash_table_2.html</id>
    <content type="html"><![CDATA[
<p>The <code>map</code> abstract data type is an unordered collection of associations between a key and a data value (just like a dictionary in Python). The <code>keys</code> in a map are all unique so that there is a one-to-one relationship between a key and a value.</p>

<p>The operations are given below:</p>

<ul>
<li><code>Map()</code> Create a new, empty map. If the key is already in the map, then replace the old value with the new value</li>
<li><code>put(key, val)</code> Add a new key-value pair to the map. If the key is already in the map, then replace the old value with the new value.</li>
<li><code>get(key)</code> Given a key, return the value stored in the map or None otherwise.</li>
<li><code>del</code> Delete the key-value pair from the map using a statement of the form <code>del map[key]</code></li>
<li><code>len()</code> Return the number of key-value pairs stored in the map</li>
<li><code>in</code> Return <code>True</code> for a statement of the form <code>key in map</code>, if the given key is in the map, <code>False</code> otherwise.</li>
</ul>

<p>It would be better to use a hash table  than a list with binary search since looking up an item in a hash table can approach \(O(1)\) performance.</p>

<p>Two list, are used to create <code>HashTable</code> class that implement the Map abstract data type. One called <code>slots</code> which will hold the key items; another called <code>data</code> which will hold the data values. It is important that the size of the hash table be a prime number so that the collision resolution algorithm can be as efficient as possible. </p>

<p><code>hash_function</code> implements the hash function by simple <code>remainder method</code>. The collision resolution is linear probing. The <code>put</code> function assumes that there will eventually be an empty slot unless the key is already present in the <code>self.slots</code></p>

<pre><code class="language-python">

class HashTable:
    &quot;&quot;&quot;
    &gt;&gt;&gt; h=HashTable()
    &gt;&gt;&gt; h[54]=&quot;cat&quot;
    &gt;&gt;&gt; h[26]=&quot;dog&quot;
    &gt;&gt;&gt; h[93]=&quot;lion&quot;
    &gt;&gt;&gt; h[77]=&quot;bird&quot;
    &gt;&gt;&gt; h[31]=&quot;cow&quot;
    &gt;&gt;&gt; h[44]=&quot;goat&quot;
    &gt;&gt;&gt; h.slots
    [77, 44, None, None, 26, 93, None, None, None, 31, 54]
    &gt;&gt;&gt; h.data
    [&#39;goat&#39;, None, None, None, &#39;dog&#39;, &#39;lion&#39;, None, None, None, &#39;cow&#39;, &#39;cat&#39;]
    &quot;&quot;&quot;
    def __init__(self):
        self.size = 11
        self.slots = [None] * self.size
        self.data = [None]* self.size

    def put(self, key, data):
        hash_value = self.hash_function(key, len(self.slots))
        if self.slots[hash_value] is None:
            self.slots[hash_value] = key
            self.data[hash_value] = data
        elif self.slots[hash_value] == key:
            self.data[hash_value] = data
        else:
            # rehash
            next_slot = self.rehash(hash_value, len(self.slots))
            while self.slots[next_slot] is not None and self.slots[next_slot] != key:
                next_slot = self.rehash(hash_value, len(self.slots))

            if self.slots[next_slot] is None:
                self.slots[next_slot] = key
                self.data[hash_value] = data
            else:
                self.data[hash_value] = data

    def hash_function(self, key, size):
        &quot;&quot;&quot;
        hash_function implements the simple remainder method
        &quot;&quot;&quot;
        return key % size

    def rehash(self, old_hash, size):
        &quot;&quot;&quot;
        linear probing with a plus 1
        &quot;&quot;&quot;
        return (old_hash+1) % size

    def get(self, key):
        start_slot = self.hash_function(key, len(self.slots))
        data = None
        stop = False
        found = False
        position = start_slot
        while self.slots[position] is not None and \
                not found and not stop:
            if self.slots[position] == key:
                found = True
                data = self.data[position]
            else:
                position = self.rehash(position, len(self.slots))
            if position == start_slot:
                stop = True
        return data

    def __getitem__(self, key):
        return self.get(key)

    def __setitem__(self, key, data):
        self.put(key, data)

    def __len__(self):
        &quot;&quot;&quot;
        return length
        &quot;&quot;&quot;
        count = 0
        for item in self.slots:
            if item is not None:
                count += 1

        return count

    def __contains__(self, item):
        &quot;&quot;&quot;
        定义了使用in和not in进行成员测试时类的行为
        &quot;&quot;&quot;
        return self.get(item) is not None


if __name__ == &quot;__main__&quot;:
    import doctest
    doctest.testmod(verbose=True)
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dijkstra's algorithm]]></title>
    <link href="http://larryim.cc/dijkstra_algorithm.html"/>
    <updated>2017-07-14T14:35:59+08:00</updated>
    <id>http://larryim.cc/dijkstra_algorithm.html</id>
    <content type="html"><![CDATA[
<p><code>Dijkstra&#39;s algorithm</code> is an iterative algorithm that provides us with the shortest path from one particular starting node to all other nodes in the graph.</p>

<p>The algorithm iterates once for every vertex in the graph. The order that iterates over the vertices is controlled by a <code>priority queue</code>. When a vertex is first created <code>dist</code> is set to a very large number(<code>sys.maxsize</code>)</p>

<pre><code>Dijkstra(G, w, s)
INITIALIZE-SINGLE-SOURCE(G, s)
Q=G.V
while Q:
    u = EXTRACT-MIN(Q)
    for each vertex in adjacent
        RELAX(u,v,w)
</code></pre>

<pre><code class="language-python">from priorityqueue import PriorityQueue
from graph import Graph, Vertex
import sys
import unittest

def dijkstra(aGraph, start):
    &quot;&quot;&quot;
    Find Single-Source shortest-paths on a weighted, directed graph
    Return shortest path
    aGraph: class Graph
    start: class Vertex
    &quot;&quot;&quot;
    pq = PriorityQueue()
    start.setDistance(0)
    pq.buildHeap([(v.getDistance(), v) for v in aGraph])
    while not pq.isEmpty():
        u = pq.delMin()
        for adjacent in u.getConnections():
            newDist = u.dist + u.getWeight(adjacent)
            if adjacent.dist &gt; newDist:
                adjacent.setDistance(newDist)
                adjacent.setPred(u)
                pq.decreaseKey(adjacent, newDist)


class TestDijkstra(unittest.TestCase):


    def testShortest(self):

        aGraph = Graph()
        with open(&#39;dijkstraData.txt&#39;) as infile:
            for line in infile:
                numbers = [number for number in line.split()]
                from_v = int(numbers[0])

                for to_v_cost in numbers[1:]:
                    to_v, cost = to_v_cost.split(&#39;,&#39;)
                    aGraph.addEdge(from_v, int(to_v), int(cost))

        dijkstra(aGraph, aGraph.getVertex(1))

        dists = []
        for vertex_id in [7, 37, 59, 82, 99, 115, 133, 165, 188, 197]:
            dist = aGraph.getVertex(vertex_id).getDistance()
            if dist == sys.maxsize:
                dist = 100000
            dists.append(dist)
        assert dists == [2599, 2610, 2947, 2052, 2367, 2399, 2029, 2442, 2505, 3068]


if __name__ == &#39;__main__&#39;:
    unittest.main()
</code></pre>

<p>It is important to note that <code>Dijkstra&#39;s algorithm</code> works only when the weights are all positive. If you introduced a negative weight on one of the edges to the graph that the algorithm would never exit.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing]]></title>
    <link href="http://larryim.cc/testing.html"/>
    <updated>2017-07-14T10:33:50+08:00</updated>
    <id>http://larryim.cc/testing.html</id>
    <content type="html"><![CDATA[
<p><a href="https://en.wikipedia.org/wiki/Unit_testing">Unit testing</a> is a software testing method by which individual units of source code, sets of one or more computer program modules together with associated control data, usage procedures, and operating procedures, are tested to determine whether they are fit for use.</p>

<h2 id="toc_0">Test-driven programming</h2>

<p>&quot;<strong>Test first and code later</strong>&quot; practice, known as test-driven programming, instead of test after code.</p>

<h3 id="toc_1">Requirement Specification</h3>

<p>When developing a piece of software, you must first know what problem the software will solve—what objectives it will meet. You can clarify your goals for the program by writing a <strong>requirement specification</strong>, a document (or just some quick notes) describing requirements the program must satisfy. </p>

<h3 id="toc_2">The 1-2-3-4 of Testing</h3>

<p>Here’s a breakdown of the test-driven development process:</p>

<ul>
<li>Figure out the new feature you want. Possibly document it, and then write a test for it.</li>
<li>Write some skeleton code for the feature, so that you program runs without any syntax errors. See your test fail.</li>
<li>Write dummy code for skeleton code, just to appease the test.</li>
<li>Rewrite the code so that it actually pass the test.</li>
</ul>

<h2 id="toc_3">Testing Tools</h2>

<p>Two brilliant modules are available to automate the testing process:</p>

<ul>
<li><code>unittest</code>: A generic testing framework.</li>
<li><code>doctest</code>: A simpler module, designed for checking documentation, but excellent for writing unit tests as well.</li>
</ul>

<h3 id="toc_4">doctest</h3>

<p>The <code>testmod</code> function checks both the module docstring and function docstring.</p>

<p>E.g.</p>

<pre><code class="language-python">def square(x):
    &quot;&quot;&quot;
    squares a number and returns the result.
    &gt;&gt;&gt; square(2)
    4
    &gt;&gt;&gt; square(3)
    9
    &quot;&quot;&quot;
    return x*x

if __name__ == &quot;__main__&quot;:
    import doctest, doc_test_example
    doctest.testmod(doc_test_example, verbose=True)
</code></pre>

<p>Run the example. To get some more output, just add <code>-v</code>(for verbose)</p>

<pre><code class="language-bash">$ python doc_test_example.py -v
Trying:
    square(2)
Expecting:
    4
ok
Trying:
    square(3)
Expecting:
    9
ok
1 items had no tests:
    doc_test_example
1 items passed all tests:
   2 tests in doc_test_example.square
2 tests in 2 items.
2 passed and 0 failed.
Test passed.
</code></pre>

<h3 id="toc_5">unittest</h3>

<p><code>unittest</code> which is based on the popular test framework <code>JUnit</code>, is more flexible and powerful. It allows to write very large and thorough test sets in a more structured manner.</p>

<p><strong>注意： 测试方法应该以test为前缀命名</strong></p>

<p>E.g.</p>

<pre><code class="language-python">import unittest
import doc_test_example as my_math

class ProductTestCase(unittest.TestCase):

    def testIntegers(self):
        for x in xrange(-10,10):
            p = my_math.square(x)
            self.failUnless(p == x*x, &#39;Integer multiplication failed&#39;)

    def testFloats(self):
        for x in xrange(-10,10):
            x = x/10.0
            p = my_math.square(x)
            self.failUnless(p == x*x, &#39;Float multiplication failed&#39;)


if __name__ == &quot;__main__&quot;:
    unittest.main()
</code></pre>

<p>Another example to test <code>dijkstra&#39;s algorithm</code> see <a href="http://larryim.cc/dijkstra_algorithm.html">here</a></p>

<p>Methods such as <code>failUnless</code> check a condition to determine whether the given test succeeds or fails. </p>

<p>The <code>unittest</code> module distinguishes between <code>errors</code>, where an exception is raised, and <code>failures</code>, which result from calls to <code>failUnless</code> and the like. </p>

<h2 id="toc_6">Source Code Checking</h2>

<p><a href="https://www.pylint.org">Pylint</a> and PyChecker are good tools for checking Python source code, looking for mistakes.</p>

<p><code>Pylint</code> is a tool that checks for errors in Python code, tries to enforce a coding standard and looks for code smells. It can also look for certain type errors, it can recommend suggestions about how particular blocks can be refactored and can offer you details about the code’s complexity.</p>

<p><code>Pylint</code> can be integrated with <code>Pycharm</code>, see <a href="https://pylint.readthedocs.io/en/latest/user_guide/ide-integration.html#pylint-in-pycharm">detail</a>.</p>

<h3 id="toc_7">Resources</h3>

<ul>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-pylint/index.html">如何使用 Pylint 来规范 Python 代码风格</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0008/">Style Guide for Python Code</a></li>
</ul>

<h2 id="toc_8">Profile</h2>

<p><strong>When in doubt, use brute force</strong></p>

<p>The standard library includes nice profiler modules called <code>profile</code> and <code>cProfile</code>.  </p>

<p>A <code>profile</code> is a set of statistics that describes how often and for how long various parts of the program executed. </p>

<pre><code class="language-python">&gt;&gt;&gt; import profile
&gt;&gt;&gt; from my_math import square
&gt;&gt;&gt; profile.run(&#39;square(1, 2)&#39;)
</code></pre>

<p>Another way to use <code>profile</code> in command-line:</p>

<pre><code class="language-bash">$ python -m profile prof1py
</code></pre>

<p>The standard library also contains a module called <code>timeit</code>, which is a simple way of timing small snippets of Python code.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Anaconda]]></title>
    <link href="http://larryim.cc/anaconda.html"/>
    <updated>2017-07-13T13:35:47+08:00</updated>
    <id>http://larryim.cc/anaconda.html</id>
    <content type="html"><![CDATA[
<p><a href="https://www.continuum.io/why-anaconda">Anaconda </a>(/ˌænə&#39;kɑndə/)是一个用于科学计算的python发行版，支持各种系统，提供了包管理和环境管理的功能。Anaconda 利用<code>conda</code>来进行package和environment的管理。</p>

<h2 id="toc_0">Conda的包管理</h2>

<p><code>Conda</code>既是一个工具，也是一个可执行命令，其核心功能是包管理和环境管理。包管理与<code>pip</code>使用类似。</p>

<pre><code class="language-python"># 安装package
conda install package

# 查看已经安装的packages
conda list

# 查找package信息
conda search package

# 更新package
conda update -n python27 package

# 删除package
conda remove -n python27 package
</code></pre>

<h2 id="toc_1">Conda的环境管理</h2>

<pre><code class="language-bash"># 创建一个名为python27的环境，指定Python版本是2.7
conda create --name python27 python=2.7

# 安装好后，使用activate激活某个环境
source activate python27 # 激活后，会发现terminal输入的地方多了python27的字样，实际上，此时系统做的事情就是把默认环境从PATH中去除，再把2.7对应的命令加入PATH

# 如果想返回python 2.7环境，运行
source deactivate python27 # for Linux &amp; Mac

# 删除一个已有的环境
conda remove --name python27 --all
</code></pre>

<h2 id="toc_2">使用Pycharm</h2>

<p>在<code>Pycharm</code>配置里选用<code>Anaconda</code>的<code>python</code>编译器所在位置即可。</p>

<h2 id="toc_3">Resources</h2>

<p><a href="https://conda.io/docs/_downloads/conda-cheatsheet.pdf">Conda Cheat Sheet</a></p>

]]></content>
  </entry>
  
</feed>
