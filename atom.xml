<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[techlarry]]></title>
  <link href="http://larryim.cc/atom.xml" rel="self"/>
  <link href="http://larryim.cc/"/>
  <updated>2017-09-08T15:13:16+08:00</updated>
  <id>http://larryim.cc/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Batch Normalization]]></title>
    <link href="http://larryim.cc/batch_normalization.html"/>
    <updated>2017-09-08T11:16:27+08:00</updated>
    <id>http://larryim.cc/batch_normalization.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Covariate Shift</h2>

<p>While stochastic gradient is simple and effective, it requires careful tuning of the model hyper-parameters, specifically the learning rate used in optimization, as well as the initial values for the model parameters. The train- ing is complicated by the fact that the inputs to each layer are affected by the parameters of all preceding layers – so that small changes to the network parameters amplify as the network becomes deeper.</p>

<p>The change in the distribution of layers&#39; inputs presents a problem because the layers need to continuously adapt to the new distribution. When the input distribution to a learning system changes, it is said to experience <code>covariate shift</code>. This is typically handled via domain adaption.</p>

<p><code>Internal Covariate Shift</code> refers to the change in the distribution of internal nodes of a deep network due to change in network parameters, in the course of training. <code>Batch Normalization</code>, that takes a step towards reducing internal covariance shift, and in doing so dramatically accelerates the training of deep neural nets. It accomplishes this via a normalization step that fixes the means and variances of layer inputs. It also has a beneficial effect on the dependence of gradients on the scale of the parameters or of their initial values. This allows us to use much higher learning rates without the risk of divergence. </p>

<h2 id="toc_1">Algorithm</h2>

<h3 id="toc_2">forward</h3>

<p>Given some input values \(x^{(1)},...,x^{(m)}\) over a mini-batch in the layer \(l\) of neural network.</p>

<p><img src="media/15048405877529/Screen%20Shot%202017-09-08%20at%203.11.32%20PM.png" alt="batch-normalization-forward"/></p>

<h3 id="toc_3">Backward</h3>

<p><img src="media/15048405877529/Screen%20Shot%202017-09-08%20at%203.11.45%20PM.png" alt="batch-normalization-backward"/></p>

<h3 id="toc_4">Test time</h3>

<p>Estimate \(\mu, \sigma^2\) using exponentially weighted average( across mini-batch). Using trained \(\alpha, \beta\)</p>

<h2 id="toc_5">TensorFlow</h2>

<p>Applying <code>Batch Normalization</code> in TensorFlow Model is very convenient. Just add one line of code in TensorFlow: <code>tf.nn.batch-normalization</code>.</p>

<h2 id="toc_6">Reference</h2>

<p>Sergey Ioffe, Christian Szegedy. 2015. Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift. arXiv:<a href="https://arxiv.org/abs/1502.03167v3">1501.02167v3</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TensorFlow Q]]></title>
    <link href="http://larryim.cc/15046658203135.html"/>
    <updated>2017-09-06T10:43:40+08:00</updated>
    <id>http://larryim.cc/15046658203135.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Q1: what&#39;s the difference between <code>tf.placeholder</code> and <code>tf.Variable</code></h2>

<p>In general, we use <code>tf.placeholder</code> to feed actual training examples, while using <code>tf.Variable</code> for parameters such as weights (\(W\)) and biases (\(b\)) for models.</p>

<p>With <code>tf.Variable</code>, we have to provide an initial value when declaring it. And we don&#39;t have to provide an initial value until running time with a <code>feed_dict</code>.</p>

<h2 id="toc_1">Q2: what&#39;s the difference between <code>tf.random_normal</code> and <code>tf.trucated_normal</code></h2>

<p><code>tf.trucated_normal</code> generates values following a normal distribution with specified mean and standard deviation, except that values whose magnitude is more than 2 standard deviations from the mean are dropped and re-picked.</p>

<pre><code>import tensorflow as tf
import matplotlib.pyplot as plt
%matplotlib inline
Session = tf.InteractiveSession()
</code></pre>

<pre><code>mean = 0.0
std = 1.0
shape = (10000,)
hist_range = (-5, 5)

A = tf.truncated_normal(shape, mean, std)
B = tf.random_normal(shape, mean, std)
a, b = Session.run([A, B])
</code></pre>

<pre><code>f, (ax1, ax2) = plt.subplots(2,1)
f1 = ax1.hist(a, bins= 100, range=hist_range)
f2 = ax2.hist(b, bins= 100, range=hist_range)
</code></pre>

<p><img src="media/15046658203135/output_2_0.png" alt="output_2_0"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pandas]]></title>
    <link href="http://larryim.cc/15046649572570.html"/>
    <updated>2017-09-06T10:29:17+08:00</updated>
    <id>http://larryim.cc/15046649572570.html</id>
    <content type="html"><![CDATA[
<p>To convert a pandas <code>dataframe</code> (df) to a numpy <code>ndarray</code>, use this code:</p>

<pre><code>df=df.values
</code></pre>

<p>df now becomes a numpy <code>ndarray</code>.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[]]></title>
    <link href="http://larryim.cc/15045390828524.html"/>
    <updated>2017-09-04T23:31:22+08:00</updated>
    <id>http://larryim.cc/15045390828524.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">ML:Anomaly Detection</h2>

<h3 id="toc_1">Problem Motivation</h3>

<p>Just like in other learning problems, we are given a dataset \({x^{(1)}, x^{(2)},\dots,x^{(m)}}\).</p>

<p>We are then given a new example, \(x_{test}\), and we want to know whether this new example is abnormal/anomalous.</p>

<p>We define a &quot;model&quot; p(x) that tells us the probability the example is not anomalous. We also use a threshold ϵ (epsilon) as a dividing line so we can say which examples are anomalous and which are not.</p>

<p>A very common application of anomaly detection is detecting fraud:</p>

<ul>
<li><p>\(x^{(i)} =\) features of user i&#39;s activities</p></li>
<li><p>Model p(x) from the data.</p></li>
<li><p>Identify unusual users by checking which have p(x)&lt;ϵ.</p></li>
</ul>

<p>If our anomaly detector is flagging <strong>too many</strong> anomalous examples, then we need to <strong>decrease</strong> our threshold ϵ</p>

<h3 id="toc_2">Gaussian Distribution</h3>

<p>The Gaussian Distribution is a familiar bell-shaped curve that can be described by a function \(\mathcal{N}(\mu,\sigma^2)\)</p>

<p>Let x∈ℝ. If the probability distribution of x is Gaussian with mean μ, variance \(\sigma^2\), then:</p>

<p>\(x \sim \mathcal{N}(\mu, \sigma^2)\)</p>

<p>The little ∼ or &#39;tilde&#39; can be read as &quot;distributed as.&quot;</p>

<p>The Gaussian Distribution is parameterized by a mean and a variance.</p>

<p>Mu, or μ, describes the center of the curve, called the mean. The width of the curve is described by sigma, or σ, called the standard deviation.</p>

<p>The full function is as follows:</p>

<p>\(\large p(x;\mu,\sigma^2) = \dfrac{1}{\sigma\sqrt{(2\pi)}}e^{-\dfrac{1}{2}(\dfrac{x - \mu}{\sigma})^2}\)</p>

<p>We can estimate the parameter μ from a given dataset by simply taking the average of all the examples:</p>

<p>\(\mu = \dfrac{1}{m}\displaystyle \sum_{i=1}^m x^{(i)}\)</p>

<p>We can estimate the other parameter, \(\sigma^2\), with our familiar squared error formula:</p>

<p>\(\sigma^2 = \dfrac{1}{m}\displaystyle \sum_{i=1}^m(x^{(i)} - \mu)^2\)</p>

<h3 id="toc_3">Algorithm</h3>

<p>Given a training set of examples, \(\lbrace x^{(1)},\dots,x^{(m)}\rbrace\) where each example is a vector, \(x \in \mathbb{R}^n\).</p>

<p>\(p(x) = p(x_1;\mu_1,\sigma_1^2)p(x_2;\mu_2,\sigma^2_2)\cdots p(x_n;\mu_n,\sigma^2_n)\)</p>

<p>In statistics, this is called an &quot;independence assumption&quot; on the values of the features inside training example x.</p>

<p>More compactly, the above expression can be written as follows:</p>

<p>\(= \displaystyle \prod^n_{j=1} p(x_j;\mu_j,\sigma_j^2)\)</p>

<p><strong>The algorithm</strong></p>

<p>Choose features \(x_i\) that you think might be indicative of anomalous examples.</p>

<p>Fit parameters \(\mu_1,\dots,\mu_n,\sigma_1^2,\dots,\sigma_n^2\)</p>

<p>Calculate \(\mu_j = \dfrac{1}{m}\displaystyle \sum_{i=1}^m x_j^{(i)}\)</p>

<p>Calculate \(\sigma^2_j = \dfrac{1}{m}\displaystyle \sum_{i=1}^m(x_j^{(i)} - \mu_j)^2\)</p>

<p>Given a new example x, compute p(x):</p>

<p>\(p(x) = \displaystyle \prod^n_{j=1} p(x_j;\mu_j,\sigma_j^2) = \prod\limits^n_{j=1} \dfrac{1}{\sqrt{2\pi}\sigma_j}exp(-\dfrac{(x_j - \mu_j)^2}{2\sigma^2_j})\)</p>

<p>Anomaly if p(x)&lt;ϵ</p>

<p>A vectorized version of the calculation for μ is \(\mu = \dfrac{1}{m}\displaystyle \sum_{i=1}^m x^{(i)}\). You can vectorize \(\sigma^2\) similarly.</p>

<h3 id="toc_4">Developing and Evaluating an Anomaly Detection System</h3>

<p>To evaluate our learning algorithm, we take some labeled data, categorized into anomalous and non-anomalous examples ( y = 0 if normal, y = 1 if anomalous).</p>

<p>Among that data, take a large proportion of <strong>good</strong> , non-anomalous data for the training set on which to train p(x).</p>

<p>Then, take a smaller proportion of mixed anomalous and non-anomalous examples (you will usually have many more non-anomalous examples) for your cross-validation and test sets.</p>

<p>For example, we may have a set where 0.2% of the data is anomalous. We take 60% of those examples, all of which are good (y=0) for the training set. We then take 20% of the examples for the cross-validation set (with 0.1% of the anomalous examples) and another 20% from the test set (with another 0.1% of the anomalous).</p>

<p>In other words, we split the data 60/20/20 training/CV/test and then split the anomalous examples 50/50 between the CV and test sets.</p>

<p><strong>Algorithm evaluation:</strong></p>

<p>Fit model p(x) on training set \(\lbrace x^{(1)},\dots,x^{(m)} \rbrace\)</p>

<p>On a cross validation/test example x, predict:</p>

<p>If p(x) &lt; ϵ ( <strong>anomaly</strong> ), then y=1</p>

<p>If p(x) ≥ ϵ ( <strong>normal</strong> ), then y=0</p>

<p>Possible evaluation metrics (see &quot;Machine Learning System Design&quot; section):</p>

<ul>
<li><p>True positive, false positive, false negative, true negative.</p></li>
<li><p>Precision/recall</p></li>
<li><p>\(F_1\) score</p></li>
</ul>

<p>Note that we use the cross-validation set to choose parameter ϵ</p>

<h3 id="toc_5">Anomaly Detection vs. Supervised Learning</h3>

<p>When do we use anomaly detection and when do we use supervised learning?</p>

<p>Use anomaly detection when...</p>

<ul>
<li><p>We have a very small number of positive examples (y=1 ... 0-20 examples is common) and a large number of negative (y=0) examples.</p></li>
<li><p>We have many different &quot;types&quot; of anomalies and it is hard for any algorithm to learn from positive examples what the anomalies look like; future anomalies may look nothing like any of the anomalous examples we&#39;ve seen so far.</p></li>
</ul>

<p>Use supervised learning when...</p>

<ul>
<li><p>We have a large number of both positive and negative examples. In other words, the training set is more evenly divided into classes.</p></li>
<li><p>We have enough positive examples for the algorithm to get a sense of what new positives examples look like. The future positive examples are likely similar to the ones in the training set.</p></li>
</ul>

<h3 id="toc_6">Choosing What Features to Use</h3>

<p>The features will greatly affect how well your anomaly detection algorithm works.</p>

<p>We can check that our features are <strong>gaussian</strong> by plotting a histogram of our data and checking for the bell-shaped curve.</p>

<p>Some <strong>transforms</strong> we can try on an example feature x that does not have the bell-shaped curve are:</p>

<ul>
<li><p>log(x)</p></li>
<li><p>log(x+1)</p></li>
<li><p>log(x+c) for some constant</p></li>
<li><p>\(\sqrt{x}\)</p></li>
<li><p>\(x^{1/3}\)</p></li>
</ul>

<p>We can play with each of these to try and achieve the gaussian shape in our data.</p>

<p>There is an <strong>error analysis procedure</strong> for anomaly detection that is very similar to the one in supervised learning.</p>

<p>Our goal is for p(x) to be large for normal examples and small for anomalous examples.</p>

<p>One common problem is when p(x) is similar for both types of examples. In this case, you need to examine the anomalous examples that are giving high probability in detail and try to figure out new features that will better distinguish the data.</p>

<p>In general, choose features that might take on unusually large or small values in the event of an anomaly.</p>

<h3 id="toc_7">Multivariate Gaussian Distribution (Optional)</h3>

<p>The multivariate gaussian distribution is an extension of anomaly detection and may (or may not) catch more anomalies.</p>

<p>Instead of modeling \(p(x_1),p(x_2),\dots\) separately, we will model p(x) all in one go. Our parameters will be: \(\mu \in \mathbb{R}^n\) and \(\Sigma \in \mathbb{R}^{n \times n}\)</p>

<p>\(p(x;\mu,\Sigma) = \dfrac{1}{(2\pi)^{n/2} |\Sigma|^{1/2}} exp(-1/2(x-\mu)^T\Sigma^{-1}(x-\mu))\)</p>

<p>The important effect is that we can model oblong gaussian contours, allowing us to better fit data that might not fit into the normal circular contours.</p>

<p>Varying Σ changes the shape, width, and orientation of the contours. Changing μ will move the center of the distribution.</p>

<p>Check also:</p>

<ul>
<li>  <a href="http://cs229.stanford.edu/section/gaussians.pdf">The Multivariate Gaussian Distribution</a> <a href="http://cs229.stanford.edu/section/gaussians.pdf">http://cs229.stanford.edu/section/gaussians.pdf</a> Chuong B. Do, October 10, 2008.</li>
</ul>

<h3 id="toc_8">Anomaly Detection using the Multivariate Gaussian Distribution (Optional)</h3>

<p>When doing anomaly detection with multivariate gaussian distribution, we compute μ and Σ normally. We then compute p(x) using the new formula in the previous section and flag an anomaly if p(x) &lt; ϵ.</p>

<p>The original model for p(x) corresponds to a multivariate Gaussian where the contours of \(p(x;\mu,\Sigma)\) are axis-aligned.</p>

<p>The multivariate Gaussian model can automatically capture correlations between different features of x.</p>

<p>However, the original model maintains some advantages: it is computationally cheaper (no matrix to invert, which is costly for large number of features) and it performs well even with small training set size (in multivariate Gaussian model, it should be greater than the number of features for Σ to be invertible).</p>

<h2 id="toc_9">ML:Recommender Systems</h2>

<h3 id="toc_10">Problem Formulation</h3>

<p>Recommendation is currently a very popular application of machine learning.</p>

<p>Say we are trying to recommend movies to customers. We can use the following definitions</p>

<ul>
<li><p>\(n_u =\) number of users</p></li>
<li><p>\(n_m =\) number of movies</p></li>
<li><p>\(r(i,j) = 1\) if user j has rated movie i</p></li>
<li><p>\(y(i,j) =\) rating given by user j to movie i (defined only if r(i,j)=1)</p></li>
</ul>

<h3 id="toc_11">Content Based Recommendations</h3>

<p>We can introduce two features, \(x_1\) and \(x_2\) which represents how much romance or how much action a movie may have (on a scale of 0−1).</p>

<p>One approach is that we could do linear regression for every single user. For each user j, learn a parameter \(\theta^{(j)} \in \mathbb{R}^3\). Predict user j as rating movie i with \((\theta^{(j)})^Tx^{(i)}\) stars.</p>

<ul>
<li><p>\(\theta^{(j)} =\) parameter vector for user j</p></li>
<li><p>\(x^{(i)} =\) feature vector for movie i</p></li>
</ul>

<p>For user j, movie i, predicted rating: \((\theta^{(j)})^T(x^{(i)})\)</p>

<ul>
<li>  \(m^{(j)} =\) number of movies rated by user j</li>
</ul>

<p>To learn \(\theta^{(j)}\), we do the following</p>

<p>\(min_{\theta^{(j)}} = \dfrac{1}{2}\displaystyle \sum_{i:r(i,j)=1} ((\theta^{(j)})^T(x^{(i)}) - y^{(i,j)})^2 + \dfrac{\lambda}{2} \sum_{k=1}^n(\theta_k^{(j)})^2\)</p>

<p>This is our familiar linear regression. The base of the first summation is choosing all i such that \(r(i,j) = 1\).</p>

<p>To get the parameters for all our users, we do the following:</p>

<p>\(min_{\theta^{(1)},\dots,\theta^{(n_u)}} = \dfrac{1}{2}\displaystyle \sum_{j=1}^{n_u} \sum_{i:r(i,j)=1} ((\theta^{(j)})^T(x^{(i)}) - y^{(i,j)})^2 + \dfrac{\lambda}{2} \sum_{j=1}^{n_u} \sum_{k=1}^n(\theta_k^{(j)})^2\)</p>

<p>We can apply our linear regression gradient descent update using the above cost function.</p>

<p>The only real difference is that we <strong>eliminate the constant</strong> \(\dfrac{1}{m}\).</p>

<h3 id="toc_12">Collaborative Filtering</h3>

<p>It can be very difficult to find features such as &quot;amount of romance&quot; or &quot;amount of action&quot; in a movie. To figure this out, we can use <u>feature finders</u> .</p>

<p>We can let the users tell us how much they like the different genres, providing their parameter vector immediately for us.</p>

<p>To infer the features from given parameters, we use the squared error function with regularization over all the users:</p>

<p>\(min_{x^{(1)},\dots,x^{(n_m)}} \dfrac{1}{2} \displaystyle \sum_{i=1}^{n_m} \sum_{j:r(i,j)=1} ((\theta^{(j)})^T x^{(i)} - y^{(i,j)})^2 + \dfrac{\lambda}{2}\sum_{i=1}^{n_m} \sum_{k=1}^{n} (x_k^{(i)})^2\)</p>

<p>You can also <strong>randomly guess</strong> the values for theta to guess the features repeatedly. You will actually converge to a good set of features.</p>

<h3 id="toc_13">Collaborative Filtering Algorithm</h3>

<p>To speed things up, we can simultaneously minimize our features and our parameters:</p>

<p>\(J(x,\theta) = \dfrac{1}{2} \displaystyle \sum_{(i,j):r(i,j)=1}((\theta^{(j)})^Tx^{(i)} - y^{(i,j)})^2 + \dfrac{\lambda}{2}\sum_{i=1}^{n_m} \sum_{k=1}^{n} (x_k^{(i)})^2 + \dfrac{\lambda}{2}\sum_{j=1}^{n_u} \sum_{k=1}^{n} (\theta_k^{(j)})^2\)</p>

<p>It looks very complicated, but we&#39;ve only combined the cost function for theta and the cost function for x.</p>

<p>Because the algorithm can learn them itself, the bias units where x0=1 have been removed, therefore x∈ℝn and θ∈ℝn.</p>

<p>These are the steps in the algorithm:</p>

<ol>
<li><p>Initialize \(x^{(i)},...,x^{(n_m)},\theta^{(1)},...,\theta^{(n_u)}\) to small random values. This serves to break symmetry and ensures that the algorithm learns features \(x^{(i)},...,x^{(n_m)}\) that are different from each other.</p></li>
<li><p>Minimize \(J(x^{(i)},...,x^{(n_m)},\theta^{(1)},...,\theta^{(n_u)})\) using gradient descent (or an advanced optimization algorithm).E.g. for every \(j=1,...,n_u,i=1,...n_m\):\(x_k^{(i)} := x_k^{(i)} - \alpha\left (\displaystyle \sum_{j:r(i,j)=1}{((\theta^{(j)})^T x^{(i)} - y^{(i,j)}) \theta_k^{(j)}} + \lambda x_k^{(i)} \right)\)\(\theta_k^{(j)} := \theta_k^{(j)} - \alpha\left (\displaystyle \sum_{i:r(i,j)=1}{((\theta^{(j)})^T x^{(i)} - y^{(i,j)}) x_k^{(i)}} + \lambda \theta_k^{(j)} \right)\)</p></li>
<li><p>For a user with parameters θ and a movie with (learned) features x, predict a star rating of \(\theta^Tx\).</p></li>
</ol>

<h3 id="toc_14">Vectorization: Low Rank Matrix Factorization</h3>

<p>Given matrices X (each row containing features of a particular movie) and Θ (each row containing the weights for those features for a given user), then the full matrix Y of all predicted ratings of all movies by all users is given simply by: \(Y = X\Theta^T\).</p>

<p>Predicting how similar two movies i and j are can be done using the distance between their respective feature vectors x. Specifically, we are looking for a small value of \(||x^{(i)} - x^{(j)}||\).</p>

<h3 id="toc_15">Implementation Detail: Mean Normalization</h3>

<p>If the ranking system for movies is used from the previous lectures, then new users (who have watched no movies), will be assigned new movies incorrectly. Specifically, they will be assigned θ with all components equal to zero due to the minimization of the regularization term. That is, we assume that the new user will rank all movies 0, which does not seem intuitively correct.</p>

<p>We rectify this problem by normalizing the data relative to the mean. First, we use a matrix Y to store the data from previous ratings, where the ith row of Y is the ratings for the ith movie and the jth column corresponds to the ratings for the jth user.</p>

<p>We can now define a vector</p>

<p>\(\mu = [\mu_1, \mu_2, \dots , \mu_{n_m}]\)</p>

<p>such that</p>

<p>\(\mu_i = \frac{\sum_{j:r(i,j)=1}{Y_{i,j}}}{\sum_{j}{r(i,j)}}\)</p>

<p>Which is effectively the mean of the previous ratings for the ith movie (where only movies that have been watched by users are counted). We now can normalize the data by subtracting u, the mean rating, from the actual ratings for each user (column in matrix Y):</p>

<p>As an example, consider the following matrix Y and mean ratings μ:</p>

<p>\(Y = \begin{bmatrix} 5 &amp; 5 &amp; 0 &amp; 0 \newline 4 &amp; ? &amp; ? &amp; 0 \newline 0 &amp; 0 &amp; 5 &amp; 4 \newline 0 &amp; 0 &amp; 5 &amp; 0 \newline \end{bmatrix}, \quad \mu = \begin{bmatrix} 2.5 \newline 2 \newline 2.25 \newline 1.25 \newline \end{bmatrix}\)</p>

<p>The resulting Y′ vector is:</p>

<p>\(Y&#39; = \begin{bmatrix} 2.5 &amp; 2.5 &amp; -2.5 &amp; -2.5 \newline 2 &amp; ? &amp; ? &amp; -2 \newline -.2.25 &amp; -2.25 &amp; 3.75 &amp; 1.25 \newline -1.25 &amp; -1.25 &amp; 3.75 &amp; -1.25 \end{bmatrix}\)</p>

<p>Now we must slightly modify the linear regression prediction to include the mean normalization term:</p>

<p>\((\theta^{(j)})^T x^{(i)} + \mu_i\)</p>

<p>Now, for a new user, the initial predicted values will be equal to the μ term instead of simply being initialized to zero, which is more accurate.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google Cloud Platform]]></title>
    <link href="http://larryim.cc/google-cloud-platform.html"/>
    <updated>2017-09-04T17:25:15+08:00</updated>
    <id>http://larryim.cc/google-cloud-platform.html</id>
    <content type="html"><![CDATA[
<p>Google Cloud Platform enables developers to <strong>build</strong>, <strong>test</strong> and <strong>deploy</strong> applications on Google&#39;s <em>highly-scalable</em>, <em>secure</em>, and <em>reliable</em> infrastructure.</p>

<p>All Google Cloud Platform services are associated with a project that is used to:</p>

<ul>
<li>Track resource and quota usage</li>
<li>Enable billing</li>
<li>Manage permissions and credentials</li>
<li>Enable services and APIs</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Machine Learning (6): Advice for applying machine learning]]></title>
    <link href="http://larryim.cc/15045143826264.html"/>
    <updated>2017-09-04T16:39:42+08:00</updated>
    <id>http://larryim.cc/15045143826264.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Machine Learning(9-1): Anomaly Detection]]></title>
    <link href="http://larryim.cc/anomaly-detection.html"/>
    <updated>2017-09-04T12:58:21+08:00</updated>
    <id>http://larryim.cc/anomaly-detection.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">Gaussian distribution</a>
<ul>
<li>
<a href="#toc_1">Standard normal distribution</a>
</li>
</ul>
</li>
<li>
<a href="#toc_2">Anomaly Detection Algorithm</a>
<ul>
<li>
<a href="#toc_3">Choosing features</a>
</li>
</ul>
</li>
<li>
<a href="#toc_4">Multivariable Gaussian Distribution</a>
<ul>
<li>
<a href="#toc_5">Understanding</a>
</li>
<li>
<a href="#toc_6">Anomaly Detection Algorithm using multivariable gaussian distribution</a>
</li>
</ul>
</li>
</ul>


<p>Several Examples that use <code>anomaly detection</code>:</p>

<ul>
<li><strong>Fraud detection</strong>:

<ul>
<li>\(x^{(i)}\) = features of user \(i\)&#39;s activities</li>
<li>Model \(p(x)\) from data</li>
<li>Identify unusual users by checking which have \(p(x)&lt; \varepsilon\)</li>
</ul></li>
<li><strong>Monitoring computers in a data center</strong>:

<ul>
<li>\(x^{(i)}\) =  features of machine</li>
<li>\(x_1\) = memory use</li>
<li>\(x_2\) = number of disk accesses/sec,</li>
<li>\(x_3\) = CPU load</li>
<li>\(x_4\) = CPU load/network traffic.</li>
</ul></li>
</ul>

<h2 id="toc_0">Gaussian distribution</h2>

<p><code>Gaussian distribution</code>, also called <code>normal distribution</code>, is a very common continuous probability distribution.</p>

<p>The <code>normal distribution</code> is often referred to as \(N(\mu, \sigma^2)\), Thus when a random variable \(X\) is distributed normally with mean \(\mu\)  and variances \(\sigma^{2}\), one may write<br/>
\[X\sim N(\mu, \sigma^2)\]</p>

<p>The probability density of the Gaussian distribution is:<br/>
\[p(x;\mu, \sigma^2)=\frac{1}{\sqrt{2\pi}\sigma}\exp(-\frac{(x-\mu)^2}{2\sigma^2})\]<br/>
where:<br/>
* \(\mu\) is the mean or expectation of the distribution<br/>
* \(\sigma\) is the standard deviation<br/>
* \(\sigma^2\) is the variance</p>

<p><img src="media/15045011015887/15045018120355.png" alt="Gaussian distribution"/></p>

<h3 id="toc_1">Standard normal distribution</h3>

<p><code>standard normal distribution</code> is a special case when \(\mu=0, \sigma=1\), its probability density function(the red line in the figure) is as follows,</p>

<p>\[\varphi(x)=\frac{1}{\sqrt{2\pi}}e^{-\frac{1}{2}x^2}\]</p>

<h2 id="toc_2">Anomaly Detection Algorithm</h2>

<p>Training set: \(\{x^{(1)},...,x^{(m)}\}\)<br/>
Each example is \(x\) in \(R^n\)</p>

<ol>
<li>Choose features \(x_i\) that you think might be indicative of anomalous examples.</li>
<li>Fit parameters \(\mu_1,...,\mu_n, \sigma_1^2,...,\sigma_n^2\)</li>
<li>Given new example \(x\), compute \(p(x)\):
\[p(x) = p(x_1;\mu_1, \sigma_1^2)p(x_2;\mu_2, \sigma_2^2)...p(x_n;\mu_n, \sigma_n^2)= \Pi_{j=1}^np(x_j;\mu_j, \sigma_j^2)\]
Anomaly if \(p(x)&lt;\varepsilon\)</li>
</ol>

<h3 id="toc_3">Choosing features</h3>

<p>Plotting histogram for each feature to check if it is gaussian. We can take transforms (such as log) if the result shows non-gaussian features:</p>

<pre><code class="language-python">import matplotlib.pyplot as plt
import numpy as np
%matplotlib inline

mu, sigma = 0, 1
# Draw random samples from a normal (Gaussian) distribution.
x = np.random.normal(mu,sigma,10000) 
plt.hist(x, 50)
plt.show()
</code></pre>

<p><img src="media/15045011015887/15045075369987.jpg" alt="gaussian feature"/></p>

<h2 id="toc_4">Multivariable Gaussian Distribution</h2>

<p>Multivariable Gaussian Distribution has two parameters \(\mu\in R^n\) and \(\Sigma \in R^{n\times n}\):</p>

<p>\[p(x;\mu,\Sigma) = \frac{1}{(2\pi)^{\frac{n}{2}}|\Sigma|^{\frac{1}{2}}}e^{-\frac{1}{2}(x-\mu)^T\Sigma^{(-1)}(x-\mu)}\]</p>

<h3 id="toc_5">Understanding</h3>

<p>Following examples illustrate the basic meaning of parameters in multivariable gaussian distribution:</p>

<pre><code>mean = [0, 0]
cov = [[1, 0], [0, 1]]  # diagonal covariance
# Draw random samples from a multivariate normal distribution
x, y = np.random.multivariate_normal(mean, cov, 5000).T
plt.plot(x, y, &#39;x&#39;,color=&#39;y&#39;)
plt.axis(&#39;equal&#39;)
plt.hold

# change mean
mean = [0, 10]
x, y = np.random.multivariate_normal(mean, cov, 5000).T
plt.plot(x, y, &#39;.&#39;, color=&#39;b&#39;)

# change variances
mean = [10, 10]
cov = [[1, 0], [0, 10]]  # diagonal covariance
x, y = np.random.multivariate_normal(mean, cov, 5000).T
plt.plot(x, y, &#39;-&#39;, color=&#39;r&#39;)
plt.show()
</code></pre>

<p><img src="media/15045011015887/15045091983941.jpg" alt="demo of multivarible gaussian"/></p>

<h3 id="toc_6">Anomaly Detection Algorithm using multivariable gaussian distribution</h3>

<ol>
<li>Fit model \(p(x)\) by Parameter fitting:
Given training set \(\{x^{(1)},x^{(2)},...,x^{(m)}\}\)
\[\mu=\frac{1}{m}\sum_{i=1}^mx^{(i)}\\
\Sigma=\frac{1}{m}\sum_{i=1}^m(x^{(i)}-\mu)(x^{(i)}-\mu)^T
\]</li>
<li>Given a new example \(x\), compute \(p(x)\) and flag an anomaly if \(p(x) &lt; \varepsilon\)</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Machine Learning(9-2): Recommender System]]></title>
    <link href="http://larryim.cc/recommender-system.html"/>
    <updated>2017-09-04T16:07:09+08:00</updated>
    <id>http://larryim.cc/recommender-system.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">Notations</a>
</li>
<li>
<a href="#toc_1">Collaborative Filtering</a>
</li>
<li>
<a href="#toc_2">Finding related movies</a>
</li>
</ul>


<h3 id="toc_0">Notations</h3>

<p>\(r(i,j)=1\) if user \(j\) has rated movie \(i\) (0 otherwise)<br/>
\(y^{(i,j)}=\) rating by user \(j\) on movie \(i\) (if defined)</p>

<p>\(\theta^{(j)}\) = parameter vector for user \(j\)<br/>
\(x^{(i)}\) = feature vector for movie \(i\)<br/>
For user \(j\), movie \(i\), predicted rating: \((\theta^{(j)})^T(x^{(i)})\)</p>

<p>\(m^{(j)}=\) no. of movies rated by user \(j\)</p>

<p>\(n_\mu\) = no. of users<br/>
\(n_m\) = no. of movies</p>

<h3 id="toc_1">Collaborative Filtering</h3>

<ul>
<li>Given \(x^{(1)},...,x^{(n_m)}\)(and movie ratings), can estimate \(\theta^{(1)},...,\theta^{(n_u)}\)

<ul>
<li><strong>Optimization objective</strong>:
\[\min_{\theta^{(j)}}\frac{1}{2} \sum_{i: r(i,j)=1}((\theta^{(j)})^Tx^{(i)}-y^{(i,j)})^2 + \frac{\lambda}{2}\sum_{k=1}^n(\theta_k^{(j)})^2\]</li>
</ul></li>
<li><p>Given \(\theta^{(1)},...,\theta^{(n_u)}\), can estimate \(x^{(1)},...,x^{(n_m)}\)</p>

<ul>
<li><strong>Optimization objective</strong>:
\[\min_{x^{(i)}} \frac{1}{2}\sum_{j:r(i,j)=1}((\theta^{(j)})^Tx^{(i)}-y^{(i,j)})^2 + \frac{\lambda}{2}\sum_{k=1}^n(x_k^{(i)})^2\]</li>
</ul></li>
<li><p><strong>Collaborative Filtering</strong>: \(\theta\rightarrow x\rightarrow\theta\rightarrow x \rightarrow ...\)</p></li>
</ul>

<p><strong>Better way to minimize</strong> \(x^{(1)},...,x^{(n_m)}\)and  \(\theta^{(1)},...,\theta^{(n_u)}\) <strong>simultaneously</strong>:</p>

<p>\(J(x^{(1)},...,x^{(n_m)}, \theta^{(1)},...,\theta^{(n_u)}=\\<br/>
\frac{1}{2}\sum_{(i,j):r(i,j)=1}((\theta^{(j)})^Tx^{(i)}-y^{(i,j)})^2 + \frac{\lambda}{2}\sum_{i=1}^{n_m}\sum_{k=1}^n(x_k^{(i)})^2+ \frac{\lambda}{2}\sum_{j=1}^{n_\mu}\sum_{k=1}^n(\theta_k^{(j)})^2\) </p>

<h3 id="toc_2">Finding related movies</h3>

<p>Small \(||x^{(i)}-x^{(j)}||\) indicate movie \(i\) and movie \(j\) are similar.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python `virtualenv` on mac]]></title>
    <link href="http://larryim.cc/virtualenv.html"/>
    <updated>2017-09-02T20:17:11+08:00</updated>
    <id>http://larryim.cc/virtualenv.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Install</h2>

<p>Install <code>virtualenv</code> using <code>conda</code> instead of <code>pip</code>, because it might raise error (see on <a href="virtualenv%20--no-site-packages%20venv">StackOverflow</a>)</p>

<pre><code class="language-bash">conda install virtualenv
</code></pre>

<h2 id="toc_1">create your environment</h2>

<p>Now you can create your python environment for your particular programs. For example, under the folder <code>your project</code>, you create an environment called <code>.venv</code> by:</p>

<pre><code class="language-bash">virtualenv --no-site-packages .venv
</code></pre>

<p>The command <code>--no-site-packages</code> requires the environment should not access to global site-packages (as default now).</p>

<p>Before running your program in your created environment, you need to activate it:</p>

<pre><code class="language-python">source .venv/bin/activate
</code></pre>

<p>And remember to deactivate it whenever you are done.:</p>

<pre><code>deactivate
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Convolutional Neural Networks]]></title>
    <link href="http://larryim.cc/convolutional-neural-networks.html"/>
    <updated>2017-09-01T09:16:18+08:00</updated>
    <id>http://larryim.cc/convolutional-neural-networks.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">Architecture</a>
<ul>
<li>
<ul>
<li>
<a href="#toc_1">Conv layers</a>
</li>
<li>
<a href="#toc_2">Pooling</a>
</li>
<li>
<a href="#toc_3">Fully-connected layers</a>
</li>
<li>
<a href="#toc_4">Layer Patterns</a>
</li>
<li>
<a href="#toc_5">Layer Sizing Patterns</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">Computational Considerations</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_7">The memory bottleneck is the largest bottleneck when constructing ConvNet architectures.</a>


<h2 id="toc_0">Architecture</h2>

<p>Three main types of layers to build ConvNet architectures: <strong>Convolutional Layer, Pooling Layer and Fully-Connected Layer</strong>.</p>

<p>The layers of a ConvNet have neurons arranged in 3 dimensions: <strong>width, height, depth</strong>.</p>

<p><img src="media/15042285789723/15043413926666.jpg" alt="convolutional"/></p>

<p>A simple ConvNet for <a href="https://www.cs.toronto.edu/%7Ekriz/cifar.html">CIFAR-10</a> classification could have the architecture as follows:</p>

<ul>
<li><strong>INPUT</strong> [width x height x color channel] will hold the raw pixel values of the image, in this case an image of width, height, and with three color channels R,G,B.</li>
<li><strong>CONV layer</strong> will compute the output of neurons that are connected to local regions in the input, each computing a dot product between their weights and a small region they are connected to in the input volume.</li>
<li><strong>RELU layer</strong> will apply an elementwise activation function, such as the <code>max(0,x)</code> thresholding at zero. </li>
<li><strong>POOL layer</strong> will perform a downsampling operation along the spatial dimensions (width, height).</li>
<li><strong>FC</strong> (i.e. fully-connected) layer will compute the class scores, where each score corresponding to the 10 categories of CIFAR-10. As with ordinary Neural Networks and as the name implies, each neuron in this layer will be connected to all the numbers in the previous volume.</li>
</ul>

<h4 id="toc_1">Conv layers</h4>

<p>Four hyperparameters <strong>depth</strong>(K), <strong>spatial extent</strong>(\(F\)), <strong>stride</strong>(\(S\)) and <strong>zero-padding</strong>(\(P\)) control the size of the output volume from the input volume (\(W\)).</p>

<p><strong>Summary</strong>. To summarize, the Conv Layer:</p>

<ul>
<li>Accepts a volume of size \(W_1 \times H_1 \times D_1\)</li>
<li>Requires four hyperparameters: 

<ul>
<li>Number of filters \(K\), </li>
<li>their spatial extent \(F\), </li>
<li>the stride \(S\), </li>
<li>the amount of zero padding \(P\).</li>
</ul></li>
<li>Produces a volume of size \(W_2 \times H_2 \times D_2\) where:

<ul>
<li>\(W_2 = (W_1 - F + 2P)/S + 1\)</li>
<li>\(H_2 = (H_1 - F + 2P)/S + 1\) (i.e. width and height are computed equally by symmetry)</li>
<li>\(D_2 = K\)</li>
</ul></li>
<li>With parameter sharing, it introduces \(F \cdot F \cdot D_1\) weights per filter, for a total of \((F \cdot F \cdot D_1) \cdot K\) weights and \(K\) biases.</li>
<li>In the output volume, the \(d\)-th depth slice (of size \(W_2 \times H_2\)) is the result of performing a valid convolution of the \(d\)-th filter over the input volume with a stride of \(S\), and then offset by \(d\)-th bias.</li>
</ul>

<p><strong>parameter sharing</strong>: the neurons in each depth slice(i.e \(K\)) to use the same weights and bias. </p>

<h4 id="toc_2">Pooling</h4>

<p><code>max pooling</code> is the most common function performed on the pooling units, others like <code>average pooling</code> or <code>L2-norm pooling</code> is work worse in practice. And Many people dislike the pooling operation and think that we can get away without it.</p>

<h4 id="toc_3">Fully-connected layers</h4>

<p>Neurons in a fully connected layer have full connections to all activations in the previous layer.</p>

<h4 id="toc_4">Layer Patterns</h4>

<p>The most common form of a ConvNet architecture stacks a few CONV-RELU layers, follows them with POOL layers, and <strong>repeats this pattern until the image has been merged spatially to a small size</strong>. At some point, it is common to transition to fully-connected layers. The last fully-connected layer holds the output, such as the class scores. In other words, the most common ConvNet architecture follows the pattern:</p>

<p>\[INPUT \rightarrow  [[CONV \rightarrow  RELU]*N \rightarrow  POOL?]*M \rightarrow [FC -&gt; RELU]*K \rightarrow  FC\]</p>

<p>where the <code>*</code> indicates repetition, and the <code>POOL?</code> indicates an optional pooling layer. Moreover, <code>N &gt;= 0</code> (and usually <code>N &lt;= 3</code>), <code>M &gt;= 0</code>, <code>K &gt;= 0</code> (and usually <code>K &lt; 3</code>). For example, here are some common ConvNet architectures you may see that follow this pattern:</p>

<p><strong>Note</strong>: <code>INPUT -&gt; FC</code>, implements a linear classifier. Here <code>N = M = K = 0</code>.<br/>
<strong>Note</strong>: Prefer a stack of small filter CONV to one large receptive field CONV layer, because of few parameters needed and expressing more powerful features of the input.</p>

<h4 id="toc_5">Layer Sizing Patterns</h4>

<ul>
<li><strong>input layer</strong>:  Common numbers include 32 (e.g. CIFAR-10), 64, 96 (e.g. STL-10), or 224 (e.g. common ImageNet ConvNets), 384, and 512.</li>
<li><strong>conv layers</strong>: small filters(\(3\times3\) or \(5\times5\)), with \(S=1\). Crucially, <em>padding the input volume with zeros in such way that the conv layer does not alter the spatial dimensions of the input.</em> </li>
<li><strong>pool layers</strong>: use max-pooling with \(F=2, S=2\) or \(F=3, S=2\)</li>
</ul>

<h3 id="toc_6">Computational Considerations</h3>

<h1 id="toc_7">The memory bottleneck is the largest bottleneck when constructing ConvNet architectures.</h1>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Transfer Learning]]></title>
    <link href="http://larryim.cc/15042359761425.html"/>
    <updated>2017-09-01T11:19:36+08:00</updated>
    <id>http://larryim.cc/15042359761425.html</id>
    <content type="html"><![CDATA[
<p><code>Transfer learning</code> focuses on storing knowledge gained while solving one problem and applying it to a different but related problem.</p>

<p>Generally, transfer learning will work only well if the inputs have similar low-level features.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cross-entropy]]></title>
    <link href="http://larryim.cc/15041905263785.html"/>
    <updated>2017-08-31T22:42:06+08:00</updated>
    <id>http://larryim.cc/15041905263785.html</id>
    <content type="html"><![CDATA[
<p>\[<br/>
L_i = -\log\left(\frac{e^{f_{y_i}}}{ \sum_j e^{f_j} }\right) \hspace{0.5in} \text{or equivalently} \hspace{0.5in} L_i = -f_{y_i} + \log\sum_j e^{f_j}<br/>
\]</p>

<p>where we are using the notation \(f_j\) to mean the j-th element of the vector of class scores \(f\). As before, the full loss for the dataset is the mean of \(L_i\) over all training examples together with a regularization term \(R(W)\). The function \(f_j(z) = \frac{e^{z_j}}{\sum_k e^{z_k}} \) is called the <strong>softmax function</strong>: It takes a vector of arbitrary real-valued scores (in \(z\)) and squashes it to a vector of values between zero and one that sum to one. The full cross-entropy loss that involves the softmax function might look scary if you&#39;re seeing it for the first time but it is relatively easy to motivate.</p>

<p><strong>Information theory view</strong>. The <em>cross-entropy</em> between a &quot;true&quot; distribution \(p\) and an estimated distribution \(q\) is defined as:</p>

<p>\[<br/>
H(p,q) = - \sum_x p(x) \log q(x)<br/>
\]</p>

<p>The Softmax classifier is hence minimizing the cross-entropy between the estimated class probabilities ( \(q = e^{f_{y_i}}  / \sum_j e^{f_j} \) as seen above) and the &quot;true&quot; distribution, which in this interpretation is the distribution where all probability mass is on the correct class (i.e. \(p = [0, \ldots 1, \ldots, 0]\) contains a single 1 at the \(y_i\) -th position.). Moreover, since the cross-entropy can be written in terms of entropy and the Kullback-Leibler divergence as \(H(p,q) = H(p) + D_{KL}(p\|\|q)\), and the entropy of the delta function \(p\) is zero, this is also equivalent to minimizing the KL divergence between the two distributions (a measure of distance). In other words, the cross-entropy objective <em>wants</em> the predicted distribution to have all of its mass on the correct answer.</p>

<p><strong>Probabilistic interpretation</strong>. Looking at the expression, we see that</p>

<p>\[<br/>
P(y_i \mid x_i; W) = \frac{e^{f_{y_i}}}{\sum_j e^{f_j} }<br/>
\]</p>

<p>can be interpreted as the (normalized) probability assigned to the correct label \(y_i\) given the image \(x_i\) and parameterized by \(W\). To see this, remember that the Softmax classifier interprets the scores inside the output vector \(f\) as the unnormalized log probabilities. Exponentiating these quantities therefore gives the (unnormalized) probabilities, and the division performs the normalization so that the probabilities sum to one. In the probabilistic interpretation, we are therefore minimizing the negative log likelihood of the correct class, which can be interpreted as performing <em>Maximum Likelihood Estimation</em> (MLE). A nice feature of this view is that we can now also interpret the regularization term \(R(W)\) in the full loss function as coming from a Gaussian prior over the weight matrix \(W\), where instead of MLE we are performing the <em>Maximum a posteriori</em> (MAP) estimation. We mention these interpretations to help your intuitions, but the full details of this derivation are beyond the scope of this class.</p>

<p><strong>Practical issues: Numeric stability</strong>. When you&#39;re writing code for computing the Softmax function in practice, the intermediate terms \(e^{f_{y_i}}\) and \(\sum_j e^{f_j}\) may be very large due to the exponentials. Dividing large numbers can be numerically unstable, so it is important to use a normalization trick. Notice that if we multiply the top and bottom of the fraction by a constant \(C\) and push it into the sum, we get the following (mathematically equivalent) expression:</p>

<p>\[<br/>
\frac{e^{f_{y_i}}}{\sum_j e^{f_j}}<br/>
= \frac{Ce^{f_{y_i}}}{C\sum_j e^{f_j}}<br/>
= \frac{e^{f_{y_i} + \log C}}{\sum_j e^{f_j + \log C}}<br/>
\]</p>

<p>We are free to choose the value of \(C\). This will not change any of the results, but we can use this value to improve the numerical stability of the computation. A common choice for \(C\) is to set \(\log C = -\max_j f_j \). This simply states that we should shift the values inside the vector \(f\) so that the highest value is zero. In code:</p>

<pre><code class="language-python">f = np.array([123, 456, 789]) # example with 3 classes and each having large scores
p = np.exp(f) / np.sum(np.exp(f)) # Bad: Numeric problem, potential blowup

# instead: first shift the values of f so that the highest number is 0:
f -= np.max(f) # f becomes [-666, -333, 0]
p = np.exp(f) / np.sum(np.exp(f)) # safe to do, gives the correct answer

</code></pre>

<p><strong>Possibly confusing naming conventions</strong>. To be precise, the <em>SVM classifier</em> uses the <em>hinge loss</em>, or also sometimes called the <em>max-margin loss</em>. The <em>Softmax classifier</em> uses the <em>cross-entropy loss</em>. The Softmax classifier gets its name from the <em>softmax function</em>, which is used to squash the raw class scores into normalized positive values that sum to one, so that the cross-entropy loss can be applied. In particular, note that technically it doesn&#39;t make sense to talk about the &quot;softmax loss&quot;, since softmax is just the squashing function, but it is a relatively commonly used shorthand.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cross-Validation]]></title>
    <link href="http://larryim.cc/cross-validation.html"/>
    <updated>2017-08-28T09:35:39+08:00</updated>
    <id>http://larryim.cc/cross-validation.html</id>
    <content type="html"><![CDATA[
<p><code>cross-validation</code> splits the training set into complementary subsets, and each model is trained against a different combination of these subsets and validates against the remaining parts. Once the model type and hyperparameters on the full training set, and the generalized error is measured on the test set.</p>

<p><img src="media/15038841395536/15042349862270.jpg" alt="demo of cross-validation"/></p>

<p>A great convenient is to use Scikit-Learn&#39;s <code>cross-validation</code> feature. The following code performs <code>K-fold cross-validation</code>: it randomly splits the training set into 10 distinct subsets called <code>folds</code>, then it trains and evaluates the Decision Tree model 10 times, picking a different fold for evaluation every time and training on the other 9 folds.</p>

<pre><code class="language-python">from sklearn.model_selection import cross_val_score
scores = cross_val_score(tree_reg, housing_prepared, housing_labels,
                             scoring=&quot;neg_mean_squared_error&quot;, cv=10)
    rmse_scores = np.sqrt(-scores)
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[K-means clustering]]></title>
    <link href="http://larryim.cc/15037532856914.html"/>
    <updated>2017-08-26T21:14:45+08:00</updated>
    <id>http://larryim.cc/15037532856914.html</id>
    <content type="html"><![CDATA[
<p>Optimization objective:<br/>
\[J(c^{(1)},...,c^{(m)},\mu_1,...,\mu_k)=\frac{1}{m}\sum^m_{i=1}\rVert x^{(i)}-\mu_{c^{(i)}}\rVert^2\]</p>

<p>Randomly initialize \(K\) cluster centroid \(\mu_1, \mu_2,...,\mu_k\)</p>

<p>Repeat{<br/>
    for \(i=1\) to \(m\)<br/>
    \( c^{(i)}=\) index (from 1 to \(K\) of cluster centroid closest to \(x^{(i)}\)</p>

<h3 id="toc_0">Random initialization</h3>

<p>Randomly pick \(K\) training examples, and set \(\mu_1, \mu_2,...,\mu_k\) equal to these \(K\) examples.</p>

<p>\[\text{For }i = 1 \text{  to  } 100 {\\<br/>
\text{    Randomly initialize K cluster centroid } \mu_1, \mu_2,...,\mu_k\\<br/>
\text{    Run K-means}\\<br/>
\text{    Compute cost function (distortion)}\\<br/>
}\\<br/>
\]</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Feature Engineering]]></title>
    <link href="http://larryim.cc/15036679491914.html"/>
    <updated>2017-08-25T21:32:29+08:00</updated>
    <id>http://larryim.cc/15036679491914.html</id>
    <content type="html"><![CDATA[
<p>As the saying goes: garbage in, garbage out. Your system will only be capable of learn‐ ing if the training data contains enough relevant features and not too many irrelevant ones. A critical part of the success of a Machine Learning project is coming up with a good set of features to train on. This process, called feature engineering, involves:</p>

<ul>
<li><code>Feature selection</code>: selecting the most useful features to train on among existing features.</li>
<li><code>Feature extraction</code>: combining existing features to produce a more useful one (as we saw earlier, dimensionality reduction algorithms can help).</li>
<li><code>Creating new features</code> by gathering new data.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Machine Learning(7): Support Vector Machines]]></title>
    <link href="http://larryim.cc/support-vector-machine.html"/>
    <updated>2017-08-25T19:52:02+08:00</updated>
    <id>http://larryim.cc/support-vector-machine.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Training Objective</h2>

<p>The smaller the weight vector <code>w</code>, the larger the margin. So we want to minimize \(\lVert w\rVert\) to get a large margin.</p>

<h3 id="toc_1">Hard Margin</h3>

<p>If we also want to avoid any margin violation (<code>hard margin</code>), then we need the decision function to be greater than 1 for all positive trainig instances, and lower than  -1 for negative training instances. If we define \(t^{(i)} = -1\) for negative instances (if \(y^{(i)}&gt;0\)) and \(t^{(i)}=1\) for positive instances (if \(y^{(i)}=1\)), then we can express this constraint as \(t^{(i)}(w^T\cdot x^{(i)}+b) \le 1\) for all instances. </p>

<p>** Hard Margin linear SVM classifier objective**</p>

<p>\[<br/>
\min_{w,b} \frac{1}{2}w^T\cdot w \\<br/>
\text{subject to } t^{(i)}(w^T\cdot x^{(i)}+b) \le 1  \quad for \quad i =1,2,...,m<br/>
\]</p>

<h3 id="toc_2">Soft Margin</h3>

<p>To get the soft margin objective, we need to introduce a <code>slack variable</code> \(\zeta^(i)\le0\) for each instance: \(\zeta^{(i)}\) measures how much the \(i^{th}\) instance is allowed to violate the margin. We now have two conflicting objectives: making the slack variables as small as possible to reduce the margin violations, and makeing \(\frac{1}{2}w^T\cdot w \) as small as possible to increase the margin.</p>

<p>** Soft Margin linear SVM classifier objective**</p>

<p>\[<br/>
\min_{w,b} \frac{1}{2}w^T\cdot w + C\sum^m_{i=1}\zeta^{(i)}\\<br/>
\text{subject to } t^{(i)}(w^T\cdot x^{(i)}+b) \le 1 - \zeta^{(i)} \quad for \quad i =1,2,...,m<br/>
\]</p>

<h2 id="toc_3">Implementation</h2>

<pre><code class="language-python">import numpy as np
from sklearn import datasets
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.svm import LinearSVC
from sklearn.svm import SVC
import matplotlib.pyplot as plt
</code></pre>

<h2 id="toc_4">Soft Margin Classification</h2>

<pre><code class="language-python">
# load data sets
iris = datasets.load_iris()
x = iris[&#39;data&#39;][:,(2,3)] # petal length, petal width
y = (iris[&#39;target&#39;] == 2).astype(np.float64) # Iris-Virginica
</code></pre>

<pre><code class="language-python">%matplotlib inline
plt.scatter(x[:,0], x[:,1], c=y)
</code></pre>

<pre><code>&lt;matplotlib.collections.PathCollection at 0x110ecf0f0&gt;
</code></pre>

<p><img src="media/15036619229303/output_4_1.png" alt="png"/></p>

<pre><code class="language-python"># plot decision boundary
def make_meshgrid(x, y, h=.02):
    &quot;&quot;&quot;Create a mesh of points to plot in

    Parameters
    ----------
    x: data to base x-axis meshgrid on
    y: data to base y-axis meshgrid on
    h: stepsize for meshgrid, optional

    Returns
    -------
    xx, yy : ndarray
    &quot;&quot;&quot;
    x_min, x_max = x.min() - 1, x.max() + 1
    y_min, y_max = y.min() - 1, y.max() + 1
    xx, yy = np.meshgrid(np.arange(x_min, x_max, h),
                         np.arange(y_min, y_max, h))
    return xx, yy

def plot_contours(model, xx, yy, **params):
    &quot;&quot;&quot;Plot the decision boundaries for a classifier.

    Parameters
    ----------
    ax: matplotlib axes object
    clf: a classifier
    xx: meshgrid ndarray
    yy: meshgrid ndarray
    params: dictionary of params to pass to contourf, optional
    &quot;&quot;&quot;
    Z = model.predict(np.c_[xx.ravel(), yy.ravel()])
    Z = Z.reshape(xx.shape)
    out = plt.contourf(xx, yy, Z, **params)
    return out
</code></pre>

<pre><code class="language-python"># svm
svm_clf = Pipeline([
    (&#39;scalar&#39;, StandardScaler()),
    (&#39;linear_svc&#39;, LinearSVC(C=1, loss=&#39;hinge&#39;))])
svm_clf.fit(x, y)
</code></pre>

<pre><code>Pipeline(steps=[(&#39;scalar&#39;, StandardScaler(copy=True, with_mean=True, with_std=True)), (&#39;linear_svc&#39;, LinearSVC(C=1, class_weight=None, dual=True, fit_intercept=True,
     intercept_scaling=1, loss=&#39;hinge&#39;, max_iter=1000, multi_class=&#39;ovr&#39;,
     penalty=&#39;l2&#39;, random_state=None, tol=0.0001, verbose=0))])
</code></pre>

<pre><code class="language-python">plot_contours(svm_clf, xx, yy,
              cmap=plt.cm.coolwarm, alpha=0.8)
plt.hold
plt.scatter(x[:,0], x[:,1], c=y)
</code></pre>

<pre><code>&lt;matplotlib.collections.PathCollection at 0x111e5c128&gt;
</code></pre>

<p><img src="media/15036619229303/output_7_1.png" alt="png"/></p>

<h2 id="toc_5">Nonelinear SVM Classification</h2>

<p>One approach to handling nonlinear datasets is to add more features, such as polynomial features. In some cases result in a linearly separable dataset.</p>

<pre><code class="language-python">from sklearn.preprocessing import PolynomialFeatures

polynomial_svm_clf = Pipeline([
    (&#39;poly_features&#39;, PolynomialFeatures(degree=3)),
    (&#39;scaler&#39;, StandardScaler()),
    (&#39;svm, clf&#39;, LinearSVC(C=10, loss=&#39;hinge&#39;))
])

polynomial_svm_clf.fit(x, y)
</code></pre>

<pre><code>Pipeline(steps=[(&#39;poly_features&#39;, PolynomialFeatures(degree=3, include_bias=True, interaction_only=False)), (&#39;scaler&#39;, StandardScaler(copy=True, with_mean=True, with_std=True)), (&#39;svm, clf&#39;, LinearSVC(C=10, class_weight=None, dual=True, fit_intercept=True,
     intercept_scaling=1, loss=&#39;hinge&#39;, max_iter=1000, multi_class=&#39;ovr&#39;,
     penalty=&#39;l2&#39;, random_state=None, tol=0.0001, verbose=0))])
</code></pre>

<pre><code class="language-python">xx, yy = make_meshgrid(x[:,0], x[:,1])
plot_contours(polynomial_svm_clf, xx, yy,
              cmap=plt.cm.coolwarm, alpha=0.8)
plt.hold
plt.scatter(x[:,0], x[:,1], c=y)
</code></pre>

<pre><code>&lt;matplotlib.collections.PathCollection at 0x112f0a470&gt;
</code></pre>

<p><img src="media/15036619229303/output_10_1.png" alt="png"/></p>

<h2 id="toc_6">Gaussian RBF Kernal</h2>

<p>Define the similarity function to be the Gaussian Radial Basis Function (RBF):</p>

<p>\[\phi(x, \gamma) = exp(-\gamma \lVert x-l\rVert ^2)\]</p>

<p>Let&#39;s try the Gaussian RBF kernel using the <code>SVC</code> class:</p>

<pre><code class="language-python">rbf_kernel_svm_clf = Pipeline([
    (&#39;svm_clf&#39;, SVC(kernel=&#39;rbf&#39;, gamma=0.1, C=0.1))
])
rbf_kernel_svm_clf.fit(x,y)
</code></pre>

<pre><code>Pipeline(steps=[(&#39;svm_clf&#39;, SVC(C=0.1, cache_size=200, class_weight=None, coef0=0.0,
  decision_function_shape=None, degree=3, gamma=0.1, kernel=&#39;rbf&#39;,
  max_iter=-1, probability=False, random_state=None, shrinking=True,
  tol=0.001, verbose=False))])
</code></pre>

<pre><code class="language-python">plot_contours(rbf_kernel_svm_clf, xx, yy,
              cmap=plt.cm.coolwarm, alpha=0.8)
plt.hold
plt.scatter(x[:,0], x[:,1], c=y)
</code></pre>

<pre><code>&lt;matplotlib.collections.PathCollection at 0x114174518&gt;
</code></pre>

<p><img src="media/15036619229303/output_13_1.png" alt="png"/></p>

<p>Other kernals such as <code>sigmoid</code>, <code>precomputed</code> are also used. With so many kernels to choose from, as a rule of thumb, you should always try the linear kernel first, especailly if the training set is very large or if it has plenty of features. If the training set is not too large, you should try the Gaussian RBF kernel as well; it works well in most cases.</p>

<h2 id="toc_7">Complexity</h2>

<p>Time complexity of algorithms above:</p>

<ul>
<li><code>LinearSVC</code>: \(O(m\times n)\)</li>
<li><code>SGDClassifier</code>: \(O(m\times n)\)</li>
<li><code>SVC</code>: \(O(m^2\times n) \text{ to } O(m^3\times n)\)</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TensorFlow(5): Vector and Matrix Product in Numpy and TensorFlow]]></title>
    <link href="http://larryim.cc/15035780907547.html"/>
    <updated>2017-08-24T20:34:50+08:00</updated>
    <id>http://larryim.cc/15035780907547.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Numpy</h2>

<p>Following are common vector and matrix product operations in Numpy, they are quite simple and straightforward:</p>

<ul>
<li><p>Inner Product   \(\quad a^Tb\quad \):  <code>np.inner()</code></p></li>
<li><p>Outer Product  \(\quad ab^T\quad \):  <code>np.outer()</code></p></li>
<li><p>Dot Product  \(\quad a \cdot b = \sum a_ib_i\quad \): <code>np.dot()</code></p></li>
<li><p>Elementwise Product  \(\quad c_i = a_ib_i\quad \): <code>np.multiply()</code></p></li>
</ul>

<p>Note: inner product is defined on vector spaces over a field 𝕂 (finite or infinite dimensional). Dot product refers specifically to the product of vectors in \(ℝ^n\)</p>

<p>The difference between the following implementations of the dot/inner/outer/elementwise product are demonstrated as follows:</p>

<pre><code class="language-python">W = np.ones((2, 7), dtype=&#39;float32&#39;)
x1 = [9, 2, 5, 0, 0, 7, 5]
x2 = [9, 2, 2, 9, 0, 9, 2]
print(&#39;vector dot product&#39;, np.dot(x1,x2)) # dot product
print(&#39;inner&#39;, np.inner(x1,x2)) # inner product
print(&#39;outter&#39;, np.outer(x1,x2)) # outter product
print(&#39;element-wsie&#39;, np.multiply(x1,x2)) # Element-wise product
print(&#39;matrix dot product&#39;, np.dot(W, x1)) # dot product
</code></pre>

<pre><code>dot for vector 168
inner 168
outter [[81 18 18 81  0 81 18]
 [18  4  4 18  0 18  4]
 [45 10 10 45  0 45 10]
 [ 0  0  0  0  0  0  0]
 [ 0  0  0  0  0  0  0]
 [63 14 14 63  0 63 14]
 [45 10 10 45  0 45 10]]
element-wsie [81  4 10  0  0 63 10]
dot for matrix [ 28.  28.]
</code></pre>

<h2 id="toc_1">TensorFlow</h2>

<p>Vector inner/outer Product are a bit complex in TensorFlow. </p>

<pre><code class="language-python">import tensorflow as tf
import numpy as np

x = tf.Variable([[1, -2, 3]], tf.float32, name=&#39;x&#39;)
y = tf.Variable([[-1, 2, -3]], tf.float32, name=&#39;y&#39;)

## inner product
inner_product1 = tf.reduce_sum(tf.multiply(x, y))
inner_product2 = tf.matmul(x, y, transpose_a=False, transpose_b= True) # different from inner_product1

## outer product
outer_product2 = tf.matmul(x, y, transpose_a= True)

## matrix dot product
X = tf.constant(np.random.randn(3,3), name=&#39;X&#39;)
W = tf.constant(np.random.randn(3,3), name=&#39;W&#39;)
matrix_product = tf.matmul(W, X)

sess = tf.InteractiveSession()
init_op = tf.global_variables_initializer()

# run
sess.run(init_op)
print(sess.run(inner_product1))
print(sess.run(inner_product2))
print(sess.run(outer_product2))
print(sess.run(matrix_product))
</code></pre>

<pre><code>-14
[[-14]]
[[-1  2 -3]
 [ 2 -4  6]
 [-3  6 -9]]
[[-0.88722509 -0.94128018 -2.1999658 ]
 [-0.67967623  1.33193446 -0.75612585]
 [ 0.31741623  1.3271727  -0.04311113]]
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python `set`, `tuple`]]></title>
    <link href="http://larryim.cc/15035712266178.html"/>
    <updated>2017-08-24T18:40:26+08:00</updated>
    <id>http://larryim.cc/15035712266178.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0"><code>set</code></h2>

<p>A <code>set</code> is an unordered collection with no duplicate elements. Basic uses include membership testing and eliminating duplicate entries. Set objects also support mathematical operations like <code>union</code>, intersection, difference, and symmetric difference.</p>

<p>Curly braces or the <code>set()</code> function can be used to create sets. Note: to create an empty set you have to use <code>set()</code>, not {}; the latter creates an empty dictionary, a data structure that we discuss in the next section.</p>

<pre><code class="language-python">&gt;&gt;&gt; basket = {&#39;apple&#39;, &#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;orange&#39;, &#39;banana&#39;}
&gt;&gt;&gt; print(basket)                      # show that duplicates have been removed
{&#39;orange&#39;, &#39;banana&#39;, &#39;pear&#39;, &#39;apple&#39;}
&gt;&gt;&gt; &#39;orange&#39; in basket                 # fast membership testing
True
&gt;&gt;&gt; &#39;crabgrass&#39; in basket
False

&gt;&gt;&gt; # Demonstrate set operations on unique letters from two words
...
&gt;&gt;&gt; a = set(&#39;abracadabra&#39;)
&gt;&gt;&gt; b = set(&#39;alacazam&#39;)
&gt;&gt;&gt; a                                  # unique letters in a
{&#39;a&#39;, &#39;r&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;}
&gt;&gt;&gt; a - b                              # letters in a but not in b
{&#39;r&#39;, &#39;d&#39;, &#39;b&#39;}
&gt;&gt;&gt; a | b                              # letters in either a or b
{&#39;a&#39;, &#39;c&#39;, &#39;r&#39;, &#39;d&#39;, &#39;b&#39;, &#39;m&#39;, &#39;z&#39;, &#39;l&#39;}
&gt;&gt;&gt; a &amp; b                              # letters in both a and b
{&#39;a&#39;, &#39;c&#39;}
&gt;&gt;&gt; a ^ b                              # letters in a or b but not both
{&#39;r&#39;, &#39;d&#39;, &#39;b&#39;, &#39;m&#39;, &#39;z&#39;, &#39;l&#39;}
</code></pre>

<h2 id="toc_1"><code>tuple</code></h2>

<p>A <code>tuple</code> is an (<code>immutable</code>) ordered list of values. A <code>tuple</code> is in many ways similar to a list; one of the most important differences is that <code>tuple</code> can be used as keys in dictionaries and as elements of sets, while <code>list</code> cannot. Here is a trivial example:</p>

<pre><code class="language-python">d = {(x, x + 1): x for x in range(10)}  # Create a dictionary with tuple keys
t = (5, 6)        # Create a tuple
print(type(t))    # Prints &quot;&lt;class &#39;tuple&#39;&gt;&quot;
print(d[t])       # Prints &quot;5&quot;
print(d[(1, 2)])  # Prints &quot;1&quot;
</code></pre>

<p>A special problem is the construction of tuples containing 0 or 1 items: the syntax has some extra quirks to accommodate these. Empty tuples are constructed by an empty pair of parentheses; a tuple with one item is constructed by following a value with a comma (it is not sufficient to enclose a single value in parentheses). Ugly, but effective. For example:</p>

<pre><code class="language-python">&gt;&gt;&gt; empty = ()
&gt;&gt;&gt; singleton = &#39;hello&#39;,    # &lt;-- note trailing comma
&gt;&gt;&gt; len(empty)
0
&gt;&gt;&gt; len(singleton)
1
&gt;&gt;&gt; singleton
(&#39;hello&#39;,)
</code></pre>

<p>The tuple syntax is simple, if you separate some values with commas, you automatically have a tuple(called <code>tuple packing</code>),</p>

<pre><code>&gt;&gt;&gt; 1,2,3
(1, 2, 3)
</code></pre>

<h3 id="toc_2"><code>tuple</code> function</h3>

<p>The <code>tuple</code> function works in pretty much the same way as <code>list</code>: it takes one sequence argument and converts it to a <code>tuple</code>.</p>

<pre><code>&gt;&gt;&gt; tuple([1,2,3])
(1, 2, 3)
</code></pre>

<h3 id="toc_3">Performance</h3>

<p>Instantiation is almost an order of magnitude faster for the tuple, but item access is actually somewhat faster for the list! So if you&#39;re creating a few tuples and accessing them many many times, it may actually be faster to use lists instead.</p>

<pre><code class="language-python">$ python -m timeit &quot;x=(1,2,3,4,5,6,7,8)&quot;
10000000 loops, best of 3: 0.0388 usec per loop

$ python -m timeit &quot;x=[1,2,3,4,5,6,7,8]&quot;
1000000 loops, best of 3: 0.363 usec per loop

$ python -m timeit -s &quot;x=(1,2,3,4,5,6,7,8)&quot; &quot;y=x[3]&quot;
10000000 loops, best of 3: 0.0938 usec per loop

$ python -m timeit -s &quot;x=[1,2,3,4,5,6,7,8]&quot; &quot;y=x[3]&quot;
10000000 loops, best of 3: 0.0649 usec per loop
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TensorFlow(4):TensorFlow Operation]]></title>
    <link href="http://larryim.cc/tensorflow_operation.html"/>
    <updated>2017-08-22T14:33:29+08:00</updated>
    <id>http://larryim.cc/tensorflow_operation.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">1 Visualize with TensorBoard</a>
<ul>
<li>
<a href="#toc_1">Explicitly name operation, variable</a>
</li>
</ul>
</li>
<li>
<a href="#toc_2">2 Constant types</a>
<ul>
<li>
<a href="#toc_3">Tensors filled with a specific value</a>
</li>
<li>
<a href="#toc_4">Constants as sequences</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">3 Math Operations</a>
</li>
<li>
<a href="#toc_6">4 TensorFlow data types:</a>
<ul>
<li>
<a href="#toc_7">Python Native Types</a>
</li>
<li>
<a href="#toc_8">TensorFlow Native Types</a>
</li>
<li>
<a href="#toc_9">Numpy Data Types</a>
</li>
<li>
<a href="#toc_10">Constant</a>
</li>
<li>
<a href="#toc_11">Variables</a>
<ul>
<li>
<a href="#toc_12">Each session maintains its own copy of variable</a>
</li>
<li>
<a href="#toc_13">Use a variable to initialize another variables</a>
</li>
<li>
<a href="#toc_14">Session vs InteractiveSession,</a>
</li>
</ul>
</li>
<li>
<a href="#toc_15">Placeholder</a>
</li>
<li>
<a href="#toc_16">Lazy loading</a>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">1 Visualize with TensorBoard</h2>

<pre><code class="language-python">import tensorflow as tf
a = tf.constant(2, name=&#39;a&#39;)
b = tf.constant(3, name=&#39;b&#39;)
x = tf.add(a, b, name=&#39;add&#39;)
with tf.Session() as sess:
    writer = tf.summary.FileWriter(&#39;./graphs&#39;, sess.graph)
    print(sess.run(x))media/15033836099887
writer.close() # close the writer when you&#39;re done using it.
</code></pre>

<pre><code>5
</code></pre>

<p>Bash command (to view TensorBoard):</p>

<pre><code class="language-bash"> tensorboard --logdir=&#39;./graphs&#39; --port 6006
 # open http://localhost:6006/#graphs in your browser
</code></pre>

<h3 id="toc_1">Explicitly name operation, variable</h3>

<pre><code class="language-python">a = tf.constant(2, name=&#39;a&#39;)
b = tf.constant(3, name=&#39;b&#39;)
x = tf.add(a,b,name=&#39;add&#39;)
with tf.Session() as sess:
    writer = tf.summary.FileWriter(&#39;./graphs&#39;, sess.graph)
    print(sess.run(x))
writer.close() # close the writer when you&#39;re done using it.
</code></pre>

<pre><code>5
</code></pre>

<p>The figure produced by TensorBoard is as follows:</p>

<p><img src="media/15033836099887/explicit_name.png" alt=""/></p>

<p><strong>Note</strong>:  Learn to use TensorBoard well and often. It will help a lot when you build complicated models.</p>

<h2 id="toc_2">2 Constant types</h2>

<h3 id="toc_3">Tensors filled with a specific value</h3>

<p>Using <code>tensorflow.zeros</code> to fill tensor with zeros, which is similar to <code>Numpy</code>:</p>

<pre><code class="language-python">tf.zeros(shape, dtype=tf.float32, name=None)
</code></pre>

<p>For example,</p>

<pre><code class="language-python">x = tf.zeros([2,3], tf.int32)
with tf.Session() as sess:
    print(sess.run(x))
</code></pre>

<pre><code>[[0 0 0]
 [0 0 0]]
</code></pre>

<p><code>tensorflow.zeros_like</code> return an tensor of zeros with the same shape and type as a given tensor. For example, we may want to have a tensor filled with zeros, with the same shape as <code>x</code>:</p>

<pre><code class="language-python">y = tf.zeros_like(x)
with tf.Session() as sess:
    print(sess.run(y))
</code></pre>

<pre><code>[[0 0 0]
 [0 0 0]]
</code></pre>

<p>There are other command to fill tensor with a specific value, such as <code>tensorflow.ones</code>, <code>tensorflow.ones_like</code>, which of usage is similar to <code>tensorflow.zeros</code>, <code>tensorflow.zeros_like</code>.</p>

<p><code>tensorflow.fill</code> creates a tensor filled with a scalar value:</p>

<pre><code class="language-python">tf.fill(dims, value, name=None)
</code></pre>

<pre><code class="language-python">z = tf.fill([3,4],3)
with tf.Session() as sess:
    print(sess.run(z))
</code></pre>

<pre><code>[[3 3 3 3]
 [3 3 3 3]
 [3 3 3 3]]
</code></pre>

<h3 id="toc_4">Constants as sequences</h3>

<p>You can create constants that are sequences, using <code>tf.linspace</code>, <code>tf.range</code>:</p>

<pre><code class="language-python">tf.linspace(start, stop, num, name=None)

# create a sequence of num evenly-spaced values are generated beginning at  start. If num &gt; 1, the values in the sequence increase by stop - start / num - 1, so that the last one is exactly stop.
# start, stop, num must be scalars
# comparable to but slightly different from numpy.linspace
# numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)

tf.range(start, limit=None, delta=1, dtype=None, name=&#39;range&#39;)
# create a sequence of numbers that begins at start and extends by increments of delta up to but not including limit
# slight different from range in Python
</code></pre>

<pre><code class="language-python">x = tf.linspace(10.0, 13.0, 4, name=&#39;linspace&#39;)
y = tf.range(3, 18)
z= tf.range(3, 18, 3)
with tf.Session() as sess:
    print(sess.run(x))
    print(sess.run(y))
    print(sess.run(z))
</code></pre>

<pre><code>[ 10.  11.  12.  13.]
[ 3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
[ 3  6  9 12 15]
</code></pre>

<h2 id="toc_5">3 Math Operations</h2>

<p><img src="media/15033836099887/math_operations.png" alt=""/></p>

<pre><code class="language-python">a = tf.constant([[3,6],[0,0]])
b = tf.constant([[0,0],[2,2]])
x1 = tf.add(a, b)
x2 = tf.add_n([a,b,b]) # &gt;&gt; [7 10]. Equivalent to a + b + b
x3 = tf.multiply(a, b) # &gt;&gt; [6 12] because mul is element wise
x4 = tf.matmul(a, b) # &gt;&gt; ValueError
x5 = tf.matmul(tf.reshape(a, [4, 1]), tf.reshape(b, [1, 4])) # &gt;&gt; [[18]]

with tf.Session() as sess:
    sess.run(a)
    sess.run(b)
    print(&#39;x1:\n&#39;, sess.run(x1))
    print(&#39;x2:\n&#39;, sess.run(x2))
    print(&#39;x3:\n&#39;, sess.run(x3))
    print(&#39;x4:\n&#39;, sess.run(x4))
    print(&#39;x5:\n&#39;, sess.run(x5))
</code></pre>

<pre><code>x1:
 [[3 6]
 [2 2]]
x2:
 [[3 6]
 [4 4]]
x3:
 [[0 0]
 [0 0]]
x4:
 [[12 12]
 [ 0  0]]
x5:
 [[ 0  0  6  6]
 [ 0  0 12 12]
 [ 0  0  0  0]
 [ 0  0  0  0]]
</code></pre>

<h2 id="toc_6">4 TensorFlow data types:</h2>

<h3 id="toc_7">Python Native Types</h3>

<p>TensorFlow takes Python natives types: <code>boolean</code>, <code>numeric</code> (<code>int</code>, <code>float</code>), <code>strings</code></p>

<p>TensorFlow takes in Python native types such as Python boolean values, numeric values (integers, floats), and strings. Single values will be converted to 0-d tensors (or scalars), lists of values will be converted to 1-d tensors (vectors), lists of lists of values will be converted to 2-d tensors (matrices), and so on.</p>

<pre><code class="language-python">tf.InteractiveSession() # open tensorflow interactivesession
t_0 = 19   # Treated as a 0-d tensor, or &quot;scalar&quot; 
print(&#39;t_0:&#39;,t_0)
print(tf.zeros_like(t_0))   # ==&gt; 0
print(tf.ones_like(t_0))   # ==&gt; 1
t_1 = [b&quot;apple&quot; ,  b&quot;peach&quot; ,  b&quot;grape&quot;]   # treated as a 1-d tensor, or &quot;vector&quot; 
print(&#39;t_1:&#39;,t_1)
print(tf.zeros_like(t_1))   # ==&gt; [&#39;&#39; &#39;&#39; &#39;&#39;]
t_2= [[ True, False, False],  [False, False, True], [False, True ,   False ]]   # treated as a 2-d tensor, or &quot;matrix&quot;
print(&#39;t_2:&#39;,t_2)
print(tf.zeros_like(t_2))   # ==&gt; 2x2 tensor, all elements are False 
print(tf.ones_like(t_2))   # ==&gt; 2x2 tensor, all elements are True
</code></pre>

<pre><code>t_0: 19
Tensor(&quot;zeros_like_32:0&quot;, shape=(), dtype=int32)
Tensor(&quot;ones_like_20:0&quot;, shape=(), dtype=int32)
t_1: [b&#39;apple&#39;, b&#39;peach&#39;, b&#39;grape&#39;]
Tensor(&quot;zeros_like_33:0&quot;, shape=(3,), dtype=string)
t_2: [[True, False, False], [False, False, True], [False, True, False]]
Tensor(&quot;zeros_like_34:0&quot;, shape=(3, 3), dtype=bool)
Tensor(&quot;ones_like_21:0&quot;, shape=(3, 3), dtype=bool)
</code></pre>

<p><strong>Note: Do not use Python native types for tensors because TensorFlow has to infer Python type.</strong></p>

<h3 id="toc_8">TensorFlow Native Types</h3>

<p>Like <code>NumPy</code>, <code>TensorFlow</code> also its own data types such as <code>tf.int32</code>, <code>tf.float32</code>. Below is a list of current TensorFlow data types.</p>

<p><img src="media/15033836099887/tensorflow_data_types.png" alt=""/></p>

<h3 id="toc_9">Numpy Data Types</h3>

<p>By now, you’ve probably noticed the similarity between <code>NumPy</code> and <code>TensorFlow</code>. <code>TensorFlow</code> was designed to integrate seamlessly with <code>Numpy</code>, the package that has become the  lingua franca of data science.</p>

<p>TensorFlow’s data types are based on those of NumPy; in fact, <code>np.int32 == tf.int32</code> returns <code>True</code>. You can pass <code>NumPy</code> types to <code>TensorFlow</code> ops.</p>

<p>Example:</p>

<pre><code class="language-python">import numpy as np
tf.ones([2, 2],  np.float32)
</code></pre>

<pre><code>&lt;tf.Tensor &#39;ones:0&#39; shape=(2, 2) dtype=float32&gt;
</code></pre>

<pre><code class="language-python">x = np.zeros((2,2))
tf.ones_like(x)
</code></pre>

<pre><code>&lt;tf.Tensor &#39;ones_like_22:0&#39; shape=(2, 2) dtype=float64&gt;
</code></pre>

<h3 id="toc_10">Constant</h3>

<p>Constants are stored in the graph definition. This makes loading graphs expensive when constants are big. <strong>Only use constants for primitive types, use variables or readers for more data that requires more memory</strong>.</p>

<pre><code class="language-python">g = tf.Graph() # to add operators to a graph, set it as default:
with g.as_default():
    my_const = tf.constant([1.0, 2.0], name=&quot;my_const&quot;)
    with tf.Session() as sess:
        print(sess.graph.as_graph_def())
</code></pre>

<pre><code>node {
  name: &quot;my_const&quot;
  op: &quot;Const&quot;
  attr {
    key: &quot;dtype&quot;
    value {
      type: DT_FLOAT
    }
  }
  attr {
    key: &quot;value&quot;
    value {
      tensor {
        dtype: DT_FLOAT
        tensor_shape {
          dim {
            size: 2
          }
        }
        tensor_content: &quot;\000\000\200?\000\000\000@&quot;
      }
    }
  }
}
versions {
  producer: 24
}
</code></pre>

<h3 id="toc_11">Variables</h3>

<p><code>tf.constant</code> is an operation, but <code>tf.Variable</code> is a class. <code>tf.Variables</code> holds several operations:</p>

<pre><code class="language-python">tf.InteractiveSession()
xx = tf.Variable(23, name=&#39;scalar&#39;)
xx.initializer # init op
xx.value() # read op
assign_op = xx.assign(5)

</code></pre>

<p>You have to initialize <code>variables</code>, The easiest way is initializing all variables at once:</p>

<pre><code class="language-python">init = tf.global_variables_initializer()
with tf.Session() as sess:
    sess.run(init)
    print(xx.eval())
    sess.run(assign_op)
    print(xx.eval())
</code></pre>

<pre><code>23
5
</code></pre>

<h4 id="toc_12">Each session maintains its own copy of variable</h4>

<pre><code class="language-python">W = tf.Variable(10, name=&#39;W&#39;)
sess1 = tf.Session()
sess2 = tf.Session()
sess1.run(W.initializer)
sess2.run(W.initializer)
print(sess1.run(W.assign_add(10)))
print(sess2.run(W.assign_sub(2))) # not 18!

sess1.close()
sess2.close()
</code></pre>

<pre><code>20
8
</code></pre>

<h4 id="toc_13">Use a variable to initialize another variables</h4>

<pre><code class="language-python"># want to declare U = 2*W
# W is random tensor
W = tf.Variable(tf.truncated_normal([4, 2]))
U = tf.Variable(2*W.initialized_value())
with tf.Session() as sess:
    sess.run(U.initializer)
    print(U.eval())
</code></pre>

<pre><code>[[ 1.11442947 -3.1675539 ]
 [ 3.02267933 -0.81786388]
 [ 2.57613969 -0.98440802]
 [ 0.6298722  -0.38194153]]
</code></pre>

<h4 id="toc_14">Session vs InteractiveSession,</h4>

<p>You sometimes see InteractiveSession instead of Session. The only difference is an InteractiveSession makes itself the default.</p>

<pre><code class="language-python">sess = tf.InteractiveSession()
a = tf.constant(5.0)
b = tf.constant(6.0)
c = a*b
# We can just use `c.eval()` with out specifying the context `sess`
print(c.eval())
sess.close()
</code></pre>

<pre><code>30.0
</code></pre>

<h3 id="toc_15">Placeholder</h3>

<p>A TensorFlow program often has 2 phases:</p>

<ol>
<li>Assemble a graph</li>
<li>Use a session to execute operations in the graph</li>
</ol>

<p>\(\rightarrow\) can assemble the graph without knowing the values needed for computation</p>

<p><strong>Analogy</strong>: Can define the function \(f(x,y) = x*2+y\) without knowing value of \(x\) or \(y\).</p>

<p>So using <code>placeholders</code>, we can later supply their data when they needed to execute the computation.</p>

<pre><code>tf.placeholder(dtype, shape=None, name=None)
</code></pre>

<p><code>shape=None</code> means that tensor of nay shape will be accepted as value for placeholder. Note: <strong><code>shape=None</code> is easy to construct graphs, but nightmarish for debugging</strong>.</p>

<p>To make <code>shape</code>  flexible, <code>None</code> can be used in the <code>shape</code> argument:</p>

<pre><code>    X = tf.placeholder(dtype=tf.float32, shape=[n_x, None], name=&#39;X&#39;)
</code></pre>

<h3 id="toc_16">Lazy loading</h3>

<p><code>Lazy loading</code> means defer creating/initializing an object until it is needed. In the context of TensorFlow, it means you defer creating an op until you need to compute it. </p>

<p>Normal loading:</p>

<pre><code class="language-python">g = tf.Graph()
with g.as_default():
    x = tf.Variable(10, name=&#39;x&#39;)
    y = tf.Variable(20, name=&#39;y&#39;)
    z = tf.add(x,y) # you create the node for add node before executing the graph

    with tf.Session() as sess:
        sess.run(tf.global_variables_initializer())
        for _ in range(10):
            sess.run(z)

</code></pre>

<p>Lazy loading:</p>

<pre><code class="language-python">g = tf.Graph()
with g.as_default():
    x = tf.Variable(10, name=&#39;x&#39;)
    y = tf.Variable(20, name=&#39;y&#39;)

    with tf.Session() as sess:
        sess.run(tf.global_variables_initializer())
        writer = tf.summary.FileWriter(&#39;./my_graph/12&#39;, sess.graph)
        for _ in range(10):
            sess.run(tf.add(x,y)) # someone decides to be clever to save one line of code
        writer.close()
</code></pre>

<p>Note: In Lazy loading, Node <code>ADD</code> added 10 times to the graph definition. Image you want to compute an operations thousands of times, you graph gets bloated slow to load, and expensive to pass around.</p>

<p><strong>Solution</strong>: </p>

<ol>
<li>Separate definition of ops from computing/running ops</li>
<li>Use Python property to ensure function is also loaded once the first time it is called.</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TensorFlow(2): Getting started with TensorFlow]]></title>
    <link href="http://larryim.cc/getting_started_with_tensorflow.html"/>
    <updated>2017-08-22T11:53:38+08:00</updated>
    <id>http://larryim.cc/getting_started_with_tensorflow.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">TensorFlow Core tutorial</a>
<ul>
<li>
<a href="#toc_1">importing TensorFlow</a>
</li>
<li>
<a href="#toc_2">The Computational Graph</a>
</li>
</ul>
</li>
<li>
<a href="#toc_3">tf.train API</a>
<ul>
<li>
<a href="#toc_4">Complete program</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">tf.estimator</a>
<ul>
<li>
<a href="#toc_6">Basic usage</a>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">TensorFlow Core tutorial</h2>

<h3 id="toc_1">importing TensorFlow</h3>

<pre><code class="language-python">import tensorflow as tf
</code></pre>

<h3 id="toc_2">The Computational Graph</h3>

<p>A <code>computational graph</code> is a series of TensorFlow operations arranged into a graph of nodes. Let&#39;s build a simple computational graph. Each node takes zero or more tensors as inputs and produces a tensor as an output. One type of node is a constant. Like all TensorFlow constant, it takes no inputs, and it outputs a value it stores internally. We can create two floating point Tensor <code>node1</code> and <code>node2</code> as follows:</p>

<pre><code class="language-python">node1 = tf.constant(3.0, dtype=tf.float32)
node2 = tf.constant(4.0) # also tf.float32 implicitly
print(node1, node2)
</code></pre>

<pre><code>Tensor(&quot;Const:0&quot;, shape=(), dtype=float32)
Tensor(&quot;Const_1:0&quot;, shape=(), dtype=float32)
</code></pre>

<p>To produce output values for <code>node1</code> and <code>nodes2</code>, evaluation is needed. To actually evaluate the nodes, we must run the computational graph within a <code>session</code>. A session encapsulates the control and state of the Tensorflow runtime.</p>

<p>The following code creates a <code>Session</code> object and then invokes its <code>run</code> method to run enough of the computational graph to evaluate <code>node1</code> and <code>node2</code>. By running the computational graph in a session as follows:</p>

<pre><code class="language-python">sess = tf.Session()
print(sess.run([node1, node2]))
</code></pre>

<pre><code>[3.0, 4.0]
</code></pre>

<p>We can build more complicated computations by combining <code>Tensor</code> nodes with operations(Operations are also nodes). For example, we can add our two constant nodes and produce a new graph as follows:</p>

<pre><code class="language-python">node3 = tf.add(node1, node2)
print(&#39;node3:&#39;, node3)
print(&#39;sess.run(node3):&#39;, sess.run(node3))
</code></pre>

<pre><code>node3: Tensor(&quot;Add:0&quot;, shape=(), dtype=float32)
sess.run(node3): 7.0
</code></pre>

<p>TensorFlow provides a utility called <code>TensorBoard</code> that can display a picture of the computational graph. Here is a screenshot showing how <code>TensorBoard</code> visualizes the graph:<br/>
<img src="media/15033740189206/getting_started_add.png" alt=""/></p>

<p>As it stands, this graph is not especially interesting because it always produces a constant result. A graph can be parameterized to accept external inputs, known as <code>placeholders</code>. A <code>placeholder</code> is a promise to provide a value later.</p>

<pre><code class="language-python">a = tf.placeholder(tf.float32)
b = tf.placeholder(tf.float32)
adder_node = a + b # + provides a shortcut for tf.add(a,b)
</code></pre>

<p>The preceding three lines are a bit like a function or a lambda in which we define two input parameters (a and b) and then an operation on them. We can evaluate this graph with multiple inputs by using the feed_dict argument to the <code>run method</code> to feed concrete values to the placeholder:</p>

<pre><code class="language-python">print(sess.run(adder_node, {a:3, b:4.5}))
print(sess.run(adder_node, {a:[1,3], b:[2,4]}))
</code></pre>

<pre><code>7.5
[ 3.  7.]
</code></pre>

<p>In <code>TensorBoard</code>, the graph looks like this:</p>

<p><img src="media/15033740189206/getting_started_adder.png" alt=""/></p>

<p>We can make the computational graph more complex by adding another operation. For example,</p>

<pre><code class="language-python">add_and_triple = adder_node * 3.
print(sess.run(add_and_triple,{a:3, b:4.5}))
</code></pre>

<pre><code>22.5
</code></pre>

<p>The preceding computational graph would look as follows in <code>TensorBoard</code>:<br/>
<img src="media/15033740189206/getting_started_triple.png" alt=""/></p>

<p>In machine learning we will typically want a model that can take arbitrary inputs, such as the one above. To make the model trainable, we need to be able to modify the graph to get new outputs with the same input. <code>variables</code> allow us to add trainable parameters to a graph. They are constructed with a type and initial value:</p>

<pre><code class="language-python">W = tf.Variable([.3], dtype=tf.float32)
b = tf.Variable([-.3], dtype=tf.float32)
x = tf.placeholder(tf.float32)
linear_model = W*x +b 
</code></pre>

<p>Constants are initialized when you call <code>tf.constant</code>, and their value can never change. By contrast, variables are not initialized when you call <code>tf.Variable</code>. To initialize all the variables in a TensorFlow program, you must explicitly call a special operation as follows:</p>

<pre><code class="language-python">init = tf.global_variables_initializer()
sess.run(init)
</code></pre>

<p>It is important to realize <code>init</code> is a handle to the TensorFlow sub-graph that initializes all the global variables. Until we call <code>sess.run</code>, the variables are uninitialized.</p>

<p>Since <code>x</code> is a placeholder, we can evaluate <code>linear_model</code> for several values of <code>x</code> simultaneously as follows:</p>

<pre><code class="language-python">print(sess.run(linear_model,{x:[1,2,3,4]}))
</code></pre>

<pre><code>[ 0.          0.30000001  0.60000002  0.90000004]
</code></pre>

<p>We&#39;ve create a model, but we don&#39;t know how good it is yet. To evaluate the model on training data, we need a <code>y</code> placeholder to provide the desired values, and we need to write a loss function.</p>

<p>A <code>loss function</code> measures how far apart the current model is from the provided data. We&#39;ll use a standard loss model for linear regression, which sums the squares of the deltas between the current model and the provided data. <code>linear_model -y</code> creates a vector where each element is the corresponding example&#39;s error delta. We call <code>tf.square</code> to square that error. Then, we sum all the squared errors to create a single scalar that abstacts the error of all examples using <code>tf.reduce_sum</code>:</p>

<pre><code class="language-python">y = tf.placeholder(tf.float32)
squared_deltas = tf.square(linear_model - y)
loss = tf.reduce_sum(squared_deltas)
print(sess.run(loss, {x:[1,2,3,4], y:[0,-1,-2,-3]}))
</code></pre>

<pre><code>23.66
</code></pre>

<p>We could improve this manually by reassigning the values of <code>W</code> and <code>b</code> to the perfect values of -1 and 1. A variable is initialized to the value provided to <code>tf.Variable</code> but can be changed using operations like <code>tf.assign</code>. FOr example, <code>W=-1</code> and <code>b=1</code> are the optimal parameters for our model. We can change <code>W</code> and <code>b</code> accordingly:</p>

<pre><code class="language-python">fixW = tf.assign(W, [-1.])
fixb = tf.assign(b, [1.])
sess.run([fixW, fixb])
print(sess.run(loss, {x:[1,2,3,4], y:[0,-1,-2,-3]}))
</code></pre>

<pre><code>0.0
</code></pre>

<p>We guessed the &quot;perfect&quot; values of <code>W</code> and <code>b</code>, but the whole point of machine learning is to find the correct model parameters automatically. We will show how to accomplish this in the next section.</p>

<h2 id="toc_3">tf.train API</h2>

<p>A complete discussion of machine learning is out of the scope of this tutorial. However, TensorFlow provides <code>optimizers</code> that slowly change each variable in order to minimize the loss function. The simplest optimizer is <code>gradient descent</code>. It modifies each variable according to the magnitude of the derivative of loss with respect to that variable. In general, computing symbolic derivatives manually is tedious and error-prone. Consequently, <code>TensorFlow</code> can automatically produce derivatives given only a description of the model using the function <code>tf.gradients</code>. For simplicity, <code>optimizers</code> typically do this for you. For example,</p>

<pre><code class="language-python">optimizer = tf.train.GradientDescentOptimizer(0.01)
train = optimizer.minimize(loss)

sess.run(init) # reset values to incorrect defaults
for i in range(1000):
    sess.run(train, {x:[1,2,3,4], y:[0,-1,-2,-3]})
print(sess.run([W,b]))
</code></pre>

<pre><code>[array([-0.9999969], dtype=float32), array([ 0.99999082], dtype=float32)]
</code></pre>

<p>Now we have done actual machine learning! Although doing this simple linear regression doesn&#39;t require much TensorFlow core code, more complicated models and methods to feed data into your model necessitate more code. Thus TensorFlow provides higher level abstractions for common patterns, structures, and functionality. We will learn how to use some of these abstractions in the next section.</p>

<h3 id="toc_4">Complete program</h3>

<pre><code class="language-python">import tensorflow as tf

# Model parameters
W = tf.Variable([.3], dtype=tf.float32)
b = tf.Variable([-.3], dtype=tf.float32)
# Model input and output
x = tf.placeholder(tf.float32)
linear_model = W * x + b
y = tf.placeholder(tf.float32)

# loss
loss = tf.reduce_sum(tf.square(linear_model - y)) # sum of the squares
# optimizer
optimizer = tf.train.GradientDescentOptimizer(0.01)
train = optimizer.minimize(loss)

# training data
x_train = [1, 2, 3, 4]
y_train = [0, -1, -2, -3]
# training loop
init = tf.global_variables_initializer()
sess = tf.Session()
sess.run(init) # reset values to wrong
for i in range(1000):
  sess.run(train, {x: x_train, y: y_train})

# evaluate training accuracy
curr_W, curr_b, curr_loss = sess.run([W, b, loss], {x: x_train, y: y_train})
print(&quot;W: %s b: %s loss: %s&quot;%(curr_W, curr_b, curr_loss))
</code></pre>

<pre><code>W: [-0.9999969] b: [ 0.99999082] loss: 5.69997e-11
</code></pre>

<p>This more complicated program can still be visualized in TensorBoard:</p>

<p><img src="media/15033740189206/getting_started_final.png" alt=""/></p>

<h2 id="toc_5">tf.estimator</h2>

<p><code>tf.estimator</code> is a high-level TensorFlow library that simplifies the mechanics of machine learning, including the following:</p>

<ul>
<li>running training loops</li>
<li>running evaluation loops</li>
<li>managing data sets</li>
<li><code>tf.estimator</code> defines many common models.</li>
</ul>

<h3 id="toc_6">Basic usage</h3>

<p>Notice how much simpler the linear regression program becomes with <code>tf.estimator</code>:</p>

<pre><code class="language-python"># NumPy is often used to load, manipulate and preprocess data.
import numpy as np

# Declare list of features. We only have one numeric feature. There are many
# other types of columns that are more complicated and useful.
feature_columns = [tf.feature_column.numeric_column(&quot;x&quot;, shape=[1])]

# An estimator is the front end to invoke training (fitting) and evaluation
# (inference). There are many predefined types like linear regression,
# linear classification, and many neural network classifiers and regressors.
# The following code provides an estimator that does linear regression.
estimator = tf.estimator.LinearRegressor(feature_columns=feature_columns)

# TensorFlow provides many helper methods to read and set up data sets.
# Here we use two data sets: one for training and one for evaluation
# We have to tell the function how many batches
# of data (num_epochs) we want and how big each batch should be.
x_train = np.array([1., 2., 3., 4.])
y_train = np.array([0., -1., -2., -3.])
x_eval = np.array([2., 5., 8., 1.])
y_eval = np.array([-1.01, -4.1, -7, 0.])
input_fn = tf.estimator.inputs.numpy_input_fn(
    {&quot;x&quot;: x_train}, y_train, batch_size=4, num_epochs=None, shuffle=True)
train_input_fn = tf.estimator.inputs.numpy_input_fn(
    {&quot;x&quot;: x_train}, y_train, batch_size=4, num_epochs=1000, shuffle=False)
eval_input_fn = tf.estimator.inputs.numpy_input_fn(
    {&quot;x&quot;: x_eval}, y_eval, batch_size=4, num_epochs=1000, shuffle=False)

# We can invoke 1000 training steps by invoking the  method and passing the
# training data set.
estimator.train(input_fn=input_fn, steps=1000)

# Here we evaluate how well our model did.
train_metrics = estimator.evaluate(input_fn=train_input_fn)
eval_metrics = estimator.evaluate(input_fn=eval_input_fn)
print(&quot;train metrics: %r&quot;% train_metrics)
print(&quot;eval metrics: %r&quot;% eval_metrics)
</code></pre>

<pre><code>INFO:tensorflow:Using default config.
WARNING:tensorflow:Using temporary folder as model directory: /var/folders/66/y1hc77j572v71r0gm2r39rfr0000gn/T/tmp2rnith_a
INFO:tensorflow:Using config: {&#39;_model_dir&#39;: &#39;/var/folders/66/y1hc77j572v71r0gm2r39rfr0000gn/T/tmp2rnith_a&#39;, &#39;_tf_random_seed&#39;: 1, &#39;_save_summary_steps&#39;: 100, &#39;_save_checkpoints_secs&#39;: 600, &#39;_save_checkpoints_steps&#39;: None, &#39;_session_config&#39;: None, &#39;_keep_checkpoint_max&#39;: 5, &#39;_keep_checkpoint_every_n_hours&#39;: 10000, &#39;_log_step_count_steps&#39;: 100}
INFO:tensorflow:Create CheckpointSaverHook.
INFO:tensorflow:Saving checkpoints for 1 into /var/folders/66/y1hc77j572v71r0gm2r39rfr0000gn/T/tmp2rnith_a/model.ckpt.
INFO:tensorflow:loss = 19.0, step = 1
INFO:tensorflow:global_step/sec: 592.325
INFO:tensorflow:loss = 0.192443, step = 101 (0.171 sec)
INFO:tensorflow:global_step/sec: 710.314
INFO:tensorflow:loss = 0.0370785, step = 201 (0.141 sec)
INFO:tensorflow:global_step/sec: 669.791
INFO:tensorflow:loss = 0.0173565, step = 301 (0.150 sec)
INFO:tensorflow:global_step/sec: 729.609
INFO:tensorflow:loss = 0.00361388, step = 401 (0.136 sec)
INFO:tensorflow:global_step/sec: 814
INFO:tensorflow:loss = 0.000215951, step = 501 (0.123 sec)
INFO:tensorflow:global_step/sec: 793.172
INFO:tensorflow:loss = 0.0001734, step = 601 (0.127 sec)
INFO:tensorflow:global_step/sec: 776.415
INFO:tensorflow:loss = 3.66416e-05, step = 701 (0.128 sec)
INFO:tensorflow:global_step/sec: 845.781
INFO:tensorflow:loss = 3.03422e-06, step = 801 (0.118 sec)
INFO:tensorflow:global_step/sec: 849.689
INFO:tensorflow:loss = 1.18453e-06, step = 901 (0.118 sec)
INFO:tensorflow:Saving checkpoints for 1000 into /var/folders/66/y1hc77j572v71r0gm2r39rfr0000gn/T/tmp2rnith_a/model.ckpt.
INFO:tensorflow:Loss for final step: 3.72255e-07.
INFO:tensorflow:Starting evaluation at 2017-08-21-05:57:38
INFO:tensorflow:Restoring parameters from /var/folders/66/y1hc77j572v71r0gm2r39rfr0000gn/T/tmp2rnith_a/model.ckpt-1000
INFO:tensorflow:Finished evaluation at 2017-08-21-05:57:40
INFO:tensorflow:Saving dict for global step 1000: average_loss = 6.05797e-08, global_step = 1000, loss = 2.42319e-07
INFO:tensorflow:Starting evaluation at 2017-08-21-05:57:40
INFO:tensorflow:Restoring parameters from /var/folders/66/y1hc77j572v71r0gm2r39rfr0000gn/T/tmp2rnith_a/model.ckpt-1000
INFO:tensorflow:Finished evaluation at 2017-08-21-05:57:42
INFO:tensorflow:Saving dict for global step 1000: average_loss = 0.00254753, global_step = 1000, loss = 0.0101901
train metrics: {&#39;average_loss&#39;: 6.057968e-08, &#39;loss&#39;: 2.4231872e-07, &#39;global_step&#39;: 1000}
eval metrics: {&#39;average_loss&#39;: 0.0025475256, &#39;loss&#39;: 0.010190102, &#39;global_step&#39;: 1000}
</code></pre>

]]></content>
  </entry>
  
</feed>
