<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[techlarry]]></title>
  <link href="http://larryim.cc/atom.xml" rel="self"/>
  <link href="http://larryim.cc/"/>
  <updated>2017-08-25T20:42:19+08:00</updated>
  <id>http://larryim.cc/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Support Vector Machines]]></title>
    <link href="http://larryim.cc/15036619229303.html"/>
    <updated>2017-08-25T19:52:02+08:00</updated>
    <id>http://larryim.cc/15036619229303.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Training Objective</h2>

<p>The smaller the weight vector <code>w</code>, the larger the margin. So we want to minimize \(\lVert w\rVert\) to get a large margin.</p>

<h3 id="toc_1">Hard Margin</h3>

<p>If we also want to avoid any margin violation (<code>hard margin</code>), then we need the decision function to be greater than 1 for all positive trainig instances, and lower than  -1 for negative training instances. If we define \(t^{(i)} = -1\) for negative instances (if \(y^{(i)}&gt;0\)) and \(t^{(i)}=1\) for positive instances (if \(y^{(i)}=1\)), then we can express this constraint as \(t^{(i)}(w^T\cdot x^{(i)}+b) \le 1\) for all instances. </p>

<p>** Hard Margin linear SVM classifier objective**</p>

<p>\[<br/>
\min_{w,b} \frac{1}{2}w^T\cdot w \\<br/>
\text{subject to } t^{(i)}(w^T\cdot x^{(i)}+b) \le 1  \quad for \quad i =1,2,...,m<br/>
\]</p>

<h3 id="toc_2">Soft Margin</h3>

<p>To get the soft margin objective, we need to introduce a <code>slack variable</code> \(\zeta^(i)\le0\) for each instance: \(\zeta^{(i)}\) measures how much the \(i^{th}\) instance is allowed to violate the margin. We now have two conflicting objectives: making the slack variables as small as possible to reduce the margin violations, and makeing \(\frac{1}{2}w^T\cdot w \) as small as possible to increase the margin.</p>

<p>** Soft Margin linear SVM classifier objective**</p>

<p>\[<br/>
\min_{w,b} \frac{1}{2}w^T\cdot w + C\sum^m_{i=1}\zeta^{(i)}\\<br/>
\text{subject to } t^{(i)}(w^T\cdot x^{(i)}+b) \le 1 - \zeta^{(i)} \quad for \quad i =1,2,...,m<br/>
\]</p>

<h2 id="toc_3">Implementation</h2>

<pre><code class="language-python">import numpy as np
from sklearn import datasets
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.svm import LinearSVC
from sklearn.svm import SVC
import matplotlib.pyplot as plt
</code></pre>

<h2 id="toc_4">Soft Margin Classification</h2>

<pre><code class="language-python">
# load data sets
iris = datasets.load_iris()
x = iris[&#39;data&#39;][:,(2,3)] # petal length, petal width
y = (iris[&#39;target&#39;] == 2).astype(np.float64) # Iris-Virginica
</code></pre>

<pre><code class="language-python">%matplotlib inline
plt.scatter(x[:,0], x[:,1], c=y)
</code></pre>

<pre><code>&lt;matplotlib.collections.PathCollection at 0x110ecf0f0&gt;
</code></pre>

<p><img src="media/15036619229303/output_4_1.png" alt="png"/></p>

<pre><code class="language-python"># plot decision boundary
def make_meshgrid(x, y, h=.02):
    &quot;&quot;&quot;Create a mesh of points to plot in

    Parameters
    ----------
    x: data to base x-axis meshgrid on
    y: data to base y-axis meshgrid on
    h: stepsize for meshgrid, optional

    Returns
    -------
    xx, yy : ndarray
    &quot;&quot;&quot;
    x_min, x_max = x.min() - 1, x.max() + 1
    y_min, y_max = y.min() - 1, y.max() + 1
    xx, yy = np.meshgrid(np.arange(x_min, x_max, h),
                         np.arange(y_min, y_max, h))
    return xx, yy

def plot_contours(model, xx, yy, **params):
    &quot;&quot;&quot;Plot the decision boundaries for a classifier.

    Parameters
    ----------
    ax: matplotlib axes object
    clf: a classifier
    xx: meshgrid ndarray
    yy: meshgrid ndarray
    params: dictionary of params to pass to contourf, optional
    &quot;&quot;&quot;
    Z = model.predict(np.c_[xx.ravel(), yy.ravel()])
    Z = Z.reshape(xx.shape)
    out = plt.contourf(xx, yy, Z, **params)
    return out
</code></pre>

<pre><code class="language-python"># svm
svm_clf = Pipeline([
    (&#39;scalar&#39;, StandardScaler()),
    (&#39;linear_svc&#39;, LinearSVC(C=1, loss=&#39;hinge&#39;))])
svm_clf.fit(x, y)
</code></pre>

<pre><code>Pipeline(steps=[(&#39;scalar&#39;, StandardScaler(copy=True, with_mean=True, with_std=True)), (&#39;linear_svc&#39;, LinearSVC(C=1, class_weight=None, dual=True, fit_intercept=True,
     intercept_scaling=1, loss=&#39;hinge&#39;, max_iter=1000, multi_class=&#39;ovr&#39;,
     penalty=&#39;l2&#39;, random_state=None, tol=0.0001, verbose=0))])
</code></pre>

<pre><code class="language-python">plot_contours(svm_clf, xx, yy,
              cmap=plt.cm.coolwarm, alpha=0.8)
plt.hold
plt.scatter(x[:,0], x[:,1], c=y)
</code></pre>

<pre><code>&lt;matplotlib.collections.PathCollection at 0x111e5c128&gt;
</code></pre>

<p><img src="media/15036619229303/output_7_1.png" alt="png"/></p>

<h2 id="toc_5">Nonelinear SVM Classification</h2>

<p>One approach to handling nonlinear datasets is to add more features, such as polynomial features. In some cases result in a linearly separable dataset.</p>

<pre><code class="language-python">from sklearn.preprocessing import PolynomialFeatures

polynomial_svm_clf = Pipeline([
    (&#39;poly_features&#39;, PolynomialFeatures(degree=3)),
    (&#39;scaler&#39;, StandardScaler()),
    (&#39;svm, clf&#39;, LinearSVC(C=10, loss=&#39;hinge&#39;))
])

polynomial_svm_clf.fit(x, y)
</code></pre>

<pre><code>Pipeline(steps=[(&#39;poly_features&#39;, PolynomialFeatures(degree=3, include_bias=True, interaction_only=False)), (&#39;scaler&#39;, StandardScaler(copy=True, with_mean=True, with_std=True)), (&#39;svm, clf&#39;, LinearSVC(C=10, class_weight=None, dual=True, fit_intercept=True,
     intercept_scaling=1, loss=&#39;hinge&#39;, max_iter=1000, multi_class=&#39;ovr&#39;,
     penalty=&#39;l2&#39;, random_state=None, tol=0.0001, verbose=0))])
</code></pre>

<pre><code class="language-python">xx, yy = make_meshgrid(x[:,0], x[:,1])
plot_contours(polynomial_svm_clf, xx, yy,
              cmap=plt.cm.coolwarm, alpha=0.8)
plt.hold
plt.scatter(x[:,0], x[:,1], c=y)
</code></pre>

<pre><code>&lt;matplotlib.collections.PathCollection at 0x112f0a470&gt;
</code></pre>

<p><img src="media/15036619229303/output_10_1.png" alt="png"/></p>

<h2 id="toc_6">Gaussian RBF Kernal</h2>

<p>Define the similarity function to be the Gaussian Radial Basis Function (RBF):</p>

<p>\[\phi(x, \gamma) = exp(-\gamma \lVert x-l\rVert ^2)\]</p>

<p>Let&#39;s try the Gaussian RBF kernel using the <code>SVC</code> class:</p>

<pre><code class="language-python">rbf_kernel_svm_clf = Pipeline([
    (&#39;svm_clf&#39;, SVC(kernel=&#39;rbf&#39;, gamma=0.1, C=0.1))
])
rbf_kernel_svm_clf.fit(x,y)
</code></pre>

<pre><code>Pipeline(steps=[(&#39;svm_clf&#39;, SVC(C=0.1, cache_size=200, class_weight=None, coef0=0.0,
  decision_function_shape=None, degree=3, gamma=0.1, kernel=&#39;rbf&#39;,
  max_iter=-1, probability=False, random_state=None, shrinking=True,
  tol=0.001, verbose=False))])
</code></pre>

<pre><code class="language-python">plot_contours(rbf_kernel_svm_clf, xx, yy,
              cmap=plt.cm.coolwarm, alpha=0.8)
plt.hold
plt.scatter(x[:,0], x[:,1], c=y)
</code></pre>

<pre><code>&lt;matplotlib.collections.PathCollection at 0x114174518&gt;
</code></pre>

<p><img src="media/15036619229303/output_13_1.png" alt="png"/></p>

<p>Other kernals such as <code>sigmoid</code>, <code>precomputed</code> are also used. With so many kernels to choose from, as a rule of thumb, you should always try the linear kernel first, especailly if the training set is very large or if it has plenty of features. If the training set is not too large, you should try the Gaussian RBF kernel as well; it works well in most cases.</p>

<h2 id="toc_7">Complexity</h2>

<p>Time complexity of algorithms above:</p>

<ul>
<li><code>LinearSVC</code>: \(O(m\times n)\)</li>
<li><code>SGDClassifier</code>: \(O(m\times n)\)</li>
<li><code>SVC</code>: \(O(m^2\times n) \text{ to } O(m^3\times n)\)</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vector and Matrix Product in Numpy and TensorFlow]]></title>
    <link href="http://larryim.cc/15035780907547.html"/>
    <updated>2017-08-24T20:34:50+08:00</updated>
    <id>http://larryim.cc/15035780907547.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Numpy</h2>

<p>Following are common vector and matrix product operations in Numpy, they are quite simple and straightforward:</p>

<ul>
<li><p>Inner Product   \(\quad a^Tb\quad \):  <code>np.inner()</code></p></li>
<li><p>Outer Product  \(\quad ab^T\quad \):  <code>np.outer()</code></p></li>
<li><p>Dot Product  \(\quad a \cdot b = \sum a_ib_i\quad \): <code>np.dot()</code></p></li>
<li><p>Elementwise Product  \(\quad c_i = a_ib_i\quad \): <code>np.multiply()</code></p></li>
</ul>

<p>Note: inner product is defined on vector spaces over a field ùïÇ (finite or infinite dimensional). Dot product refers specifically to the product of vectors in \(‚Ñù^n\)</p>

<p>The difference between the following implementations of the dot/inner/outer/elementwise product are demonstrated as follows:</p>

<pre><code class="language-python">W = np.ones((2, 7), dtype=&#39;float32&#39;)
x1 = [9, 2, 5, 0, 0, 7, 5]
x2 = [9, 2, 2, 9, 0, 9, 2]
print(&#39;vector dot product&#39;, np.dot(x1,x2)) # dot product
print(&#39;inner&#39;, np.inner(x1,x2)) # inner product
print(&#39;outter&#39;, np.outer(x1,x2)) # outter product
print(&#39;element-wsie&#39;, np.multiply(x1,x2)) # Element-wise product
print(&#39;matrix dot product&#39;, np.dot(W, x1)) # dot product
</code></pre>

<pre><code>dot for vector 168
inner 168
outter [[81 18 18 81  0 81 18]
 [18  4  4 18  0 18  4]
 [45 10 10 45  0 45 10]
 [ 0  0  0  0  0  0  0]
 [ 0  0  0  0  0  0  0]
 [63 14 14 63  0 63 14]
 [45 10 10 45  0 45 10]]
element-wsie [81  4 10  0  0 63 10]
dot for matrix [ 28.  28.]
</code></pre>

<h2 id="toc_1">TensorFlow</h2>

<p>Vector inner/outer Product are a bit complex in TensorFlow. </p>

<pre><code class="language-python">import tensorflow as tf
import numpy as np

x = tf.Variable([[1, -2, 3]], tf.float32, name=&#39;x&#39;)
y = tf.Variable([[-1, 2, -3]], tf.float32, name=&#39;y&#39;)

## inner product
inner_product1 = tf.reduce_sum(tf.multiply(x, y))
inner_product2 = tf.matmul(x, y, transpose_a=False, transpose_b= True) # different from inner_product1

## outer product
outer_product2 = tf.matmul(x, y, transpose_a= True)

## matrix dot product
X = tf.constant(np.random.randn(3,3), name=&#39;X&#39;)
W = tf.constant(np.random.randn(3,3), name=&#39;W&#39;)
matrix_product = tf.matmul(W, X)

sess = tf.InteractiveSession()
init_op = tf.global_variables_initializer()

# run
sess.run(init_op)
print(sess.run(inner_product1))
print(sess.run(inner_product2))
print(sess.run(outer_product2))
print(sess.run(matrix_product))
</code></pre>

<pre><code>-14
[[-14]]
[[-1  2 -3]
 [ 2 -4  6]
 [-3  6 -9]]
[[-0.88722509 -0.94128018 -2.1999658 ]
 [-0.67967623  1.33193446 -0.75612585]
 [ 0.31741623  1.3271727  -0.04311113]]
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python `set`, `tuple`]]></title>
    <link href="http://larryim.cc/15035712266178.html"/>
    <updated>2017-08-24T18:40:26+08:00</updated>
    <id>http://larryim.cc/15035712266178.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0"><code>set</code></h2>

<p>A <code>set</code> is an unordered collection with no duplicate elements. Basic uses include membership testing and eliminating duplicate entries. Set objects also support mathematical operations like <code>union</code>, intersection, difference, and symmetric difference.</p>

<p>Curly braces or the <code>set()</code> function can be used to create sets. Note: to create an empty set you have to use <code>set()</code>, not {}; the latter creates an empty dictionary, a data structure that we discuss in the next section.</p>

<pre><code class="language-python">&gt;&gt;&gt; basket = {&#39;apple&#39;, &#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;orange&#39;, &#39;banana&#39;}
&gt;&gt;&gt; print(basket)                      # show that duplicates have been removed
{&#39;orange&#39;, &#39;banana&#39;, &#39;pear&#39;, &#39;apple&#39;}
&gt;&gt;&gt; &#39;orange&#39; in basket                 # fast membership testing
True
&gt;&gt;&gt; &#39;crabgrass&#39; in basket
False

&gt;&gt;&gt; # Demonstrate set operations on unique letters from two words
...
&gt;&gt;&gt; a = set(&#39;abracadabra&#39;)
&gt;&gt;&gt; b = set(&#39;alacazam&#39;)
&gt;&gt;&gt; a                                  # unique letters in a
{&#39;a&#39;, &#39;r&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;}
&gt;&gt;&gt; a - b                              # letters in a but not in b
{&#39;r&#39;, &#39;d&#39;, &#39;b&#39;}
&gt;&gt;&gt; a | b                              # letters in either a or b
{&#39;a&#39;, &#39;c&#39;, &#39;r&#39;, &#39;d&#39;, &#39;b&#39;, &#39;m&#39;, &#39;z&#39;, &#39;l&#39;}
&gt;&gt;&gt; a &amp; b                              # letters in both a and b
{&#39;a&#39;, &#39;c&#39;}
&gt;&gt;&gt; a ^ b                              # letters in a or b but not both
{&#39;r&#39;, &#39;d&#39;, &#39;b&#39;, &#39;m&#39;, &#39;z&#39;, &#39;l&#39;}
</code></pre>

<h2 id="toc_1"><code>tuple</code></h2>

<p>A <code>tuple</code> is an (<code>immutable</code>) ordered list of values. A <code>tuple</code> is in many ways similar to a list; one of the most important differences is that <code>tuple</code> can be used as keys in dictionaries and as elements of sets, while <code>list</code> cannot. Here is a trivial example:</p>

<pre><code class="language-python">d = {(x, x + 1): x for x in range(10)}  # Create a dictionary with tuple keys
t = (5, 6)        # Create a tuple
print(type(t))    # Prints &quot;&lt;class &#39;tuple&#39;&gt;&quot;
print(d[t])       # Prints &quot;5&quot;
print(d[(1, 2)])  # Prints &quot;1&quot;
</code></pre>

<p>A special problem is the construction of tuples containing 0 or 1 items: the syntax has some extra quirks to accommodate these. Empty tuples are constructed by an empty pair of parentheses; a tuple with one item is constructed by following a value with a comma (it is not sufficient to enclose a single value in parentheses). Ugly, but effective. For example:</p>

<pre><code class="language-python">&gt;&gt;&gt; empty = ()
&gt;&gt;&gt; singleton = &#39;hello&#39;,    # &lt;-- note trailing comma
&gt;&gt;&gt; len(empty)
0
&gt;&gt;&gt; len(singleton)
1
&gt;&gt;&gt; singleton
(&#39;hello&#39;,)
</code></pre>

<p>The tuple syntax is simple, if you separate some values with commas, you automatically have a tuple(called <code>tuple packing</code>),</p>

<pre><code>&gt;&gt;&gt; 1,2,3
(1, 2, 3)
</code></pre>

<h3 id="toc_2"><code>tuple</code> function</h3>

<p>The <code>tuple</code> function works in pretty much the same way as <code>list</code>: it takes one sequence argument and converts it to a <code>tuple</code>.</p>

<pre><code>&gt;&gt;&gt; tuple([1,2,3])
(1, 2, 3)
</code></pre>

<h3 id="toc_3">Performance</h3>

<p>Instantiation is almost an order of magnitude faster for the tuple, but item access is actually somewhat faster for the list! So if you&#39;re creating a few tuples and accessing them many many times, it may actually be faster to use lists instead.</p>

<pre><code class="language-python">$ python -m timeit &quot;x=(1,2,3,4,5,6,7,8)&quot;
10000000 loops, best of 3: 0.0388 usec per loop

$ python -m timeit &quot;x=[1,2,3,4,5,6,7,8]&quot;
1000000 loops, best of 3: 0.363 usec per loop

$ python -m timeit -s &quot;x=(1,2,3,4,5,6,7,8)&quot; &quot;y=x[3]&quot;
10000000 loops, best of 3: 0.0938 usec per loop

$ python -m timeit -s &quot;x=[1,2,3,4,5,6,7,8]&quot; &quot;y=x[3]&quot;
10000000 loops, best of 3: 0.0649 usec per loop
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TensorFlow Operation]]></title>
    <link href="http://larryim.cc/tensorflow_operation.html"/>
    <updated>2017-08-22T14:33:29+08:00</updated>
    <id>http://larryim.cc/tensorflow_operation.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">1 Visualize with TensorBoard</a>
<ul>
<li>
<a href="#toc_1">Explicitly name operation, variable</a>
</li>
</ul>
</li>
<li>
<a href="#toc_2">2 Constant types</a>
<ul>
<li>
<a href="#toc_3">Tensors filled with a specific value</a>
</li>
<li>
<a href="#toc_4">Constants as sequences</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">3 Math Operations</a>
</li>
<li>
<a href="#toc_6">4 TensorFlow data types:</a>
<ul>
<li>
<a href="#toc_7">Python Native Types</a>
</li>
<li>
<a href="#toc_8">TensorFlow Native Types</a>
</li>
<li>
<a href="#toc_9">Numpy Data Types</a>
</li>
<li>
<a href="#toc_10">Constant</a>
</li>
<li>
<a href="#toc_11">Variables</a>
<ul>
<li>
<a href="#toc_12">Each session maintains its own copy of variable</a>
</li>
<li>
<a href="#toc_13">Use a variable to initialize another variables</a>
</li>
<li>
<a href="#toc_14">Session vs InteractiveSession,</a>
</li>
</ul>
</li>
<li>
<a href="#toc_15">Placeholder</a>
</li>
<li>
<a href="#toc_16">Lazy loading</a>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">1 Visualize with TensorBoard</h2>

<pre><code class="language-python">import tensorflow as tf
a = tf.constant(2, name=&#39;a&#39;)
b = tf.constant(3, name=&#39;b&#39;)
x = tf.add(a, b, name=&#39;add&#39;)
with tf.Session() as sess:
    writer = tf.summary.FileWriter(&#39;./graphs&#39;, sess.graph)
    print(sess.run(x))media/15033836099887
writer.close() # close the writer when you&#39;re done using it.
</code></pre>

<pre><code>5
</code></pre>

<p>Bash command (to view TensorBoard):</p>

<pre><code class="language-bash"> tensorboard --logdir=&#39;./graphs&#39; --port 6006
 # open http://localhost:6006/#graphs in your browser
</code></pre>

<h3 id="toc_1">Explicitly name operation, variable</h3>

<pre><code class="language-python">a = tf.constant(2, name=&#39;a&#39;)
b = tf.constant(3, name=&#39;b&#39;)
x = tf.add(a,b,name=&#39;add&#39;)
with tf.Session() as sess:
    writer = tf.summary.FileWriter(&#39;./graphs&#39;, sess.graph)
    print(sess.run(x))
writer.close() # close the writer when you&#39;re done using it.
</code></pre>

<pre><code>5
</code></pre>

<p>The figure produced by TensorBoard is as follows:</p>

<p><img src="media/15033836099887/explicit_name.png" alt=""/></p>

<p><strong>Note</strong>:  Learn to use TensorBoard well and often. It will help a lot when you build complicated models.</p>

<h2 id="toc_2">2 Constant types</h2>

<h3 id="toc_3">Tensors filled with a specific value</h3>

<p>Using <code>tensorflow.zeros</code> to fill tensor with zeros, which is similar to <code>Numpy</code>:</p>

<pre><code class="language-python">tf.zeros(shape, dtype=tf.float32, name=None)
</code></pre>

<p>For example,</p>

<pre><code class="language-python">x = tf.zeros([2,3], tf.int32)
with tf.Session() as sess:
    print(sess.run(x))
</code></pre>

<pre><code>[[0 0 0]
 [0 0 0]]
</code></pre>

<p><code>tensorflow.zeros_like</code> return an tensor of zeros with the same shape and type as a given tensor. For example, we may want to have a tensor filled with zeros, with the same shape as <code>x</code>:</p>

<pre><code class="language-python">y = tf.zeros_like(x)
with tf.Session() as sess:
    print(sess.run(y))
</code></pre>

<pre><code>[[0 0 0]
 [0 0 0]]
</code></pre>

<p>There are other command to fill tensor with a specific value, such as <code>tensorflow.ones</code>, <code>tensorflow.ones_like</code>, which of usage is similar to <code>tensorflow.zeros</code>, <code>tensorflow.zeros_like</code>.</p>

<p><code>tensorflow.fill</code> creates a tensor filled with a scalar value:</p>

<pre><code class="language-python">tf.fill(dims, value, name=None)
</code></pre>

<pre><code class="language-python">z = tf.fill([3,4],3)
with tf.Session() as sess:
    print(sess.run(z))
</code></pre>

<pre><code>[[3 3 3 3]
 [3 3 3 3]
 [3 3 3 3]]
</code></pre>

<h3 id="toc_4">Constants as sequences</h3>

<p>You can create constants that are sequences, using <code>tf.linspace</code>, <code>tf.range</code>:</p>

<pre><code class="language-python">tf.linspace(start, stop, num, name=None)

# create a sequence of num evenly-spaced values are generated beginning at  start. If num &gt; 1, the values in the sequence increase by stop - start / num - 1, so that the last one is exactly stop.
# start, stop, num must be scalars
# comparable to but slightly different from numpy.linspace
# numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)

tf.range(start, limit=None, delta=1, dtype=None, name=&#39;range&#39;)
# create a sequence of numbers that begins at start and extends by increments of delta up to but not including limit
# slight different from range in Python
</code></pre>

<pre><code class="language-python">x = tf.linspace(10.0, 13.0, 4, name=&#39;linspace&#39;)
y = tf.range(3, 18)
z= tf.range(3, 18, 3)
with tf.Session() as sess:
    print(sess.run(x))
    print(sess.run(y))
    print(sess.run(z))
</code></pre>

<pre><code>[ 10.  11.  12.  13.]
[ 3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
[ 3  6  9 12 15]
</code></pre>

<h2 id="toc_5">3 Math Operations</h2>

<p><img src="media/15033836099887/math_operations.png" alt=""/></p>

<pre><code class="language-python">a = tf.constant([[3,6],[0,0]])
b = tf.constant([[0,0],[2,2]])
x1 = tf.add(a, b)
x2 = tf.add_n([a,b,b]) # &gt;&gt; [7 10]. Equivalent to a + b + b
x3 = tf.multiply(a, b) # &gt;&gt; [6 12] because mul is element wise
x4 = tf.matmul(a, b) # &gt;&gt; ValueError
x5 = tf.matmul(tf.reshape(a, [4, 1]), tf.reshape(b, [1, 4])) # &gt;&gt; [[18]]

with tf.Session() as sess:
    sess.run(a)
    sess.run(b)
    print(&#39;x1:\n&#39;, sess.run(x1))
    print(&#39;x2:\n&#39;, sess.run(x2))
    print(&#39;x3:\n&#39;, sess.run(x3))
    print(&#39;x4:\n&#39;, sess.run(x4))
    print(&#39;x5:\n&#39;, sess.run(x5))
</code></pre>

<pre><code>x1:
 [[3 6]
 [2 2]]
x2:
 [[3 6]
 [4 4]]
x3:
 [[0 0]
 [0 0]]
x4:
 [[12 12]
 [ 0  0]]
x5:
 [[ 0  0  6  6]
 [ 0  0 12 12]
 [ 0  0  0  0]
 [ 0  0  0  0]]
</code></pre>

<h2 id="toc_6">4 TensorFlow data types:</h2>

<h3 id="toc_7">Python Native Types</h3>

<p>TensorFlow takes Python natives types: <code>boolean</code>, <code>numeric</code> (<code>int</code>, <code>float</code>), <code>strings</code></p>

<p>TensorFlow takes in Python native types such as Python boolean values, numeric values (integers, floats), and strings. Single values will be converted to 0-d tensors (or scalars), lists of values will be converted to 1-d tensors (vectors), lists of lists of values will be converted to 2-d tensors (matrices), and so on.</p>

<pre><code class="language-python">tf.InteractiveSession() # open tensorflow interactivesession
t_0 = 19   # Treated as a 0-d tensor, or &quot;scalar&quot; 
print(&#39;t_0:&#39;,t_0)
print(tf.zeros_like(t_0))   # ==&gt; 0
print(tf.ones_like(t_0))   # ==&gt; 1
t_1 = [b&quot;apple&quot; ,  b&quot;peach&quot; ,  b&quot;grape&quot;]   # treated as a 1-d tensor, or &quot;vector&quot; 
print(&#39;t_1:&#39;,t_1)
print(tf.zeros_like(t_1))   # ==&gt; [&#39;&#39; &#39;&#39; &#39;&#39;]
t_2= [[ True, False, False],  [False, False, True], [False, True ,   False ]]   # treated as a 2-d tensor, or &quot;matrix&quot;
print(&#39;t_2:&#39;,t_2)
print(tf.zeros_like(t_2))   # ==&gt; 2x2 tensor, all elements are False 
print(tf.ones_like(t_2))   # ==&gt; 2x2 tensor, all elements are True
</code></pre>

<pre><code>t_0: 19
Tensor(&quot;zeros_like_32:0&quot;, shape=(), dtype=int32)
Tensor(&quot;ones_like_20:0&quot;, shape=(), dtype=int32)
t_1: [b&#39;apple&#39;, b&#39;peach&#39;, b&#39;grape&#39;]
Tensor(&quot;zeros_like_33:0&quot;, shape=(3,), dtype=string)
t_2: [[True, False, False], [False, False, True], [False, True, False]]
Tensor(&quot;zeros_like_34:0&quot;, shape=(3, 3), dtype=bool)
Tensor(&quot;ones_like_21:0&quot;, shape=(3, 3), dtype=bool)
</code></pre>

<p><strong>Note: Do not use Python native types for tensors because TensorFlow has to infer Python type.</strong></p>

<h3 id="toc_8">TensorFlow Native Types</h3>

<p>Like <code>NumPy</code>, <code>TensorFlow</code> also its own data types such as <code>tf.int32</code>, <code>tf.float32</code>. Below is a list of current TensorFlow data types.</p>

<p><img src="media/15033836099887/tensorflow_data_types.png" alt=""/></p>

<h3 id="toc_9">Numpy Data Types</h3>

<p>By now, you‚Äôve probably noticed the similarity between <code>NumPy</code> and <code>TensorFlow</code>. <code>TensorFlow</code> was designed to integrate seamlessly with <code>Numpy</code>, the package that has become the  lingua franca of data science.</p>

<p>TensorFlow‚Äôs data types are based on those of NumPy; in fact, <code>np.int32 == tf.int32</code> returns <code>True</code>. You can pass <code>NumPy</code> types to <code>TensorFlow</code> ops.</p>

<p>Example:</p>

<pre><code class="language-python">import numpy as np
tf.ones([2, 2],  np.float32)
</code></pre>

<pre><code>&lt;tf.Tensor &#39;ones:0&#39; shape=(2, 2) dtype=float32&gt;
</code></pre>

<pre><code class="language-python">x = np.zeros((2,2))
tf.ones_like(x)
</code></pre>

<pre><code>&lt;tf.Tensor &#39;ones_like_22:0&#39; shape=(2, 2) dtype=float64&gt;
</code></pre>

<h3 id="toc_10">Constant</h3>

<p>Constants are stored in the graph definition. This makes loading graphs expensive when constants are big. <strong>Only use constants for primitive types, use variables or readers for more data that requires more memory</strong>.</p>

<pre><code class="language-python">g = tf.Graph() # to add operators to a graph, set it as default:
with g.as_default():
    my_const = tf.constant([1.0, 2.0], name=&quot;my_const&quot;)
    with tf.Session() as sess:
        print(sess.graph.as_graph_def())
</code></pre>

<pre><code>node {
  name: &quot;my_const&quot;
  op: &quot;Const&quot;
  attr {
    key: &quot;dtype&quot;
    value {
      type: DT_FLOAT
    }
  }
  attr {
    key: &quot;value&quot;
    value {
      tensor {
        dtype: DT_FLOAT
        tensor_shape {
          dim {
            size: 2
          }
        }
        tensor_content: &quot;\000\000\200?\000\000\000@&quot;
      }
    }
  }
}
versions {
  producer: 24
}
</code></pre>

<h3 id="toc_11">Variables</h3>

<p><code>tf.constant</code> is an operation, but <code>tf.Variable</code> is a class. <code>tf.Variables</code> holds several operations:</p>

<pre><code class="language-python">tf.InteractiveSession()
xx = tf.Variable(23, name=&#39;scalar&#39;)
xx.initializer # init op
xx.value() # read op
assign_op = xx.assign(5)

</code></pre>

<p>You have to initialize <code>variables</code>, The easiest way is initializing all variables at once:</p>

<pre><code class="language-python">init = tf.global_variables_initializer()
with tf.Session() as sess:
    sess.run(init)
    print(xx.eval())
    sess.run(assign_op)
    print(xx.eval())
</code></pre>

<pre><code>23
5
</code></pre>

<h4 id="toc_12">Each session maintains its own copy of variable</h4>

<pre><code class="language-python">W = tf.Variable(10, name=&#39;W&#39;)
sess1 = tf.Session()
sess2 = tf.Session()
sess1.run(W.initializer)
sess2.run(W.initializer)
print(sess1.run(W.assign_add(10)))
print(sess2.run(W.assign_sub(2))) # not 18!

sess1.close()
sess2.close()
</code></pre>

<pre><code>20
8
</code></pre>

<h4 id="toc_13">Use a variable to initialize another variables</h4>

<pre><code class="language-python"># want to declare U = 2*W
# W is random tensor
W = tf.Variable(tf.truncated_normal([4, 2]))
U = tf.Variable(2*W.initialized_value())
with tf.Session() as sess:
    sess.run(U.initializer)
    print(U.eval())
</code></pre>

<pre><code>[[ 1.11442947 -3.1675539 ]
 [ 3.02267933 -0.81786388]
 [ 2.57613969 -0.98440802]
 [ 0.6298722  -0.38194153]]
</code></pre>

<h4 id="toc_14">Session vs InteractiveSession,</h4>

<p>You sometimes see InteractiveSession instead of Session. The only difference is an InteractiveSession makes itself the default.</p>

<pre><code class="language-python">sess = tf.InteractiveSession()
a = tf.constant(5.0)
b = tf.constant(6.0)
c = a*b
# We can just use `c.eval()` with out specifying the context `sess`
print(c.eval())
sess.close()
</code></pre>

<pre><code>30.0
</code></pre>

<h3 id="toc_15">Placeholder</h3>

<p>A TensorFlow program often has 2 phases:</p>

<ol>
<li>Assemble a graph</li>
<li>Use a session to execute operations in the graph</li>
</ol>

<p>\(\rightarrow\) can assemble the graph without knowing the values needed for computation</p>

<p><strong>Analogy</strong>: Can define the function \(f(x,y) = x*2+y\) without knowing value of \(x\) or \(y\).</p>

<p>So using <code>placeholders</code>, we can later supply their data when they needed to execute the computation.</p>

<pre><code>tf.placeholder(dtype, shape=None, name=None)
</code></pre>

<p><code>shape=None</code> means that tensor of nay shape will be accepted as value for placeholder. Note: <strong><code>shape=None</code> is easy to construct graphs, but nightmarish for debugging</strong>.</p>

<p>To make <code>shape</code>  flexible, <code>None</code> can be used in the <code>shape</code> argument:</p>

<pre><code>    X = tf.placeholder(dtype=tf.float32, shape=[n_x, None], name=&#39;X&#39;)
</code></pre>

<h3 id="toc_16">Lazy loading</h3>

<p><code>Lazy loading</code> means defer creating/initializing an object until it is needed.</p>

<p>Normal loading:</p>

<pre><code class="language-python">g = tf.Graph()
with g.as_default():
    x = tf.Variable(10, name=&#39;x&#39;)
    y = tf.Variable(20, name=&#39;y&#39;)
    z = tf.add(x,y) # you create the node for add node before executing the graph

    with tf.Session() as sess:
        sess.run(tf.global_variables_initializer())
        for _ in range(10):
            sess.run(z)

</code></pre>

<p>Lazy loading:</p>

<pre><code class="language-python">g = tf.Graph()
with g.as_default():
    x = tf.Variable(10, name=&#39;x&#39;)
    y = tf.Variable(20, name=&#39;y&#39;)

    with tf.Session() as sess:
        sess.run(tf.global_variables_initializer())
        writer = tf.summary.FileWriter(&#39;./my_graph/12&#39;, sess.graph)
        for _ in range(10):
            sess.run(tf.add(x,y)) # someone decides to be clever to save one line of code
        writer.close()
</code></pre>

<p>Note: In Lazy loading, Node <code>ADD</code> added 10 times to the graph definition. Image you want to compute an operations thousands of times, you graph gets bloated slow to load, and expensive to pass around.</p>

<p><strong>Solution</strong>: </p>

<ol>
<li>Separate definition of ops from computing/running ops</li>
<li>Use Python property to ensure function is also loaded once the first time it is called.</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting started with TensorFlow]]></title>
    <link href="http://larryim.cc/getting_started_with_tensorflow.html"/>
    <updated>2017-08-22T11:53:38+08:00</updated>
    <id>http://larryim.cc/getting_started_with_tensorflow.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">TensorFlow Core tutorial</a>
<ul>
<li>
<a href="#toc_1">importing TensorFlow</a>
</li>
<li>
<a href="#toc_2">The Computational Graph</a>
</li>
</ul>
</li>
<li>
<a href="#toc_3">tf.train API</a>
<ul>
<li>
<a href="#toc_4">Complete program</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">tf.estimator</a>
<ul>
<li>
<a href="#toc_6">Basic usage</a>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">TensorFlow Core tutorial</h2>

<h3 id="toc_1">importing TensorFlow</h3>

<pre><code class="language-python">import tensorflow as tf
</code></pre>

<h3 id="toc_2">The Computational Graph</h3>

<p>A <code>computational graph</code> is a series of TensorFlow operations arranged into a graph of nodes. Let&#39;s build a simple computational graph. Each node takes zero or more tensors as inputs and produces a tensor as an output. One type of node is a constant. Like all TensorFlow constant, it takes no inputs, and it outputs a value it stores internally. We can create two floating point Tensor <code>node1</code> and <code>node2</code> as follows:</p>

<pre><code class="language-python">node1 = tf.constant(3.0, dtype=tf.float32)
node2 = tf.constant(4.0) # also tf.float32 implicitly
print(node1, node2)
</code></pre>

<pre><code>Tensor(&quot;Const:0&quot;, shape=(), dtype=float32)
Tensor(&quot;Const_1:0&quot;, shape=(), dtype=float32)
</code></pre>

<p>To produce output values for <code>node1</code> and <code>nodes2</code>, evaluation is needed. To actually evaluate the nodes, we must run the computational graph within a <code>session</code>. A session encapsulates the control and state of the Tensorflow runtime.</p>

<p>The following code creates a <code>Session</code> object and then invokes its <code>run</code> method to run enough of the computational graph to evaluate <code>node1</code> and <code>node2</code>. By running the computational graph in a session as follows:</p>

<pre><code class="language-python">sess = tf.Session()
print(sess.run([node1, node2]))
</code></pre>

<pre><code>[3.0, 4.0]
</code></pre>

<p>We can build more complicated computations by combining <code>Tensor</code> nodes with operations(Operations are also nodes). For example, we can add our two constant nodes and produce a new graph as follows:</p>

<pre><code class="language-python">node3 = tf.add(node1, node2)
print(&#39;node3:&#39;, node3)
print(&#39;sess.run(node3):&#39;, sess.run(node3))
</code></pre>

<pre><code>node3: Tensor(&quot;Add:0&quot;, shape=(), dtype=float32)
sess.run(node3): 7.0
</code></pre>

<p>TensorFlow provides a utility called <code>TensorBoard</code> that can display a picture of the computational graph. Here is a screenshot showing how <code>TensorBoard</code> visualizes the graph:<br/>
<img src="media/15033740189206/getting_started_add.png" alt=""/></p>

<p>As it stands, this graph is not especially interesting because it always produces a constant result. A graph can be parameterized to accept external inputs, known as <code>placeholders</code>. A <code>placeholder</code> is a promise to provide a value later.</p>

<pre><code class="language-python">a = tf.placeholder(tf.float32)
b = tf.placeholder(tf.float32)
adder_node = a + b # + provides a shortcut for tf.add(a,b)
</code></pre>

<p>The preceding three lines are a bit like a function or a lambda in which we define two input parameters (a and b) and then an operation on them. We can evaluate this graph with multiple inputs by using the feed_dict argument to the <code>run method</code> to feed concrete values to the placeholder:</p>

<pre><code class="language-python">print(sess.run(adder_node, {a:3, b:4.5}))
print(sess.run(adder_node, {a:[1,3], b:[2,4]}))
</code></pre>

<pre><code>7.5
[ 3.  7.]
</code></pre>

<p>In <code>TensorBoard</code>, the graph looks like this:</p>

<p><img src="media/15033740189206/getting_started_adder.png" alt=""/></p>

<p>We can make the computational graph more complex by adding another operation. For example,</p>

<pre><code class="language-python">add_and_triple = adder_node * 3.
print(sess.run(add_and_triple,{a:3, b:4.5}))
</code></pre>

<pre><code>22.5
</code></pre>

<p>The preceding computational graph would look as follows in <code>TensorBoard</code>:<br/>
<img src="media/15033740189206/getting_started_triple.png" alt=""/></p>

<p>In machine learning we will typically want a model that can take arbitrary inputs, such as the one above. To make the model trainable, we need to be able to modify the graph to get new outputs with the same input. <code>variables</code> allow us to add trainable parameters to a graph. They are constructed with a type and initial value:</p>

<pre><code class="language-python">W = tf.Variable([.3], dtype=tf.float32)
b = tf.Variable([-.3], dtype=tf.float32)
x = tf.placeholder(tf.float32)
linear_model = W*x +b 
</code></pre>

<p>Constants are initialized when you call <code>tf.constant</code>, and their value can never change. By contrast, variables are not initialized when you call <code>tf.Variable</code>. To initialize all the variables in a TensorFlow program, you must explicitly call a special operation as follows:</p>

<pre><code class="language-python">init = tf.global_variables_initializer()
sess.run(init)
</code></pre>

<p>It is important to realize <code>init</code> is a handle to the TensorFlow sub-graph that initializes all the global variables. Until we call <code>sess.run</code>, the variables are uninitialized.</p>

<p>Since <code>x</code> is a placeholder, we can evaluate <code>linear_model</code> for several values of <code>x</code> simultaneously as follows:</p>

<pre><code class="language-python">print(sess.run(linear_model,{x:[1,2,3,4]}))
</code></pre>

<pre><code>[ 0.          0.30000001  0.60000002  0.90000004]
</code></pre>

<p>We&#39;ve create a model, but we don&#39;t know how good it is yet. To evaluate the model on training data, we need a <code>y</code> placeholder to provide the desired values, and we need to write a loss function.</p>

<p>A <code>loss function</code> measures how far apart the current model is from the provided data. We&#39;ll use a standard loss model for linear regression, which sums the squares of the deltas between the current model and the provided data. <code>linear_model -y</code> creates a vector where each element is the corresponding example&#39;s error delta. We call <code>tf.square</code> to square that error. Then, we sum all the squared errors to create a single scalar that abstacts the error of all examples using <code>tf.reduce_sum</code>:</p>

<pre><code class="language-python">y = tf.placeholder(tf.float32)
squared_deltas = tf.square(linear_model - y)
loss = tf.reduce_sum(squared_deltas)
print(sess.run(loss, {x:[1,2,3,4], y:[0,-1,-2,-3]}))
</code></pre>

<pre><code>23.66
</code></pre>

<p>We could improve this manually by reassigning the values of <code>W</code> and <code>b</code> to the perfect values of -1 and 1. A variable is initialized to the value provided to <code>tf.Variable</code> but can be changed using operations like <code>tf.assign</code>. FOr example, <code>W=-1</code> and <code>b=1</code> are the optimal parameters for our model. We can change <code>W</code> and <code>b</code> accordingly:</p>

<pre><code class="language-python">fixW = tf.assign(W, [-1.])
fixb = tf.assign(b, [1.])
sess.run([fixW, fixb])
print(sess.run(loss, {x:[1,2,3,4], y:[0,-1,-2,-3]}))
</code></pre>

<pre><code>0.0
</code></pre>

<p>We guessed the &quot;perfect&quot; values of <code>W</code> and <code>b</code>, but the whole point of machine learning is to find the correct model parameters automatically. We will show how to accomplish this in the next section.</p>

<h2 id="toc_3">tf.train API</h2>

<p>A complete discussion of machine learning is out of the scope of this tutorial. However, TensorFlow provides <code>optimizers</code> that slowly change each variable in order to minimize the loss function. The simplest optimizer is <code>gradient descent</code>. It modifies each variable according to the magnitude of the derivative of loss with respect to that variable. In general, computing symbolic derivatives manually is tedious and error-prone. Consequently, <code>TensorFlow</code> can automatically produce derivatives given only a description of the model using the function <code>tf.gradients</code>. For simplicity, <code>optimizers</code> typically do this for you. For example,</p>

<pre><code class="language-python">optimizer = tf.train.GradientDescentOptimizer(0.01)
train = optimizer.minimize(loss)

sess.run(init) # reset values to incorrect defaults
for i in range(1000):
    sess.run(train, {x:[1,2,3,4], y:[0,-1,-2,-3]})
print(sess.run([W,b]))
</code></pre>

<pre><code>[array([-0.9999969], dtype=float32), array([ 0.99999082], dtype=float32)]
</code></pre>

<p>Now we have done actual machine learning! Although doing this simple linear regression doesn&#39;t require much TensorFlow core code, more complicated models and methods to feed data into your model necessitate more code. Thus TensorFlow provides higher level abstractions for common patterns, structures, and functionality. We will learn how to use some of these abstractions in the next section.</p>

<h3 id="toc_4">Complete program</h3>

<pre><code class="language-python">import tensorflow as tf

# Model parameters
W = tf.Variable([.3], dtype=tf.float32)
b = tf.Variable([-.3], dtype=tf.float32)
# Model input and output
x = tf.placeholder(tf.float32)
linear_model = W * x + b
y = tf.placeholder(tf.float32)

# loss
loss = tf.reduce_sum(tf.square(linear_model - y)) # sum of the squares
# optimizer
optimizer = tf.train.GradientDescentOptimizer(0.01)
train = optimizer.minimize(loss)

# training data
x_train = [1, 2, 3, 4]
y_train = [0, -1, -2, -3]
# training loop
init = tf.global_variables_initializer()
sess = tf.Session()
sess.run(init) # reset values to wrong
for i in range(1000):
  sess.run(train, {x: x_train, y: y_train})

# evaluate training accuracy
curr_W, curr_b, curr_loss = sess.run([W, b, loss], {x: x_train, y: y_train})
print(&quot;W: %s b: %s loss: %s&quot;%(curr_W, curr_b, curr_loss))
</code></pre>

<pre><code>W: [-0.9999969] b: [ 0.99999082] loss: 5.69997e-11
</code></pre>

<p>This more complicated program can still be visualized in TensorBoard:</p>

<p><img src="media/15033740189206/getting_started_final.png" alt=""/></p>

<h2 id="toc_5">tf.estimator</h2>

<p><code>tf.estimator</code> is a high-level TensorFlow library that simplifies the mechanics of machine learning, including the following:</p>

<ul>
<li>running training loops</li>
<li>running evaluation loops</li>
<li>managing data sets</li>
<li><code>tf.estimator</code> defines many common models.</li>
</ul>

<h3 id="toc_6">Basic usage</h3>

<p>Notice how much simpler the linear regression program becomes with <code>tf.estimator</code>:</p>

<pre><code class="language-python"># NumPy is often used to load, manipulate and preprocess data.
import numpy as np

# Declare list of features. We only have one numeric feature. There are many
# other types of columns that are more complicated and useful.
feature_columns = [tf.feature_column.numeric_column(&quot;x&quot;, shape=[1])]

# An estimator is the front end to invoke training (fitting) and evaluation
# (inference). There are many predefined types like linear regression,
# linear classification, and many neural network classifiers and regressors.
# The following code provides an estimator that does linear regression.
estimator = tf.estimator.LinearRegressor(feature_columns=feature_columns)

# TensorFlow provides many helper methods to read and set up data sets.
# Here we use two data sets: one for training and one for evaluation
# We have to tell the function how many batches
# of data (num_epochs) we want and how big each batch should be.
x_train = np.array([1., 2., 3., 4.])
y_train = np.array([0., -1., -2., -3.])
x_eval = np.array([2., 5., 8., 1.])
y_eval = np.array([-1.01, -4.1, -7, 0.])
input_fn = tf.estimator.inputs.numpy_input_fn(
    {&quot;x&quot;: x_train}, y_train, batch_size=4, num_epochs=None, shuffle=True)
train_input_fn = tf.estimator.inputs.numpy_input_fn(
    {&quot;x&quot;: x_train}, y_train, batch_size=4, num_epochs=1000, shuffle=False)
eval_input_fn = tf.estimator.inputs.numpy_input_fn(
    {&quot;x&quot;: x_eval}, y_eval, batch_size=4, num_epochs=1000, shuffle=False)

# We can invoke 1000 training steps by invoking the  method and passing the
# training data set.
estimator.train(input_fn=input_fn, steps=1000)

# Here we evaluate how well our model did.
train_metrics = estimator.evaluate(input_fn=train_input_fn)
eval_metrics = estimator.evaluate(input_fn=eval_input_fn)
print(&quot;train metrics: %r&quot;% train_metrics)
print(&quot;eval metrics: %r&quot;% eval_metrics)
</code></pre>

<pre><code>INFO:tensorflow:Using default config.
WARNING:tensorflow:Using temporary folder as model directory: /var/folders/66/y1hc77j572v71r0gm2r39rfr0000gn/T/tmp2rnith_a
INFO:tensorflow:Using config: {&#39;_model_dir&#39;: &#39;/var/folders/66/y1hc77j572v71r0gm2r39rfr0000gn/T/tmp2rnith_a&#39;, &#39;_tf_random_seed&#39;: 1, &#39;_save_summary_steps&#39;: 100, &#39;_save_checkpoints_secs&#39;: 600, &#39;_save_checkpoints_steps&#39;: None, &#39;_session_config&#39;: None, &#39;_keep_checkpoint_max&#39;: 5, &#39;_keep_checkpoint_every_n_hours&#39;: 10000, &#39;_log_step_count_steps&#39;: 100}
INFO:tensorflow:Create CheckpointSaverHook.
INFO:tensorflow:Saving checkpoints for 1 into /var/folders/66/y1hc77j572v71r0gm2r39rfr0000gn/T/tmp2rnith_a/model.ckpt.
INFO:tensorflow:loss = 19.0, step = 1
INFO:tensorflow:global_step/sec: 592.325
INFO:tensorflow:loss = 0.192443, step = 101 (0.171 sec)
INFO:tensorflow:global_step/sec: 710.314
INFO:tensorflow:loss = 0.0370785, step = 201 (0.141 sec)
INFO:tensorflow:global_step/sec: 669.791
INFO:tensorflow:loss = 0.0173565, step = 301 (0.150 sec)
INFO:tensorflow:global_step/sec: 729.609
INFO:tensorflow:loss = 0.00361388, step = 401 (0.136 sec)
INFO:tensorflow:global_step/sec: 814
INFO:tensorflow:loss = 0.000215951, step = 501 (0.123 sec)
INFO:tensorflow:global_step/sec: 793.172
INFO:tensorflow:loss = 0.0001734, step = 601 (0.127 sec)
INFO:tensorflow:global_step/sec: 776.415
INFO:tensorflow:loss = 3.66416e-05, step = 701 (0.128 sec)
INFO:tensorflow:global_step/sec: 845.781
INFO:tensorflow:loss = 3.03422e-06, step = 801 (0.118 sec)
INFO:tensorflow:global_step/sec: 849.689
INFO:tensorflow:loss = 1.18453e-06, step = 901 (0.118 sec)
INFO:tensorflow:Saving checkpoints for 1000 into /var/folders/66/y1hc77j572v71r0gm2r39rfr0000gn/T/tmp2rnith_a/model.ckpt.
INFO:tensorflow:Loss for final step: 3.72255e-07.
INFO:tensorflow:Starting evaluation at 2017-08-21-05:57:38
INFO:tensorflow:Restoring parameters from /var/folders/66/y1hc77j572v71r0gm2r39rfr0000gn/T/tmp2rnith_a/model.ckpt-1000
INFO:tensorflow:Finished evaluation at 2017-08-21-05:57:40
INFO:tensorflow:Saving dict for global step 1000: average_loss = 6.05797e-08, global_step = 1000, loss = 2.42319e-07
INFO:tensorflow:Starting evaluation at 2017-08-21-05:57:40
INFO:tensorflow:Restoring parameters from /var/folders/66/y1hc77j572v71r0gm2r39rfr0000gn/T/tmp2rnith_a/model.ckpt-1000
INFO:tensorflow:Finished evaluation at 2017-08-21-05:57:42
INFO:tensorflow:Saving dict for global step 1000: average_loss = 0.00254753, global_step = 1000, loss = 0.0101901
train metrics: {&#39;average_loss&#39;: 6.057968e-08, &#39;loss&#39;: 2.4231872e-07, &#39;global_step&#39;: 1000}
eval metrics: {&#39;average_loss&#39;: 0.0025475256, &#39;loss&#39;: 0.010190102, &#39;global_step&#39;: 1000}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What is a tensorflow session?]]></title>
    <link href="http://larryim.cc/what_is_a_tensorflow_session.html"/>
    <updated>2017-08-22T11:52:07+08:00</updated>
    <id>http://larryim.cc/what_is_a_tensorflow_session.html</id>
    <content type="html"><![CDATA[
<p>by <a href="http://danijar.com/what-is-a-tensorflow-session/">Danijar Hafner</a>, modified by <a href="http://larryim.cc">larry</a></p>

<p>I‚Äôve seen a lot of confusion over the rules of <code>tf.Graph</code> and <code>tf.Session</code> in TensorFlow. It‚Äôs simple:</p>

<ul>
<li>A <code>graph</code> defines the computation. It doesn‚Äôt compute anything, it doesn‚Äôt hold any values, it just defines the operations that you specified in your code.</li>
<li>A <code>session</code> allows you to execute graphs or part of graphs. It allocates resources (on one or more machines) for that and holds the actual values of intermediate results and variables.</li>
</ul>

<p>Let‚Äôs look at an example.</p>

<h3 id="toc_0">Defining the Graph</h3>

<p>We define a graph with a variable and three operations: <code>x</code> returns the current value of our variable. <code>init</code> assigns the initial value of 42 to that variable. <code>x_assign</code> assigns the new value of 13 to that variable.</p>

<pre><code class="language-python">import tensorflow as tf
graph = tf.Graph()
with graph.as_default():
  x = tf.Variable(42, name=&#39;foo&#39;)
  init = tf.global_variables_initializer()
  x_assign = x.assign(13)
</code></pre>

<p>On a side note: TensorFlow creates a default graph for you, so we don‚Äôt need the first two lines of the code above. The default graph is also what the sessions in the next section use when not manually specifying a graph.</p>

<h3 id="toc_1">Running Computations in a Session</h3>

<p>To run any of the three defined operations, we need to create a session for that graph. The session will also allocate memory to store the current value of the variable.</p>

<pre><code class="language-python">with tf.Session(graph=graph) as sess:
  sess.run(init)
  sess.run(x_assign)
  print(sess.run(x))
</code></pre>

<pre><code>13
</code></pre>

<p>As you can see, the value of our variable is only valid within one session. If we try to query the value afterwards in a second session, TensorFlow will raise an error because the variable is not initialized there.</p>

<pre><code class="language-python">with tf.Session(graph=graph) as sess:
  print(sess.run(x))
# Error: Attempting to use uninitialized value foo

</code></pre>

<p>Of course, we can use the graph in more than one session, we just have to initialize the variables again. The values in the new session will be completely independent from the first one:</p>

<pre><code class="language-python">with tf.Session(graph=graph) as sess:
  sess.run(init)
  print(sess.run(x))
</code></pre>

<pre><code>42
</code></pre>

<p>Hopefully this short workthrough helped you to better understand <code>tf.Session</code>. </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bit manipulation (2)]]></title>
    <link href="http://larryim.cc/bit_manipulation_2.html"/>
    <updated>2017-08-17T11:21:12+08:00</updated>
    <id>http://larryim.cc/bit_manipulation_2.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">‰∏ãÈù¢Âàó‰∏æ‰∫Ü‰∏Ä‰∫õÂ∏∏ËßÅÁöÑ‰∫åËøõÂà∂‰ΩçÁöÑÂèòÊç¢Êìç‰Ωú„ÄÇ</h2>

<table>
<thead>
<tr>
<th>ÂäüËÉΩ</th>
<th>Á§∫‰æã</th>
<th>‰ΩçËøêÁÆó</th>
</tr>
</thead>

<tbody>
<tr>
<td>ÂéªÊéâÊúÄÂêé‰∏Ä‰Ωç</td>
<td>(101101-&gt;10110)</td>
<td>x &gt;&gt; 1</td>
</tr>
<tr>
<td>Âú®ÊúÄÂêéÂä†‰∏Ä‰∏™0</td>
<td>(101101-&gt;1011010)</td>
<td>x &gt;&gt; 1</td>
</tr>
<tr>
<td>Âú®ÊúÄÂêéÂä†‰∏Ä‰∏™1</td>
<td>(101101-&gt;1011011)</td>
<td>x &lt;&lt; 1+1</td>
</tr>
<tr>
<td>ÊääÊúÄÂêé‰∏Ä‰ΩçÂèòÊàê1</td>
<td>(101100-&gt;101101)</td>
<td>x or 1</td>
</tr>
<tr>
<td>ÊääÊúÄÂêé‰∏Ä‰ΩçÂèòÊàê0</td>
<td>(101101-&gt;101100)</td>
<td>x or 1-1</td>
</tr>
<tr>
<td>ÊúÄÂêé‰∏Ä‰ΩçÂèñÂèç</td>
<td>(101101-&gt;101100)</td>
<td>x xor 1</td>
</tr>
<tr>
<td>ÊääÂè≥Êï∞Á¨¨k‰ΩçÂèòÊàê1</td>
<td>(101001-&gt;101101,k=3)</td>
<td>x or (1 &lt;&lt; (k-1))</td>
</tr>
<tr>
<td>ÊääÂè≥Êï∞Á¨¨k‰ΩçÂèòÊàê0</td>
<td>(101101-&gt;101001,k=3)</td>
<td>x and not (1 &lt;&lt; (k-1))</td>
</tr>
<tr>
<td>Âè≥Êï∞Á¨¨k‰ΩçÂèñÂèç</td>
<td>(101001-&gt;101101,k=3)</td>
<td>x xor (1 &lt;&lt; (k-1))</td>
</tr>
<tr>
<td>ÂèñÊú´‰∏â‰Ωç</td>
<td>(1101101-&gt;101)</td>
<td>x and 7</td>
</tr>
<tr>
<td>ÂèñÊú´k‰Ωç</td>
<td>(1101101-&gt;1101,k=5)</td>
<td>x and (1 &lt;&lt; k-1)</td>
</tr>
<tr>
<td>ÂèñÂè≥Êï∞Á¨¨k‰Ωç</td>
<td>(1101101-&gt;1,k=4)</td>
<td>x &gt;&gt; (k-1) and 1</td>
</tr>
<tr>
<td>ÊääÊú´k‰ΩçÂèòÊàê1</td>
<td>(101001-&gt;101111,k=4)</td>
<td>x or (1 &lt;&lt; k-1)</td>
</tr>
<tr>
<td>Êú´k‰ΩçÂèñÂèç</td>
<td>(101001-&gt;100110,k=4)</td>
<td>x xor (1 &lt;&lt; k-1)</td>
</tr>
<tr>
<td>ÊääÂè≥ËæπËøûÁª≠ÁöÑ1ÂèòÊàê0</td>
<td>(100101111-&gt;100100000)</td>
<td>x and (x+1)</td>
</tr>
<tr>
<td>ÊääÂè≥Ëµ∑Á¨¨‰∏Ä‰∏™0ÂèòÊàê1</td>
<td>(100101111-&gt;100111111)</td>
<td>x or (x+1)</td>
</tr>
<tr>
<td>ÊääÂè≥ËæπËøûÁª≠ÁöÑ0ÂèòÊàê1</td>
<td>(11011000-&gt;11011111)</td>
<td>x or (x-1)</td>
</tr>
<tr>
<td>ÂèñÂè≥ËæπËøûÁª≠ÁöÑ1</td>
<td>(100101111-&gt;1111)</td>
<td>(x xor (x+1)) &gt;&gt; 1</td>
</tr>
<tr>
<td>ÂéªÊéâÂè≥Ëµ∑Á¨¨‰∏Ä‰∏™1ÁöÑÂ∑¶Ëæπ</td>
<td>(100101000-&gt;1000)</td>
<td>x and (x xor (x-1))</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bit manipulation]]></title>
    <link href="http://larryim.cc/bit_manipulation.html"/>
    <updated>2017-08-16T21:07:38+08:00</updated>
    <id>http://larryim.cc/bit_manipulation.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">136. Single Number</h2>

<p><a href="https://leetcode.com/problems/single-number/description/">LeetCode Single Number</a></p>

<p>Given an array of integers, every element appears <em>twice</em> except for one. Find that single one.</p>

<p><strong>Note</strong>:<br/><br/>
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>

<p><code>^</code>(<code>xor</code>, <code>Exclusive or</code>):  outputs true whenever the inputs differ:</p>

<pre><code class="language-python">0 ^ 0 = 0 
n ^ 0 = n 
n ^ n = 0
</code></pre>

<p><strong>Solution</strong>:</p>

<pre><code class="language-python">class Solution(object):
    def singleNumber(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        n = 0
        for num in nums:
            n = n^num
        return n     
</code></pre>

<h2 id="toc_1">137 Single Number II</h2>

<p>Given an array of integers, every element appears <em>three</em> times except for one, which appears exactly once. Find that single one.</p>

<p><strong>Note</strong>:<br/>
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Thread]]></title>
    <link href="http://larryim.cc/15028699473698.html"/>
    <updated>2017-08-16T15:52:27+08:00</updated>
    <id>http://larryim.cc/15028699473698.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Process]]></title>
    <link href="http://larryim.cc/15028699346565.html"/>
    <updated>2017-08-16T15:52:14+08:00</updated>
    <id>http://larryim.cc/15028699346565.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python GIL]]></title>
    <link href="http://larryim.cc/python_GIL_global_interpreter_lock.html"/>
    <updated>2017-08-16T15:31:02+08:00</updated>
    <id>http://larryim.cc/python_GIL_global_interpreter_lock.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">An example</a>
</li>
<li>
<a href="#toc_1">Introduction</a>
<ul>
<li>
<a href="#toc_2">Visualization:</a>
</li>
<li>
<a href="#toc_3">Cooperative Multitasking</a>
</li>
<li>
<a href="#toc_4">Preemptive Multitasking</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">Ëß£ÂÜ≥ÂäûÊ≥ï</a>
<ul>
<li>
<a href="#toc_6">Áî®<code>multiprocessing</code>Êõø‰ª£<code>Thread</code></a>
</li>
<li>
<a href="#toc_7">Âà©Áî®<code>ctypes</code>ÁªïËøá<code>GIL</code></a>
</li>
</ul>
</li>
<li>
<a href="#toc_8">Reference</a>
</li>
</ul>


<h2 id="toc_0">An example</h2>

<p>In the following Python program, it seems that the program may reach 100% CPU usuage. In fact, it takes only 50% of CPU resources.</p>

<pre><code class="language-python">import threading


# Â≠êÁ∫øÁ®ãÊ≠ªÂæ™ÁéØ
def test():
    while True:
        pass


t1 = threading.Thread(target=test)
t1.start()

# ‰∏ªÁ∫øÁ®ãÊ≠ªÂæ™ÁéØ
while True:
    pass
</code></pre>

<h2 id="toc_1">Introduction</h2>

<p>PythonÂÖ®Â±ÄËß£ÈáäÂô®ÈîÅ(<code>Global Interpreter Lock</code>)ÊòØÁî®‰∫éÂêåÊ≠•Á∫øÁ®ãÁöÑ‰∏ÄÁßçÊú∫Âà∂ÔºåÂÆÉ‰ΩøÂæó‰ªª‰ΩïÊó∂Âàª‰ªÖÊúâ‰∏Ä‰∏™Á∫øÁ®ãÂú®ÊâßË°å„ÄÇ‰∏äÈù¢‰æãÂ≠ê‰∏≠ËôΩÁÑ∂‰∏§‰∏™Á∫øÁ®ãÊòØÊ≠ªÂæ™ÁéØÔºåËÄå‰∏îÊúâ‰∏§‰∏™Áâ©ÁêÜCPUÂÜÖÊ†∏Ôºå‰ΩÜÂõ†‰∏∫ <code>GIL</code>ÁöÑÈôêÂà∂Ôºå‰∏§‰∏™Á∫øÁ®ãÂè™ÊòØÂÅöÁùÄÂàÜÊó∂ÂàáÊç¢ÔºåÊÄªÁöÑCPUÂç†Áî®ÁéáËøòÁï•‰Ωé‰∫é50ÔºÖ„ÄÇ</p>

<p><strong>Note: One thread runs Python, while N others sleep or await I/O</strong></p>

<h3 id="toc_2">Visualization:</h3>

<p>All of those red regions indicate times where the operating system has scheduled a Python thread on one of the cores, but it can&#39;t run because the thread on the other core is holding it.</p>

<p><img src="media/15028686628076/15028730462252.png" alt="demo for GIL"/><br/>
<img src="media/15028686628076/15028733300914.png" alt=""/></p>

<h3 id="toc_3">Cooperative Multitasking</h3>

<p>When it begins a task, such as network I/O, that is of long or uncertain duration and does not require running any Python code, a thread relinquishes the <code>GIL</code> so another thread can take it and run Python. This polite conduct is called <code>cooperative multitasking</code>(ÂçèÂêåÂºèÂ§ö‰ªªÂä°Â§ÑÁêÜ), and it allows concurrency; many threads can wait for different events at the same time.</p>

<p>For <code>cooperative multitasking</code>, processes voluntarily yield control periodically or when idle in order to enable multiple applications to be run simultaneously. All programs must cooperate for the entire scheduling scheme to work.</p>

<p>Say that two threads each connect a <code>socket</code>:</p>

<pre><code class="language-python">def do_connect():
    s = socket.socket()
    s.connect((&#39;python.org&#39;, 80))  # drop the GIL

for i in range(2):
    t = threading.Thread(target=do_connect)
    t.start()
</code></pre>

<p>Only one of these two threads can execute Python at a time, but once the thread has begun connecting, it drops the GIL so the other thread can run. This means that both threads could be waiting for their sockets to connect concurrently, which is a good thing. They can do more work in the same amount of time.</p>

<p>Let&#39;s try to open the box and see how a Python thread actually drops the GIL while it waits for a connection to be established, in <code>socketmodule.c</code>:</p>

<pre><code class="language-C">/* s.connect((host, port)) method */
static PyObject *
sock_connect(PySocketSockObject *s, PyObject *addro)
{
    sock_addr_t addrbuf;
    int addrlen;
    int res;

    /* convert (host, port) tuple to C address */
    getsockaddrarg(s, addro, SAS2SA(&amp;addrbuf), &amp;addrlen);

    Py_BEGIN_ALLOW_THREADS
    res = connect(s-&gt;sock_fd, addr, addrlen);
    Py_END_ALLOW_THREADS

    /* error handling and so on .... */
}
</code></pre>

<p>The <code>Py_BEGIN_ALLOW_THREADS</code> macro is where the thread drops the <code>GIL</code>; it is defined simply as:</p>

<pre><code>PyThread_release_lock(interpreter_lock);
</code></pre>

<p>And of course <code>Py_END_ALLOW_THREADS</code> reacquires the lock. A thread might block at this spot, waiting for another thread to release the lock; once that happens, the waiting thread grabs the GIL back and resumes executing your Python code. In short: While N threads are blocked on network I/O or waiting to reacquire the <code>GIL</code>, one thread can run Python.</p>

<p>Let&#39;s contrast cooperative multitasking with the other kind of multitasking.</p>

<h3 id="toc_4">Preemptive Multitasking</h3>

<p>A Python thread can voluntarily release the <code>GIL,</code> but it can also have the GIL seized from it preemptively(<code>Preemptive multitasking</code>, Êä¢Âç†ÂºèÂ§ö‰ªªÂä°Â§ÑÁêÜ).</p>

<p>Let&#39;s back up and talk about how Python is executed. Your program is run in two stages. First, your Python program is compiled into a simpler binary format called <code>bytecode</code>. Second, the Python interpreter&#39;s main loop, a function mellifluously named <code>PyEval_EvalFrameEx()</code>, reads the <code>bytecode</code> and executes the instructions in it one by one.</p>

<p>While the interpreter steps through your<code>bytecode</code> it periodically drops the <code>GIL</code>, without asking permission of the thread whose code it is executing, so other threads can run:</p>

<pre><code class="language-C">for (;;) {
    if (--ticker &lt; 0) {
        ticker = check_interval;
    
        /* Give another thread a chance */
        PyThread_release_lock(interpreter_lock);
    
        /* Other threads may run now */
    
        PyThread_acquire_lock(interpreter_lock, 1);
    }

    bytecode = *next_instr++;
    switch (bytecode) {
        /* execute the next instruction ... */ 
    }
}
</code></pre>

<p>By default the check interval is 1000 <code>bytecodes</code>. All threads run this same code and have the lock taken from them periodically in the same way. In Python 3 the GIL&#39;s implementation is more complex, and the check interval is not a fixed number of <code>bytecodes</code>, but 15 milliseconds. For your code, however, these differences are not significant.</p>

<h2 id="toc_5">Ëß£ÂÜ≥ÂäûÊ≥ï</h2>

<h3 id="toc_6">Áî®<code>multiprocessing</code>Êõø‰ª£<code>Thread</code></h3>

<p>Âà©Áî®<code>multiprocessing</code>Ê®°ÂùóÔºåÂèØ‰ª•ÂæàÊñπ‰æøÁöÑÂ§ÑÁêÜ„ÄÇ‰ΩÜËøõÁ®ã‰ºöÂ¢ûÂä†Á®ãÂ∫èÂÆûÁé∞Êó∂Á∫øÁ®ãÈó¥Êï∞ÊçÆÈÄöËÆØÂíåÂêåÊ≠•ÁöÑÂõ∞Èöæ„ÄÇ</p>

<h3 id="toc_7">Âà©Áî®<code>ctypes</code>ÁªïËøá<code>GIL</code></h3>

<p><code>ctypes</code>ÂèØ‰ª•ËÆ©Python Êé•Ë∞ÉÁî®‰ªªÊÑèÁöÑCÂä®ÊÄÅÂ∫ìÁöÑÂØºÂá∫ÂáΩÊï∞„ÄÇ</p>

<pre><code class="language-python">from ctypes import *
from threading import Thread

#Âä†ËΩΩÂä®ÊÄÅÂ∫ì
lib = cdll.LoadLibrary(&quot;./libdeadloop.so&quot;)

#ÂàõÂª∫‰∏Ä‰∏™Â≠êÁ∫øÁ®ãÔºåËÆ©ÂÖ∂ÊâßË°åÔΩÉËØ≠Ë®ÄÁºñÂÜôÁöÑÂáΩÊï∞ÔºåÊ≠§ÂáΩÊï∞ÊòØ‰∏Ä‰∏™Ê≠ªÂæ™ÁéØ
t = Thread(target=lib.DeadLoop)
t.start()

#‰∏ªÁ∫øÁ®ãÔºå‰πüË∞ÉÁî®ÔΩÉËØ≠Ë®ÄÁºñÂÜôÁöÑÈÇ£‰∏™Ê≠ªÂæ™ÁéØÂáΩÊï∞
#lib.DeadLoop()

while True:
    pass
</code></pre>

<h2 id="toc_8">Reference</h2>

<ul>
<li><a href="https://opensource.com/article/17/4/grok-gil">Grok the GIL: How to write fast and thread-safe Python</a></li>
<li><a href="http://www.dabeaz.com/GIL/">Understanding the Python GIL, David Beazley</a></li>
<li><a href="https://en.wikipedia.org/wiki/Cooperative_multitasking">Cooperative multitasking WEKIPEDIA</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python and MySQL]]></title>
    <link href="http://larryim.cc/python_and_mysql.html"/>
    <updated>2017-08-14T15:06:58+08:00</updated>
    <id>http://larryim.cc/python_and_mysql.html</id>
    <content type="html"><![CDATA[
<p>There are a lot of python driver available for MySQL and two stand out the most. The one, traditionally everybody‚Äôs choice, sort of industrial standard <code>MySQLdb</code>. It uses a C module to link to MySQL‚Äôs client library.  For Python3, use <code>PyMySQL</code> instead, because <code>MySQLdb</code> don&#39;t support Python3. Oracle‚Äôs <code>mysql-connector</code> on the other hand is pure python so no MySQL libraries and no compilation is necessary.</p>

<h2 id="toc_0">MySQL Connector/Python</h2>

<p>To use Python with MySQL, you can use the MySQL Connector/Python (<a href="https://dev.mysql.com/downloads/connector/python/">Download Here</a>). For those with anaconda, just install with <code>conda</code>:</p>

<pre><code>conda install -c anaconda mysql-connector-python 
</code></pre>

<p>MySQL Connector/Python includes support for:</p>

<ul>
<li>Almost all features provided by MySQL Server.</li>
<li>Converting parameter values back and forth between Python and MySQL data types.</li>
<li>All MySQL extensions to standard SQL syntax.</li>
</ul>

<pre><code class="language-python">import re
import mysql.connector

# establishes the connection to MySQL.
cnx = mysql.connector.connect(user=&#39;root&#39;, password=&#39;8032804254qq&#39;,
                              host=&#39;127.0.0.1&#39;, database=&#39;rookery&#39;, port=&#39;3306&#39;)

# creates a cursor object (cur) to use for executing queries on the database.


cur = cnx.cursor(buffered=True)

# query mysql database for list of user accounts
sql_stmnt = &quot;SELECT DISTINCT User, Host FROM mysql.db &quot;
sql_stmnt += &quot;WHERE Db IN(&#39;rookery&#39;,&#39;birdwatchers&#39;) &quot;
sql_stmnt += &quot;ORDER BY User, Host&quot;
cur.execute(sql_stmnt)

# loop through list of user accounts
for user_accounts in cur.fetchall():
    user_name = user_accounts[0]
    host_address = user_accounts[1]
    user_account = user_name.decode(&#39;utf-8&#39;) + &quot;@&quot; + host_address.decode(&#39;utf-8&#39;)

# display user account heading
print(&#39;User Account:&#39;, (user_name, host_address))
print(&quot;------------------------------------------&quot;)

# query mysql for grants for user account
sql_stmnt = &quot;show grants for &quot; + user_account
cur.execute(sql_stmnt)

# loop through grant entries for user account
for grants in cur.fetchall():
    # skip &#39;usage&#39; entry
    if re.search(&#39;USAGE&#39;, grants[0]):
        continue
    # extract name of database and table
    dbtb = re.search(&#39;ON\s(.*)\.+?(.+?)\sTO&#39;, grants[0])
    db = dbtb.group(1)
    tb = dbtb.group(2)

    # change wildcard for tables to &#39;all&#39;
    if re.search(&#39;\*&#39;, tb): tb = &quot;all&quot;

    # display database and table name for privileges
    print(&quot;database: &quot;, db, &quot;table: &quot;, tb)

    # extract and display privileges for user account # for database and table
    privs = re.search(&#39;GRANT\s(.+?)\sON&#39;, grants[0])
    print(&#39;privileges: &#39;, privs.group(1))

cur.close()
cnx.close()
</code></pre>

<h2 id="toc_1">PyMySQL</h2>

<p><a href="https://github.com/PyMySQL/PyMySQL">PyMySQL</a> is to be a drop-in replacement for <code>MySQLdb</code> and work on <code>CPython</code>, <code>PyPy</code> and <code>IronPython</code>.</p>

<h3 id="toc_2">Installation</h3>

<pre><code class="language-bash">$ pip install PyMySQL
</code></pre>

<h3 id="toc_3">Example</h3>

<pre><code class="language-python">import pymysql

# connect to the datacase
connection = pymysql.connect(host=&#39;localhost&#39;, user=&#39;root&#39;, password=&#39;8032804254qq&#39;, db=&#39;test&#39;)

with connection.cursor() as cursor:
    &quot;&quot;&quot;
    Create Table | CREATE TABLE `books` (
    `book_id` int(3) NOT NULL AUTO_INCREMENT,
    `title` text DEFAULT NULL,
    `status` bit(1) DEFAULT b&#39;0&#39;,
    PRIMARY KEY (`book_id`)
    ) ENGINE=MyISAM AUTO_INCREMENT=103 DEFAULT CHARSET=utf8
    &quot;&quot;&quot;
    # create a new record
    sql = &quot;INSERT INTO `books` (`title`, `status`) VALUES (%s, %s)&quot;
    cursor.execute(sql, (&#39;GRE Reading&#39;, 1))
    
    # connection is not autocommit by default. So you must commit to save your changes.
    connection.commit()

with connection.cursor() as cursor:
    sql = &quot;select `book_id`, `title`, `status` from `books`&quot;
    cursor.execute(sql)
    # read records
    for book in cursor.fetchall():
        book = list(book)
        book[2] = ord(book[2])
        print(book)
</code></pre>

<h2 id="toc_4">Difference? which is better?</h2>

<p><code>MySQLdb</code> is a thin python wrapper around C module which implements API for MySQL database.</p>

<p><code>MySQL Connector</code>is a Python module that reimplements the <a href="https://www.python.org/dev/peps/pep-0249/"><code>MySQL Database API</code></a> in Python. It is written in Python and does not have any dependencies except for the Python Standard Library. It is slower, but does not require the C library and so is more portable.</p>

<h3 id="toc_5">Query Performance</h3>

<p>Obviously, <code>MySQLdb</code> has better performance, especially when it comes to large data sets.</p>

<p><img src="media/15026944183320/Untitled.png" alt="Untitled"/></p>

<h2 id="toc_6">Reference</h2>

<p>1.<a href="https://stackoverflow.com/questions/32575857/the-differences-between-mysqldb-and-mysqlconnector">The differences between MySQLdb and mysqlconnector</a><br/>
2.<a href="http://charlesnagy.info/it/python/python-mysqldb-vs-mysql-connector-query-performance">Python MySQLdb vs mysql-connector query performance</a><br/>
3. <a href="https://wiki.openstack.org/wiki/PyMySQL_evaluation">PyMySQL evaluation</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ÈÄªËæëÂà†Èô§]]></title>
    <link href="http://larryim.cc/15026939409542.html"/>
    <updated>2017-08-14T14:59:00+08:00</updated>
    <id>http://larryim.cc/15026939409542.html</id>
    <content type="html"><![CDATA[
<p><strong>ÈÄªËæëÂà†Èô§</strong>ÔºöÂΩìÊï∞ÊçÆÈùûÂ∏∏ÈáçË¶ÅÊó∂ÔºåÂú®ÂÆûÈôÖÊâßË°åÂà†Èô§Êìç‰ΩúÊó∂ÔºåÂè™ÊòØÂ∞ÜÊï∞ÊçÆÊ†áËÆ∞‰∏∫Âà†Èô§„ÄÇÂú®Êï∞ÊçÆÊü•ËØ¢Êìç‰ΩúÊó∂ÔºåÂä†‰∏äÊòØÂê¶Âà†Èô§ËØ≠Âè•„ÄÇ</p>

<pre><code class="language-SQL">mysql&gt; alter table birds add column isDelete bit default b&#39;0&#39;;
mysql&gt; update birds
    -&gt; set isDelete = b&#39;1&#39;
    -&gt; where bird_id = 101;
mysql&gt; select count(*)
    -&gt; from birds
    -&gt; where `isDelete` = 0;
+----------+
| count(*) |
+----------+
| 28890    |
+----------+
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Regular Expression in MySQL]]></title>
    <link href="http://larryim.cc/regular_expression_in_MySQL.html"/>
    <updated>2017-08-14T14:08:00+08:00</updated>
    <id>http://larryim.cc/regular_expression_in_MySQL.html</id>
    <content type="html"><![CDATA[
<p><code>MySQL</code> support pattern-matching operations performed with the <code>REGEXP</code> operator in SQL statements.</p>

<pre><code class="language-SQL">mysql &gt; select common_name as &#39;Birds Great and Small&#39;
      -&gt; from birds
      -&gt; where common_name regexp &#39;Least|Great&#39;
      -&gt; order by common_name desc
      -&gt; limit 10;

+-----------------------+
| Birds Great and Small |
+-----------------------+
| Least Tern            |
| Least Storm-Petrel    |
| Least Seedsnipe       |
| Least Sandpiper       |
| Least Pygmy-Owl       |
| Least Pauraque        |
| Least Nighthawk       |
| Least Honeyguide      |
| Least Grebe           |
| Least Flycatcher      |
+-----------------------+

</code></pre>

<p><code>REGEXP</code> Operator is case insensitive. If we want an expression to be case sensitive, we&#39;ll need to add the <code>Binary</code> option.</p>

<pre><code class="language-SQL">mysql &gt; select common_name as &#39;Hawks&#39;
      -&gt; from birds
      -&gt; where common_name regexp binary &#39;Hawk&#39;
      -&gt; and common_name not regexp &#39;Hawk-Owl&#39;
      -&gt; order by family_id
      -&gt; limit 10;
+------------------------+
| Hawks                  |
+------------------------+
| Ornate Hawk-Eagle      |
| Wallace&#39;s Hawk-Eagle   |
| Pinsker&#39;s Hawk-Eagle   |
| Philippine Hawk-Eagle  |
| Sulawesi Hawk-Eagle    |
| Javan Hawk-Eagle       |
| Blyth&#39;s Hawk-Eagle     |
| Mountain Hawk-Eagle    |
| Flores Hawk-Eagle      |
| Madagascar Cuckoo-Hawk |
+------------------------+
</code></pre>

<h2 id="toc_0">Syntax of Regular Expressions</h2>

<ul>
<li><code>^</code>: Match the beginning of a string</li>
<li><code>$</code>: Match the end of a string</li>
<li><code>.</code>: Match any character</li>
<li><code>a*</code>: Match any sequence of zero or more <code>a</code> characters</li>
<li><code>a+</code>: Match any sequence of one or more <code>a</code> characters</li>
<li><code>a?</code>: Match either zero or one <code>a</code> character</li>
<li><code>de|abc</code>: Match either of the sequences <code>de</code> or <code>abc</code></li>
<li><code>(abc)*</code>: Match zero or more instances of the sequence <code>abc</code></li>
</ul>

<h2 id="toc_1">Rescources</h2>

<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/regexp.html">Regular Expressions</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Deep Learning]]></title>
    <link href="http://larryim.cc/15025954300059.html"/>
    <updated>2017-08-13T11:37:10+08:00</updated>
    <id>http://larryim.cc/15025954300059.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Latex ÊäÄÂ∑ß]]></title>
    <link href="http://larryim.cc/15025903235887.html"/>
    <updated>2017-08-13T10:12:03+08:00</updated>
    <id>http://larryim.cc/15025903235887.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Latex Êü•ËØ¢</h2>

<p>ÂèØ‰ª•Âú®<code>Dash</code>‰∏≠‰∏ãËΩΩLatex Cheat Sheet‰ª•‰æøÈöèÊó∂Êü•ËØ¢„ÄÇ</p>

<h2 id="toc_1">Latex Â¶Ç‰ΩïÂ∞Ü‰∏ãÊ†áÊîæÂú®Ê≠£‰∏äÊñπÔºèÊ≠£‰∏ãÊñπ</h2>

<p>Âú® <code>\sum</code>Ôºå<code>\max</code>Á≠â‰πãÂêéÊ∑ªÂä†<code>\limits^{upper}_{lower}</code>Ôºö\(\sum\limits^{upper}_{lower}\)</p>

<p>‰æãÂ¶ÇÔºö</p>

<pre><code class="language-Latex">cost(i,j) = \sum \limits^{j}_{k=i}freq[k] + \min \limits_{r=i}^j
</code></pre>

<p>\(cost(i,j) = \sum \limits^{j}_{k=i}freq[k] + \min \limits_{r=i}^j\)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tensorflow Introduction]]></title>
    <link href="http://larryim.cc/TensorFlow_introduction.html"/>
    <updated>2017-08-12T16:44:23+08:00</updated>
    <id>http://larryim.cc/TensorFlow_introduction.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">Install</a>
</li>
<li>
<a href="#toc_1">TensorFlow Python docset</a>
</li>
<li>
<a href="#toc_2">Basics</a>
<ul>
<li>
<ul>
<li>
<a href="#toc_3">Graph and Operation</a>
</li>
<li>
<a href="#toc_4">Session</a>
</li>
<li>
<a href="#toc_5">Steps</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_6">Learning Resources</a>
</li>
</ul>


<p><a href="https://www.tensorflow.org">Tensorflow</a> is an open-source software library for Machine Intelligence.</p>

<h2 id="toc_0">Install</h2>

<p>Using <code>conda</code> tool under <code>Anaconda</code> to install tensorflow is a very convenient and direct way.</p>

<h2 id="toc_1">TensorFlow Python docset</h2>

<p>Build TensorFlow Python docset is complex, many dependent utilities and procedures are needed. Fortunately,  a feed for TensorFlow Python docset has been built for us.</p>

<p>Add feed below to Dash/Zeal, and install docset. (<a href="https://github.com/ppwwyyxx/dash-docset-tensorflow">Project site</a>)</p>

<pre><code>https://raw.githubusercontent.com/ppwwyyxx/dash-docset-tensorflow/master/TensorFlow.xml
</code></pre>

<h2 id="toc_2">Basics</h2>

<h4 id="toc_3">Graph and Operation</h4>

<p>A data flow <code>graph</code> representing a TensorFlow computation. It can be viewed via <code>TensorBoard</code>.</p>

<p>An <code>Operation</code> is a node in a TensorFlow <code>Graph</code> that takes zero or more <code>Tensor</code> object as input, and produces zero or more <code>Tensor</code> objects as output.</p>

<p>For example <code>c = tf.matmul(a, b)</code> creates an Operation of type <code>MatMul</code> that takes tensors \(a\) and \(b\) as input, and produces \(c\) as output.</p>

<h4 id="toc_4">Session</h4>

<p>If you are not using an <code>InteractiveSession</code>, then you should build the entire computation graph before starting a session and launching the graph.</p>

<p>Note that there are two typical ways to create and use sessions in tensorflow:</p>

<p><strong>Method 1</strong>:</p>

<pre><code class="language-python">sess = tf.Session()
# Run the variables initialization (if needed), run the operations
result = sess.run(..., feed_dict = {...})
sess.close() # Close the session
</code></pre>

<p><strong>Method 2</strong>:</p>

<pre><code class="language-python">with tf.Session() as sess: 
    # run the variables initialization (if needed), run the operations
    result = sess.run(..., feed_dict = {...})
    # This takes care of closing the session for you :)
</code></pre>

<h4 id="toc_5">Steps</h4>

<p>Writing and running programs in TensorFlow has the following steps:</p>

<ul>
<li>Create Tensors (variables) that are not yet executed/evaluated.</li>
<li>Write operations between those Tensors.</li>
<li>Initialize your Tensors.</li>
<li>Create a Session.</li>
<li>Run the Session. This will run the operations you&#39;d written above.</li>
</ul>

<h2 id="toc_6">Learning Resources</h2>

<ol>
<li><a href="https://web.stanford.edu/class/cs20si/">CS 20SI: Tensorflow for Deep Learning Research</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL(3): Storage Engines]]></title>
    <link href="http://larryim.cc/15025201109276.html"/>
    <updated>2017-08-12T14:41:50+08:00</updated>
    <id>http://larryim.cc/15025201109276.html</id>
    <content type="html"><![CDATA[
<p>You can use the <code>SHOW TABLE STATUS</code> command to display information about tables, which include types of storage engines.</p>

<pre><code class="language-sql">mysql root@localhost:rookery&gt; show table status\G
***************************[ 1. row ]***************************
Name            | bird_families
Engine          | InnoDB
Version         | 10
Row_format      | Dynamic
Rows            | 12
Avg_row_length  | 1365
Data_length     | 16384
Max_data_length | 0
Index_length    | 16384
Data_free       | 0
Auto_increment  | 113
Create_time     | 2017-08-11 00:18:18
Update_time     | 2017-08-12 13:11:47
Check_time      | &lt;null&gt;
Collation       | latin1_bin
Checksum        | &lt;null&gt;
Create_options  |
Comment         |
</code></pre>

<h2 id="toc_0">InnoDB</h2>

<p><code>InnoDB</code> is the default transactional storage engine for MySQL and the most important and broadly useful engine overall. <em>You should use InnoDB for your tables unless you have a compelling need to use a different engine</em>.</p>

<h2 id="toc_1">Reference</h2>

<ol>
<li>Baron S, Peter Z, Vadim T. 2012. High Performance MySQL 3rd Edition.</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NP-completeness]]></title>
    <link href="http://larryim.cc/15023384623586.html"/>
    <updated>2017-08-10T12:14:22+08:00</updated>
    <id>http://larryim.cc/15023384623586.html</id>
    <content type="html"><![CDATA[
<p><code>NP</code> stands for <code>None-deterministic Polynomial</code>. This means that the problem can be solved in Polynomial time using a None-deterministic Turing machine.</p>

<h2 id="toc_0">Polynomial-Time Solvability</h2>

<p>A problem is <code>polynomial-time solvable</code> if there is an algorithm that correctly solves it in \(O(n^k)\) time, for some constant \(k\).</p>

<p>Definition: P = the set of polynomial-time solvable problems.</p>

<h2 id="toc_1">Reference</h2>

<ul>
<li><a href="https://stackoverflow.com/questions/210829/what-is-an-np-complete-in-computer-science">What is an NP-complete in computer science?</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dynamic Programming (4): Optimal Binary Search Tree]]></title>
    <link href="http://larryim.cc/Dynamic_Programming_Optimal_Binary_Search_Tree.html"/>
    <updated>2017-08-09T16:42:39+08:00</updated>
    <id>http://larryim.cc/Dynamic_Programming_Optimal_Binary_Search_Tree.html</id>
    <content type="html"><![CDATA[
<p>An <code>Optimal Binary Search Tree (Optimal BST)</code> is a binary search tree which provides the smallest possible search time for a given sequence of access probabilities. The cost of a BST node is the level of that node plus one multiplied by its frequency.</p>

<p><strong>Problem Statement</strong>: Given a sorted array \(keys[0.. n-1]\) of search keys and an array \(freq[0.. n-1]\) of frequency counts, where \(freq[i]\) is the number of searches to \(keys[i]\). Construct a binary search tree of all keys such that the total cost of all the searches is as small as possible.</p>

<h2 id="toc_0">Optimal Substructure</h2>

<p>The optimal cost of node \(i,...,j\) can be recursively calculated using the following formula.</p>

<p>\(Cost(i,j) = \sum \limits^{j}_{k=i}freq[k] + \min \limits_{r=i}^j[Cost(i,r-1)+Cost(r+1,j)]\)</p>

<p>We try all nodes one by one as root (\(r\) varies from \(i\) to \(j\)). When we make \(r\)th node as root, we recursively calculate optimal cost from \(i\) to \(r-1\) and \(r+1\) to \(j\). </p>

<h3 id="toc_1">Implementation: top-down with memoization</h3>

<pre><code class="language-python">def optimal_bst(freq):
    def opt_cost(hash_table, freq, i, j):
        &quot;&quot;&quot;
        Optimal Binary Search Tree
        Recursive Method used here
        &quot;&quot;&quot;

        # base case: only 0~1 element
        if j &lt; i:
            return 0
        if j == i:
            return freq[i]

        # if already exists
        if (i, j) in hash_table:
            return hash_table[(i, j)]

        min_cost = sys.maxsize
        for r in range(i, j + 1):
            cost = opt_cost(hash_table, freq, i, r - 1) + opt_cost(hash_table, freq, r + 1, j)
            if cost &lt; min_cost:
                min_cost = cost

        hash_table[(i, j)] = sum(freq[i:j + 1]) + min_cost
        return hash_table[(i, j)]

    return opt_cost({}, freq, 0, len(freq) - 1)
</code></pre>

<h2 id="toc_2">Reference</h2>

<ul>
<li><a href="http://ac.els-cdn.com/S0304397596003209/1-s2.0-S0304397596003209-main.pdf?_tid=1505980e-7cd4-11e7-83de-00000aacb361&amp;acdnat=1502263778_53b76d131a06906e9fe3adfadc778677">Optimal Binary Search Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/dynamic-programming-set-24-optimal-binary-search-tree/">Optimal Binary Search Tree GeeksforGeeks</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
