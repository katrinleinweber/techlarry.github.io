<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Computer System - techlarry
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="techlarry" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:larryim.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">HomePage</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        <li id=""><a target="_blank" href="wiki">WIKI</a></li>
        
        <li id=""><a target="_self" href="notebook.html">NOTEBOOK</a></li>
        
        <li id=""><a target="_self" href="about.html">About</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="http://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; techlarry</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">HomePage</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        
        <li><a target="_blank" href="wiki">WIKI</a></li>
        
        <li><a target="_self" href="notebook.html">NOTEBOOK</a></li>
        
        <li><a target="_self" href="about.html">About</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Leetcode.html">Leetcode</a></li>
        
            <li><a href="programming_language.html">编程语言</a></li>
        
            <li><a href="data_structure_and_algorithm.html">数据结构和算法</a></li>
        
            <li><a href="Python%E7%89%B9%E6%80%A7.html">Python特性</a></li>
        
            <li><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html">机器学习</a></li>
        
            <li><a href="Python%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96.html">Python科学计算三维可视化</a></li>
        
            <li><a href="English.html">English</a></li>
        
            <li><a href="Computer%20System.html">Computer System</a></li>
        
            <li><a href="Deep%20Learning.html">Deep Learning</a></li>
        
            <li><a href="Linux%20%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html">Linux 系统编程</a></li>
        
            <li><a href="%E6%95%B0%E6%8D%AE%E5%BA%93.html">数据库</a></li>
        
            <li><a href="Tensorflow.html">Tensorflow</a></li>
        
            <li><a href="Big%20Data.html">Big Data</a></li>
        
            <li><a href="%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB.html">文献阅读</a></li>
        
            <li><a href="Tools.html">Tools</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="exceptional_control_flow.html">
                
                  <h1>CSAPP - 异常控制流</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">1 异常</a>
<ul>
<li>
<a href="#toc_1">1.1 异常的处理</a>
</li>
<li>
<a href="#toc_2">1.2 异常的类别</a>
</li>
</ul>
</li>
<li>
<a href="#toc_3">2 进程</a>
<ul>
<li>
<a href="#toc_4">2.1 逻辑控制流</a>
</li>
<li>
<a href="#toc_5">2.2 并发流</a>
</li>
<li>
<a href="#toc_6">2.3 私有地址空间</a>
</li>
<li>
<a href="#toc_7">2.4 用户模式和内核模式</a>
</li>
</ul>
</li>
<li>
<a href="#toc_8">3 系统调用错误处理</a>
</li>
<li>
<a href="#toc_9">4 进程控制</a>
<ul>
<li>
<a href="#toc_10">4.1 获取进程ID</a>
</li>
<li>
<a href="#toc_11">4.2 创建和终止进程</a>
</li>
<li>
<a href="#toc_12">4.3 回收子进程</a>
</li>
<li>
<a href="#toc_13">4.4 进程休眠</a>
</li>
<li>
<a href="#toc_14">4.5  加载并运行程序</a>
</li>
</ul>
</li>
<li>
<a href="#toc_15">5 信号</a>
<ul>
<li>
<a href="#toc_16">5.1 发送/接收信号</a>
</li>
<li>
<a href="#toc_17">5.2 发送信号</a>
</li>
<li>
<a href="#toc_18">5.3 接收信号</a>
</li>
<li>
<a href="#toc_19">5.4 阻塞信号和进程回收</a>
<ul>
<li>
<a href="#toc_20">5.4.1 隐式阻塞机制</a>
</li>
<li>
<a href="#toc_21">5.4.2 显式阻塞机制</a>
</li>
</ul>
</li>
<li>
<a href="#toc_22">5.5 信号处理程序</a>
</li>
</ul>
</li>
</ul>


<p>从给处理器加电开始，直到你断电为止，程序计数器假设成一个值的序列</p>

<p>\[a_0, a_1, ..., a_{n-1}\]</p>

<p>其中，每个\(a_k\)是某个相应的指令\(I_k\)的 <u>地址</u> 。每次从\(a_k\)到\(a_{k+1}\)的过渡称为<strong>控制转移</strong>(control transfer)。这样的控制转移序列叫做处理器的<strong>控制流</strong>(control flow)。</p>

<p>现在系统通过使控制流发生突变来应对系统状态的变化(eg.缺页异常，网络等待)，把这些突变称为<strong>异常控制流</strong>(Exceptional Control Flow, ECF)。</p>

<h2 id="toc_0">1 异常</h2>

<h3 id="toc_1">1.1 异常的处理</h3>

<p>系统为每<strong>类</strong>可能的异常都分配了一个唯一的非负整数的<strong>异常号</strong>(exception number)。在系统启动时，操作系统分配和初始化一张称为<strong>异常表</strong>的跳转表，使得表目\(k\)包含异常\(k\)的处理程序的地址。</p>

<p><img src="media/15312146721582/%E5%BC%82%E5%B8%B8%E8%A1%A8.png" alt="异常表"/></p>

<p>当检测到发生了一个事件，并且确定了相应的异常号\(k\)，处理器触发异常，执行间接过程调用，通过异常表的表目\(k\)，转到相应的处理程序。</p>

<h3 id="toc_2">1.2 异常的类别</h3>

<p>异常(exceptions)可以分为四类：中断(interrupt)、陷阱(trap)、故障(fault)和终止(abort)。<br/>
<img src="media/15312146721582/Exceptions.png" alt="Exceptions"/></p>

<ul>
<li><strong>中断</strong>是异步发生的，是来自处理器外部的I/O设备的信号的结果。</li>
<li><strong>陷阱</strong>是有意的异常，是执行一条指令的结果。
<ul>
<li>其用途是在用户程序和内核之间提供一个像过程一样的接口(系统调用)</li>
</ul></li>
<li><strong>故障</strong>是由错误情况引起的，可能能够被故障处理程序修正。
<ul>
<li>例如缺页异常</li>
</ul></li>
<li><strong>终止</strong>是不可恢复的致命错误造成的结果，通常是一些硬件错误。<br/></li>
</ul>

<h2 id="toc_3">2 进程</h2>

<p>进程(Process)的经典定义就是 <u>一个执行中程序的实例</u> (A process is a program in execuation) 。系统中的每个程序都运行在某个进程的上下文(context)中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。</p>

<p>进程提供了应用程序两个关键抽象：</p>

<ul>
<li>一个<strong>独立</strong>的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器。</li>
<li>一个<strong>私有</strong>的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统。</li>
</ul>

<h3 id="toc_4">2.1 逻辑控制流</h3>

<p><strong>逻辑控制流</strong>(Logical Control Flow，简称逻辑流)是PC值的序列。</p>

<h3 id="toc_5">2.2 并发流</h3>

<p>一个逻辑流的执行在时间上与另一个流重叠，称为<strong>并发流</strong>(concurrent flow)，这两个流被称为<strong>并发地运行</strong>。</p>

<h3 id="toc_6">2.3 私有地址空间</h3>

<p>进程为每个程序提供它自己的<strong>私有地址空间</strong>。一般而言，和这个空间中某个地址相关联的那个内存字节是不能被其他进程读或者写的，从这个意义上说，这个地址空间是私有的。</p>

<h3 id="toc_7">2.4 用户模式和内核模式</h3>

<p>处理器通常是用某个控制寄存器中的一个<strong>模式位</strong>(mode bit)来控制用户/内核模式。当设置了模式位时，进程就运行在<strong>内核模式</strong>中，否则运行在<strong>用户模式</strong>中。</p>

<p>运行在内核模式的进程可以执行指令集中的任何指令，可以访问任何内存位置。用户模式中的进程不允许执行特权指令，也不允许直接引用地址空间中内核区的代码和数据。</p>

<h2 id="toc_8">3 系统调用错误处理</h2>

<h2 id="toc_9">4 进程控制</h2>

<p>进程控制包括获取进程ID、创建和终止进程、回收子进程、让进程休眠、加载并运行程序等。这一节将描述Unix提供了控制进程的系统调用。</p>

<h3 id="toc_10">4.1 获取进程ID</h3>

<p>每一个进程都有一个唯一的整数(非零)进程ID(PID)。<code>getpid</code>函数返回调用进程的PID。<code>getppid</code>函数返回它的父进程的PID。</p>

<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

pid_t getpid(void);
pit_t getppid(void);
</code></pre>

<h3 id="toc_11">4.2 创建和终止进程</h3>

<p><strong>父进程</strong>通过调用fork函数创建一个新的运行的<strong>子进程</strong>。</p>

<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

pid_t fork(void);
</code></pre>

<p>新创建的子进程几乎但不完全与父进程相同：</p>

<ul>
<li><strong>相同但是独立的地址空间</strong>：子进程获得父进程虚拟地址空间的一份副本</li>
<li><strong>共享文件</strong>：子进程获得父进程打开文件描述符相同的副本</li>
<li>子进程与父进程pid不同</li>
</ul>

<h3 id="toc_12">4.3 回收子进程</h3>

<p>进程在终止后，并不会被内核从系统中清除，而是保持这种状态，直到被它的父进程<strong>回收</strong>(reaped)。</p>

<ul>
<li>一个终止了但还未被回收的进程称为<strong>僵死进程</strong>(zombie)。</li>
<li>即使僵死进程没有运行，它仍然消耗系统的内存资源。</li>
</ul>

<p>通过调用<code>waitpid</code>函数来等待子进程终止或者停止。</p>

<h3 id="toc_13">4.4 进程休眠</h3>

<p><code>sleep</code>函数将一个进程挂起一段制定的时间。</p>

<pre><code class="language-c">#include &lt;unistd.n&gt;
unsigned int sleep(unsigned int secs);
</code></pre>

<h3 id="toc_14">4.5  加载并运行程序</h3>

<p><code>execve</code>函数在当前进程的上下文中加载并运行一个新程序。</p>

<ul>
<li><code>execve</code>调用一次并从不返回。</li>
</ul>

<h2 id="toc_15">5 信号</h2>

<p>Linux<strong>信号</strong>，通知进程系统中发生一个某种类型的事件。每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。下面是Linux系统上常见的信号：</p>

<p><strong>常见的信号</strong>：</p>

<table>
<thead>
<tr>
<th>编号</th>
<th>名称</th>
<th>默认动作</th>
<th>对应事件</th>
</tr>
</thead>

<tbody>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>终止</td>
<td>来自键盘的中断CTRL+C</td>
</tr>
<tr>
<td>3</td>
<td>SIGQUIT</td>
<td>终止</td>
<td>来自键盘的退出CTRL+\</td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>终止</td>
<td>杀死程序 <code>\bin\kill -9</code></td>
</tr>
<tr>
<td>11</td>
<td>SIGSEGV</td>
<td>终止并转储内存</td>
<td>段故障(无效的内存引用)</td>
</tr>
<tr>
<td>15</td>
<td>SIGTERM</td>
<td>终止</td>
<td>软件终止信号<code>\bin\kill</code></td>
</tr>
<tr>
<td>17</td>
<td>SIGCHLD</td>
<td>忽略</td>
<td>子进程停止或终止</td>
</tr>
<tr>
<td>18</td>
<td>SIGCONT</td>
<td>忽略</td>
<td>继续进程如果该进程停止</td>
</tr>
<tr>
<td>20</td>
<td>SIGTSTP</td>
<td>停止直到下一个SIGCONT</td>
<td>用户输入CTRL+Z</td>
</tr>
</tbody>
</table>

<p>详细信息可以通过<code>man 7 signal</code>查询。</p>

<h3 id="toc_16">5.1 发送/接收信号</h3>

<p>传送一个信号到目的进程由发送、接收信号两个步骤组成：</p>

<ul>
<li>发送信号。内核通过更新目的进程上下文中的某个状态，发送(递送)一个信号给目的进程。</li>
<li>接收信号。当目的进程被内核强迫已某种方式对信号的发送做出反应时，它就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为<strong>信号处理程序</strong>的用户层函数捕获这个信号。</li>
</ul>

<h3 id="toc_17">5.2 发送信号</h3>

<p>发送信号可以由以下原因引起：</p>

<ul>
<li>用户：用户能够通过输入<code>CTRL+c</code>(<code>SIGINT</code>)、<code>Ctrl+z</code>(<code>SIGTSTP</code>)，或者是终端驱动程序分配给信号控制字符的其他任何键来请求内核产生信号；</li>
<li>内核：当进程执行出错时，内核会给进程发送一个信号，例如非法段存取(内存访问违规)、浮点数溢出等；</li>
<li>进程：一个进程可以通过系统调用kill给另一个进程或自己发送信号。</li>
</ul>

<h3 id="toc_18">5.3 接收信号</h3>

<p>当内核把进程\(p\)从内核模式切换到用户模式时，它会检查进程\(p\)的未被阻塞的待处理信号的集合(<code>pending&amp;~blocked</code>,见下文)，如果集合非空，那么内核强制\(p\)接收信号，触发进程采取某种行为。</p>

<p>进程接收到信号以后，可以有如下3种选择进行处理：</p>

<ul>
<li>接收默认处理：接收默认处理的进程通常会导致进程本身消亡。例如连接到终端的进程，用户按下CTRL+c，将导致内核向进程发送一个SIGINT的信号，进程如果不对该信号做特殊的处理，系统将采用默认的方式处理该信号，即终止进程的执行；</li>
<li>忽略信号：进程可以通过代码，显示地忽略某个信号的处理，例如：<code>signal(SIGINT,SIGDEF)</code>；但是某些信号是不能被忽略的，</li>
<li>捕获信号并处理：当接收到信号时，由信号处理程序自动捕获并且处理信号。</li>
</ul>

<pre><code class="language-c">sighandler_t signal(int signum, sighandler_t handler);
</code></pre>

<p>有两个信号既不能被忽略也不能被捕获，它们是<code>SIGKILL</code>和<code>SIGSTOP</code>。即进程接收到这两个信号后，只能接受系统的默认处理，即终止线程。</p>

<h3 id="toc_19">5.4 阻塞信号和进程回收</h3>

<p>一个发出而没有被接受的信号叫做<strong>未处理信号</strong>（Pending Signal）。进程可以选择阻塞（Block）某个信号。被阻塞的信号产生时将保持在未处理状态，直到进程解除对此信号的阻塞，才执行接收的动作。阻塞和忽略是不同的，<strong>只要信号被阻塞就不会接收</strong>，而忽略是在接收之后可选的一种处理动作。</p>

<p>Linux提供阻塞信号的隐式和显式机制:</p>

<ul>
<li><strong>隐式阻塞机制</strong>：内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。如果在进程解除对某信号的阻塞之前这种信号产生过多次，只计一次。因为每个信号只有一个bit的未处理标志(如下图)，非0即1，不记录该信号产生了多少次，阻塞标志也是这样表示的。</li>
<li><strong>显式阻塞机制</strong>：应用<code>sigprocmask</code>函数，明确地阻塞和解除阻塞选定的信号。</li>
</ul>

<p>内核为每个进程在<strong>pending位向量</strong>中维护着待处理信号的集合，而在<strong>blocked位向量</strong>中维护着被阻塞的信号集合。信号在内核中的表示可以看作是这样的：</p>

<p><img src="media/15156057194882/15156070945641.png" alt=""/></p>

<p>每个信号都有两个标志位分别表示阻塞和未处理，还有一个函数指针表示处理动作。信号产生时，内核在进程控制块中设置该信号的未处理标志，直到信号接收才清除该标志。在上图的例子中，</p>

<ul>
<li>SIGHUP信号未阻塞也未产生过，当它接收时执行默认处理动作。</li>
<li>SIGINT信号产生过，但正在被阻塞，所以暂时不能接收。虽然它的处理动作是忽略，但在没有解除阻塞之前不能忽略这个信号，因为进程仍有机会改变处理动作之后再解除阻塞。</li>
<li>SIGQUIT信号未产生过，一旦产生SIGQUIT信号将被阻塞，它调用信号处理程序<code>sighandler</code>。</li>
</ul>

<h4 id="toc_20">5.4.1 隐式阻塞机制</h4>

<p>当多个未处理信号(<code>pending signal</code>)到达时，由于信号并不会产生排队等待这样的情况，所以产生的效果仅相当于一个未处理信号(也就是对应的<code>pending</code>位标记为1，例如上图中的<code>SIGINT</code>信号)。</p>

<p>这样带来几个问题：</p>

<ul>
<li>不能用信号来对其他进程中发生的事件计数，这是显而易见的</li>
<li>在回收子进程时，要回收尽可能多的子进程。例如下面这个例子。</li>
</ul>

<pre><code class="language-c">void handler1(int sig)   
{  
    pid_t pid;  
  
    if ((pid = waitpid(-1, NULL, 0)) &lt; 0)  
        unix_error(&quot;waitpid error&quot;);  
    printf(&quot;Handler reaped child %d\n&quot;, (int)pid);  
    Sleep(2);  
    return;  
}  

/* $begin signal2 */
void handler2(int sig) 
{
    int olderrno = errno;

    while (waitpid(-1, NULL, 0) &gt; 0) {
        Sio_puts(&quot;Handler reaped child\n&quot;);
    }
    // waitpid()函数有可能因为找不到子进程而报ECHILD错误
    if (errno != ECHILD)
        Sio_error(&quot;waitpid error&quot;);
    Sleep(1);
    errno = olderrno;
}
/* $end signal2 */

int main() 
{
    int i, n;
    char buf[MAXBUF];

    if (signal(SIGCHLD, handler2) == SIG_ERR) //handler2 或者 handler1
        unix_error(&quot;signal error&quot;);

    /* Parent creates children */
    for (i = 0; i &lt; 3; i++) {
        if (Fork() == 0) {
            printf(&quot;Hello from child %d\n&quot;, (int)getpid());
            exit(0);
        }
    }

    /* Parent waits for terminal input and then processes it */
    if ((n = read(STDIN_FILENO, buf, sizeof(buf))) &lt; 0)
        unix_error(&quot;read&quot;);

    printf(&quot;Parent processing input\n&quot;);
    while (1)
        ;

    exit(0);
}
</code></pre>

<p>在上面这个例子中，父进程创建一些子进程，这些子进程各自独立运行一段时间，然后终止。用<code>SIGCHLD</code>处理程序来回收子进程，其中<code>handler1</code>是错误的，会产生僵死子进程。<code>handler2</code>是安全的。原因是在<code>handler1</code>中，可能存在子进程先被执行，产生<code>SIGCHLD</code>信号；但是在子进程还未被回收之前，又有多个子进程被执行，产生多个<code>SIGCHLD</code>信号。于是多余的未处理<code>SIGCHLD</code>信号就被抛弃，只相当于一个<code>SIGCHLD</code>信号。最终会造成有的子进程未被回收，产生僵死子进程。</p>

<p>执行的可能结果如下，可以看到父进程只回收了两个子进程。</p>

<pre><code class="language-text">Hello from child 5617
Hello from child 5616
Hello from child 5618
Handler reaped child
Handler reaped child

Parent processing input
</code></pre>

<h4 id="toc_21">5.4.2 显式阻塞机制</h4>

<p>有时候不希望在发送信号后就立即去接收、处理信号，同时也不希望忽略该信号，那么可以通过<code>sigprocmask</code>显式地阻塞信号从而实现延迟接收信号。</p>

<p>函数<code>sigprocmask</code>可以更改当前阻塞的信号集合(即blocked位向量):</p>

<pre><code class="language-c">int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
</code></pre>

<p>其具体行为依赖于how值：</p>

<pre><code class="language-text">SIG_BLOCK, blocked = blocked | set //添加set信号
SIG_UNBLOCK, blocked = blocked &amp; ~set //删除set信号
SIG_SETMASK, block = set //设置set信号为阻塞的信号
</code></pre>

<p>阻塞的信号集合其实就是一个无符号整型数组(在x86-64上，数组长度是16)。</p>

<pre><code class="language-c">/* A `sigset_t&#39; has a bit for each signal.  */
# define _SIGSET_NWORDS (1024 / (8 * sizeof (unsigned long int)))
typedef struct
{
    unsigned long int __val[_SIGSET_NWORDS];
} sigset_t;
</code></pre>

<p>还有其他的一些函数可以对信号集进行操作：</p>

<pre><code class="language-c">int sigfillset(sigset_t *set); // 信号集初始化, 然后把所有的信号加入到此信号集里
int sigemptyset(sigset_t *set); //信号集初始化为空
int sigaddset(sigset_t *set, int signo); //将信号signo添加到信号集中  
</code></pre>

<p>下面看个例子, 是一个具有细微同步错误的SHELL程序。如果子进程在父进程能够开始运行前就结束了，那么<br/>
<code>addjob()</code> 和 <code>deletejob()</code> 会以错误的方式被调用。这个程序希望父进程在一个作业列表中记录着它的当前子进程，每个作业条目。 <code>addjob()</code> 和 <code>deletejob()</code> 分别想这个作业列表添加和从中删除作业。当父进程创建一个新的子进程时，它就把这个子进程添加到作业列表中。当父进程在<code>SIGCHLD</code> 处理程序中回收一个终止的（僵死）子进程时，它就从作业列表中删除这个子进程。乍一看，这段代码是对的。不幸的是，可能发生下面的情况：</p>

<ul>
<li>1. 父进程执行<code>fork()</code>，内核调度新创建的子进程运行，而不是父进程</li>
<li>2. 在父进程能够再次运行之前，子进程就终止，并且变成一个僵死进程，使得内核传递一个<code>SIGCHLD</code>信号给父进程</li>
<li>3. 后来，当父进程再次变成可运行但又在它执行之前，内核注意到待处理的<code>SIGCHLD</code>信号，并通过在父进程中运行处理程序接收这个信号</li>
<li>4. 处理程序回收终止的子进程，并调用<code>deletejob()</code>，这个函数什么都不做，因为父进程还没有把该子进程添加到列表中</li>
<li>5. 在处理程序运行结束后，内核运行父进程，父进程从<code>fork()</code>返回，通过调用<code>addjob()</code> 错误地把（不存在的）子进程添加到作业列表中</li>
</ul>

<pre><code class="language-c">void handler(int sig)
{
        pid_t pid;
        while ((pid = waitpid(-1, NULL, 0)) &gt; 0) /* Reap a zombie child */
                deletejob(pid); /* Delete the child from the job list */
        if (errno != ECHILD)
                unix_error(&quot;waitpid error&quot;);
}

int main(int argc, char **argv)
{
        int pid;

        Signal(SIGCHLD, handler);
        initjobs();             /* Initialize the job list */

        while (1) {
                /* Child process */
                if ((pid = Fork()) == 0) {
                        Execve(&quot;/bin/date&quot;, argv, NULL);
                }

                /* Parent process */
                addjob(pid);    /* Add the child to the job list */
        }

        exit(0);
}
</code></pre>

<p>正确的做法应该如下,  通过在调用 <code>fork()</code> 之前，阻塞 <code>SIGCHLD</code> 信号，然后在我们调用了 <code>addjob()</code> 之后就取消阻塞这些信号，我们保证了在子进程被添加到作业列表之后回收该子进程。注意，子进程继承了它们父进程的被阻塞集合，所以我们必须在调用 <code>execve()</code> 之前，小心地解除子进程中阻塞的 <code>SIGCHLD</code> 信号。这样，父进程保证在相应的 <code>deletejob()</code> 之前执行 <code>addjob()</code>。</p>

<pre><code class="language-c">int main(int argc, char **argv)
{
    int pid;
    sigset_t mask_all, mask_one, prev_one;

    Sigfillset(&amp;mask_all);
    Sigemptyset(&amp;mask_one);
    Sigaddset(&amp;mask_one, SIGCHLD);
    Signal(SIGCHLD, handler);
    initjobs(); /* Initialize the job list */

    while (1) {
        Sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev_one); /* Block SIGCHLD */
        if ((pid = Fork()) == 0) { /* Child process */
            Sigprocmask(SIG_SETMASK, &amp;prev_one, NULL); /* Unblock SIGCHLD */
            Execve(&quot;/bin/date&quot;, argv, NULL);
        }
        Sigprocmask(SIG_BLOCK, &amp;mask_all, NULL); /* Parent process */  
        addjob(pid);  /* Add the child to the job list */
        Sigprocmask(SIG_SETMASK, &amp;prev_one, NULL);  /* Unblock SIGCHLD */
    }
    exit(0);
}
</code></pre>

<h3 id="toc_22">5.5 信号处理程序</h3>

<p>信号处理程序(signal handler)是重要且棘手的一个问题。其难点在：</p>

<ul>
<li>处理程序与主程序并发运行，共享同样的全局变量，因此可能与主程序和其他处理程序相互干扰；</li>
<li>如何以及何时接收信号的规则常常违背人的直觉。</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/1/10</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Computer%20System.html'>Computer System</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="overhead.html">
                
                  <h1>Overhead</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><strong>overhead</strong>这个词在计算机中经常出现，那么它到底是什么意思呢？</p>

<p>overhead视风格可以翻译成「额外开销」、「额外消耗」、「虚耗」。</p>

<p>额外开销是建立一个操作所需的资源，它可能看起来不相关，但是却是必须的。就好像当你需要去某个地方的时候，你可能需要一辆车。但是如果你开车上街这件事是大量的额外开销，你可能会想要走路；但是如果你要开车穿越一个国家，额外开销是值得的。</p>

<p>The meaning of the word can differ a lot with context. In general, it&#39;s resources (most often memory and CPU time) that are used, which do not contribute directly to the intended result, but are required by the technology or method that is being used. Examples:</p>

<ul>
<li><p>Protocol overhead: Ethernet frames, IP packets and TCP segments all have headers, TCP connections require handshake packets. Thus, you cannot use the entire bandwidth the hardware is capable of for your actual data. You can reduce the overhead by using larger packet sizes and UDP has a smaller header and no handshake.</p></li>
<li><p>Data structure memory overhead: A linked list requires at least one pointer for each element it contains. If the elements are the same size as a pointer, this means a 50% memory overhead, whereas an array can potentially have 0% overhead.</p></li>
<li><p>Method call overhead: A well-designed program is broken down into lots of short methods. But each method call requires setting up a stack frame, copying parameters and a return address. This represents CPU overhead compared to a program that does everything in a single monolithic function. Of course, the added maintainability makes it very much worth it, but in some cases, excessive method calls can have a significant performance impact.</p></li>
</ul>

<h2 id="toc_0">参考</h2>

<ul>
<li><a href="https://stackoverflow.com/questions/2860234/what-is-overhead">https://stackoverflow.com/questions/2860234/what-is-overhead</a></li>
<li><a href="https://www.zhihu.com/question/20596199?sort=created">https://www.zhihu.com/question/20596199?sort=created</a></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/1/21</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Computer%20System.html'>Computer System</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15146536465849.html">
                
                  <h1>CSAPP - x86-64汇编</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">汇编代码格式</h2>

<p>现在主要存在<code>ATT</code>和<code>Intel</code>两种汇编代码格式。<code>ATT</code>格式是<code>GCC</code>、 <code>OBJDUMP</code>常用工具的默认格式。其他的诸如Microsoft的工具和来自Intel的文档都是<code>Intel</code>格式的。本文使用<code>ATT</code>格式。</p>

<p><code>ATT</code>汇编格式的注释格式有两种</p>

<pre><code class="language-text"># this is a comment
/* this is a comment */
</code></pre>

<h2 id="toc_1">寄存器</h2>

<p><code>x86-64</code>体系结构广泛存在于个人电脑中。它拥有16个整数寄存器，分别存储64位的值。这些寄存器可以存储地址或整数数据，其分布如下：</p>

<p><img src="media/15146536465849/sfd.png" alt="sfd"/></p>

<p>根据惯例，寄存器%rbx, %rbp和%r12~%r15被划分为<strong>被调用者保存寄存器</strong>。所有其他的寄存器，除了栈指针%rsp都分类为<strong>调用者保存寄存器</strong>。</p>

<ul>
<li>在函数被调用时，不能改变<strong>被</strong>调用者寄存器；</li>
<li>如果要改变的话，只能把<strong>被</strong>调用者寄存器的值压入栈中，在使用后，从栈中恢复<strong>被</strong>调用者寄存器。</li>
</ul>

<h3 id="toc_2">rip 寄存器与PC相对寻址</h3>

<p>%rip 的名称来自于(instruction pointer register，指令指针寄存器)。%rip其实就是<strong>程序计数器</strong>(Program Counter, PC), <u><em>存放着下一条指令的地址</em></u> 。不可以直接修改%rip。</p>

<p>-&gt; <code>instruction pointer = program counter = %rip</code></p>

<p>%rip的其他很重要的一个用法就是RIP/<strong>PC相对寻址</strong>(RIP/PC relative addressing)。即<code>%rip + displacement</code>的用法。</p>

<p>例如，</p>

<pre><code class="language-assembly">mov    0x202a62(%rip),%rdi        # 6044d0 &lt;infile&gt;  rdi = infile
</code></pre>

<p>表示传输%rip+0x202a62的地址对应的内存上的内容到%rdi。</p>

<p>下面说说它是怎么进行PC相对寻址的。</p>

<ul>
<li>源文件经过预处理器、编译器、汇编器处理，输出<strong>可重定位目标文件</strong></li>
<li>再经过<strong>符号解析</strong>(Symbol resolution)把代码中的每个符号引用和一个符号定义关联起来之后，要完成<strong>重定位</strong>(Relocation)任务，最终输出<strong>可执行目标文件</strong>。
<ul>
<li>在<strong>重定位</strong>阶段，ELF(可重定位目标文件在LINUX系统上的一种格式)文件中的<code>R_X86_64_PC32</code>重定位类型重定位了一个使用32位PC相对地址的引用。</li>
<li>当CPU执行一条使用PC相对寻址的指令时，它就将在指令中编码的32位值加上PC的当前运行时值，得到<strong>有效地址</strong>。</li>
</ul></li>
</ul>

<h2 id="toc_3">指令</h2>

<p>指令主要有<code>mov</code>数据传送指令，<code>push</code>、<code>pop</code>压入和压出栈数据，<code>add</code>,<code>sub</code>等算数操作指令，<code>ret</code>, <code>call</code>等转移控制指令。</p>

<h3 id="toc_4">数据传送指令</h3>

<table>
<thead>
<tr>
<th>指令</th>
<th>效果</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>MOV S, D</td>
<td>将S中数据传送到D中</td>
<td>传送</td>
</tr>
<tr>
<td>movb</td>
<td>传送字节</td>
<td></td>
</tr>
<tr>
<td>movw</td>
<td>传送字(双字节)</td>
<td></td>
</tr>
<tr>
<td>movl</td>
<td>传送双字(四字节)</td>
<td></td>
</tr>
<tr>
<td>MOVS S, D</td>
<td>将S中数据传送到D，过程中做了符号扩展处理 传送需要符号扩展的字节</td>
<td></td>
</tr>
<tr>
<td>movsbw</td>
<td>将做了符号扩展的字节传送到字</td>
<td></td>
</tr>
<tr>
<td>movsbl</td>
<td>将做了符号扩展的字节传送到双字</td>
<td></td>
</tr>
<tr>
<td>movswl</td>
<td>将做了符号扩展的字传送到双字</td>
<td></td>
</tr>
<tr>
<td>MOVZ S, D</td>
<td>将S中数据传送到D，过程中做了零扩展处理</td>
<td>传送需要零扩展的字节</td>
</tr>
<tr>
<td>movzbw</td>
<td>将做了零扩展的字节传送到</td>
<td></td>
</tr>
<tr>
<td>movzbl</td>
<td>将做了零扩展的字节传送到双字</td>
<td></td>
</tr>
<tr>
<td>movzwl</td>
<td>将做了零扩展的字传送到双字</td>
<td></td>
</tr>
<tr>
<td>pushl S</td>
<td>R[%esp] &lt;- R[%esp] - 4; M[R[%esp]] &lt;- S;</td>
<td>将双字压栈</td>
</tr>
<tr>
<td>popl D</td>
<td>D &lt;- M[R[%esp]]; R[%esp] &lt;- R[%esp] + 4;</td>
<td>将双字出栈</td>
</tr>
</tbody>
</table>

<h3 id="toc_5">ret, call指令</h3>

<p>在x86-64上，<code>ret</code>指令，相当于从栈中弹出地址A，然后把PC设置为A。<br/>
<code>pop %rip</code><br/>
而<code>call</code>指令，刚好相反，把%rip 压入栈中，然后跳到函数对应的地址。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/12/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Computer%20System.html'>Computer System</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="objdump_disassembler.html">
                
                  <h1>Objdump 反汇编</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><code>objdump</code>是一个反汇编器(<code>disassembler</code>)，可以将机器语言生成对应的汇编文件。常用的命令是</p>

<pre><code class="language-text">objdump -d filename.o
</code></pre>

<p>其选项有：</p>

<pre><code class="language-text">--archive-headers 
-a 
显示档案库的成员信息,类似ls -l将lib*.a的信息列出。 

-b bfdname 
--target=bfdname 
指定目标码格式。这不是必须的，objdump能自动识别许多格式，比如： 

objdump -b oasys -m vax -h fu.o 
显示fu.o的头部摘要信息，明确指出该文件是Vax系统下用Oasys编译器生成的目标文件。objdump -i将给出这里可以指定的目标码格式列表。 

-C 
--demangle 
将底层的符号名解码成用户级名字，除了去掉所开头的下划线之外，还使得C++函数名以可理解的方式显示出来。 

--debugging 
-g 
显示调试信息。企图解析保存在文件中的调试信息并以C语言的语法显示出来。仅仅支持某些类型的调试信息。有些其他的格式被readelf -w支持。 

-e 
--debugging-tags 
类似-g选项，但是生成的信息是和ctags工具相兼容的格式。 

--disassemble 
-d 
从objfile中反汇编那些特定指令机器码的section。 

-D 
--disassemble-all 
与 -d 类似，但反汇编所有section. 

--prefix-addresses 
反汇编的时候，显示每一行的完整地址。这是一种比较老的反汇编格式。 

-EB 
-EL 
--endian={big|little} 
指定目标文件的小端。这个项将影响反汇编出来的指令。在反汇编的文件没描述小端信息的时候用。例如S-records. 

-f 
--file-headers 
显示objfile中每个文件的整体头部摘要信息。 

-h 
--section-headers 
--headers 
显示目标文件各个section的头部摘要信息。 

-H 
--help 
简短的帮助信息。 

-i 
--info 
显示对于 -b 或者 -m 选项可用的架构和目标格式列表。 

-j name
--section=name 
仅仅显示指定名称为name的section的信息 

-l
--line-numbers 
用文件名和行号标注相应的目标代码，仅仅和-d、-D或者-r一起使用使用-ld和使用-d的区别不是很大，在源码级调试的时候有用，要求编译时使用了-g之类的调试编译选项。 

-m machine 
--architecture=machine 
指定反汇编目标文件时使用的架构，当待反汇编文件本身没描述架构信息的时候(比如S-records)，这个选项很有用。可以用-i选项列出这里能够指定的架构. 

--reloc 
-r 
显示文件的重定位入口。如果和-d或者-D一起使用，重定位部分以反汇编后的格式显示出来。 

--dynamic-reloc 
-R 
显示文件的动态重定位入口，仅仅对于动态目标文件意义，比如某些共享库。 

-s 
--full-contents 
显示指定section的完整内容。默认所有的非空section都会被显示。 

-S 
--source 
尽可能反汇编出源代码，尤其当编译的时候指定了-g这种调试参数时，效果比较明显。隐含了-d参数。 

--show-raw-insn 
反汇编的时候，显示每条汇编指令对应的机器码，如不指定--prefix-addresses，这将是缺省选项。 

--no-show-raw-insn 
反汇编时，不显示汇编指令的机器码，如不指定--prefix-addresses，这将是缺省选项。 

--start-address=address 
从指定地址开始显示数据，该选项影响-d、-r和-s选项的输出。 

--stop-address=address 
显示数据直到指定地址为止，该项影响-d、-r和-s选项的输出。 

-t 
--syms 
显示文件的符号表入口。类似于nm -s提供的信息 

-T 
--dynamic-syms 
显示文件的动态符号表入口，仅仅对动态目标文件意义，比如某些共享库。它显示的信息类似于 nm -D|--dynamic 显示的信息。 

-V 
--version 
版本信息 

--all-headers 
-x 
显示所可用的头信息，包括符号表、重定位入口。-x 等价于-a -f -h -r -t 同时指定。 

-z 
--disassemble-zeroes 
一般反汇编输出将省略大块的零，该选项使得这些零块也被反汇编。 

@file 可以将选项集中到一个文件中，然后使用这个@file选项载入。
</code></pre>

<p>下面通过一个简单的例子来说明一下<code>objdump</code>的常见用法，以及它生成的文件的格式。</p>

<p>假设写一个简单的C程序<code>test.c</code>如下：</p>

<pre><code class="language-c">int foo()
{
    int a = 5;
    int b = 0;
    b = a + 3;
}
</code></pre>

<p>用<code>gcc</code>命令<code>gcc test.c -c</code>生成目标文件<code>test.o</code>后, 利用<code>objdump -d test.o &gt; test.s</code>生成类似汇编文件：</p>

<pre><code class="language-text">test.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt;foo&gt;:
   0:   55                      push   %rbp
   1:   48 89 e5                mov    %rsp,%rbp
   4:   c7 45 f8 05 00 00 00    movl   $0x5,-0x8(%rbp)
   b:   c7 45 fc 00 00 00 00    movl   $0x0,-0x4(%rbp)
  12:   8b 45 f8                mov    -0x8(%rbp),%eax
  15:   83 c0 03                add    $0x3,%eax
  18:   89 45 fc                mov    %eax,-0x4(%rbp)
  1b:   5d                      pop    %rbp
  1c:   c3                      retq
</code></pre>

<p>可以看到的其实这个类似于汇编文件的格式是<code>elf64-x86-64</code>, 下一小节会简单的介绍这个格式。其中最重要的内容是从<code>0000000000000000 &lt;foo&gt;</code>开始到结束的部分。这部分从左到右依次是</p>

<ul>
<li>指令开始的地址<code>memory staring addresses</code></li>
<li>汇编代码对应的二进制指令<code>byte codes for instruction</code></li>
<li>汇编代码<code>assembly codes</code></li>
</ul>

<h3 id="toc_0">显示文件的符号表入口</h3>

<p><code>objdump -t</code> 命令会打印文件的符号表<code>symbol table</code>. 输出的文件一共有7列，从左到右依次是</p>

<ul>
<li>value</li>
<li>class</li>
<li>type</li>
<li>size</li>
<li>line</li>
<li>section</li>
<li>symbol-name</li>
</ul>

<h2 id="toc_1">elf64-x86-64 文件</h2>

<p><code>elf</code>是<code>Executable and Linkable Format</code>(可执行和可链接格式，<a href="http://larryim.cc/Linking.html">看本文</a>)的简称。<code>elf</code>文件格式及其复杂，如果只需要研究<code>objdump</code>产生的反汇编文件没有必要去专门学习<code>elf</code>格式。掌握下面几点，就可以阅读<code>objdump</code>产生的反汇编文件了。<code>objdump</code>产生的<code>elf</code>文件，主要包括以下几个部分：</p>

<ul>
<li>Disassembly of section .init</li>
<li>Disassembly of section .plt</li>
<li>Disassembly of section .text</li>
<li>Disassembly of section .fini</li>
</ul>

<p>下面是一个具体的文件，为了更简洁的展示，每一部分只保留了一小段内容：</p>

<pre><code class="language-text">ctarget:     file format elf64-x86-64


Disassembly of section .init:

0000000000400c48 &lt;_init&gt;:
  400c48:   48 83 ec 08             sub    $0x8,%rsp
  400c4c:   e8 6b 02 00 00          callq  400ebc &lt;call_gmon_start&gt;
  400c51:   48 83 c4 08             add    $0x8,%rsp
  400c55:   c3                      retq   

Disassembly of section .plt:

0000000000400cb0 &lt;strcpy@plt&gt;:
  400cb0:   ff 25 6a 33 20 00       jmpq   *0x20336a(%rip)        # 604020 &lt;_GLOBAL_OFFSET_TABLE_+0x38&gt;
  400cb6:   68 04 00 00 00          pushq  $0x4
  400cbb:   e9 a0 ff ff ff          jmpq   400c60 &lt;_init+0x18&gt;


Disassembly of section .text:

00000000004011ad &lt;main&gt;:
  4011bb:   be c5 1d 40 00          mov    $0x401dc5,%esi
  4011c0:   bf 0b 00 00 00          mov    $0xb,%edi
  4011c5:   e8 86 fb ff ff          callq  400d50 &lt;signal@plt&gt;
  4011cf:   bf 07 00 00 00       
  401384:   c3                      retq   


Disassembly of section .fini:

0000000000402d74 &lt;_fini&gt;:
  402d74:   48 83 ec 08             sub    $0x8,%rsp
  402d78:   48 83 c4 08             add    $0x8,%rsp
  402d7c:   c3                      retq   

</code></pre>

<p>其中<code>.fini</code>部分是有关进程结束的指令。<code>.init</code>部分是有关进程启动的指令，在<code>main()</code>函数执行前会执行。<code>PLT</code>代表<code>Procedure Linkage Table</code>(过程链接表),用来调用在链接阶段未知的外部函数/过程的，在运行时它会动态链接。所以最重要的内容都在<code>.text</code>部分中。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/1/1</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Computer%20System.html'>Computer System</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="virtual_memory_and_dynamic_memory_allocate.html">
                
                  <h1>CSAPP - 虚拟内存</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">1 物理/虚拟寻址</h2>

<p>主存是由连续的<strong>字节大小</strong>的单元组成的数组，每字节都有一个唯一的<strong>物理地址</strong>(Physical Adress)。CPU使用物理地址访问内存的方式称为<strong>物理寻址</strong>(Physical adressing)。</p>

<p>早期的PC以及数字信号处理器等使用物理寻址，下面是物理寻址的示意图：</p>

<p><img src="media/15164033620970/physical_address.png" alt="physical_address"/></p>

<p>现代处理器通过生成一个<strong>虚拟地址</strong>(Virtual Address)来访问主存，虚拟地址经过<strong>地址翻译</strong>转换为物理地址。地址翻译由CPU内的<strong>内存管理单元</strong>(Memory Management Unit, <code>MMU</code>)负责.</p>

<p><img src="media/15164033620970/virtual_memory%20.png" alt="virtual_memory "/></p>

<p>虚拟内存充当着三个角色：</p>

<ul>
<li>作为缓存的工具，可以更有效率的使用内存：使用DRAM当做部分的虚拟地址空间的缓存</li>
<li>作为内存管理的工具，简化内存管理：每个进程都有统一的线性地址空间</li>
<li>作为内存保护的工具，分隔地址空间：进程的内存不会相互影响；用户程序不能访问保密的内核信息和代码</li>
</ul>

<p>下面一节具体讲解虚拟内存的这三个角色。</p>

<h2 id="toc_1">2 虚拟内存的三个角色</h2>

<h3 id="toc_2">2.1 作为缓存的工具</h3>

<p>可以把主存DRAM看作是虚拟内存的缓存，类似于L1、L2、L3高速缓存是DRAM内存的缓存。也就是说可以把虚拟内存看成是存储器层次结构的一部分。</p>

<p><img src="media/15164033620970/vm_as_cache.png" alt="vm_as_cache"/></p>

<p>和其他存储器层次结构中的缓存一样，较低层上的数据被分割成块，作为与较高层之间的传输单元。这里较低层是虚拟内存，分割成<strong>虚拟页</strong>(Virtual Page, VP)，虚拟页大小为\(P=2^p\)字节。类似的，这里的较高层，物理内存DRAM，被分割为<strong>物理页</strong>(Physical Page, PP)，大小也为\(P\)，也叫做页桢。</p>

<p>虚拟页的状态分为三种：</p>

<ul>
<li>未分配(Unallocated): 系统还未分配(创建)的页，不占用磁盘空间。</li>
<li>缓存的(Cached): 当前已缓存在物理内存中的已分配页。</li>
<li>未缓存的(Uncached): 未缓存在物理内存中的已分配页。</li>
</ul>

<p>那么具体是怎么判断一个虚拟页的状态呢？怎么知道虚拟页放在哪个物理页中呢？</p>

<p>物理内存中存在一个叫<strong>页表</strong>(page table)的数据结构，由操作系统负责。页表将虚拟页映射到物理页，每次内存管理单元中的<strong>地址翻译硬件</strong>将虚拟地址转换为物理地址时都会读取页表。</p>

<p>页表其实是一个页表条目(Page Table Entry, PTE)的数组。页表条目包含一个有效位(valid bit)和一个n位地址字段。</p>

<p><img src="media/15164033620970/page_table.jpg" alt="page_table"/></p>

<p>在虚拟内存的习惯说法中，DRAM缓存命中/不命中，特称为<strong>页命中</strong>/<strong>缺页</strong>(Page Fault)。</p>

<h3 id="toc_3">2.2 作为内存管理的工具</h3>

<p>操作系统为每个进程提供了一个独立的页表，也就是提供了一个独立的虚拟地址空间。多个虚拟页面可以映射到同一个共享物理页面上。虚拟内存简化了链接和加载、代码和数据共享、以及应用程序的内存分配。</p>

<h3 id="toc_4">2.3 作为内存保护的工具</h3>

<p>一方面，每个进程拥有独立的地址空间使得区分不同进程的私有内存变得容易。另一方面在每个页表条目PTE中，添加了额外的<strong>许可位</strong>(SUP, READ, WRITE, EXEC)来控制对一个虚拟页面内容的访问：</p>

<ul>
<li>SUP位表示进程是否运行在超级用户模式下才能访问</li>
<li>READ/WRITE位控制读和写的访问</li>
<li>EXEC位控制执行的访问</li>
</ul>

<p><img src="media/15164033620970/vm_protection.png" alt="vm_protection"/></p>

<p>如果违反许可条件，那么就触发段错误(segmentation fault)。</p>

<h2 id="toc_5">3 Linux虚拟内存系统</h2>

<p>Linux为每个进程维护了一个单独的虚拟地址空间。Linux将虚拟内存组织成一些<strong>区域</strong>的集合。一个区域就是已分配的虚拟内存的连续片。</p>

<p>Linux虚拟地址空间由如下几个区域组成：</p>

<ul>
<li>代码（<code>.text</code>）: 这里存放的是CPU要执行的指令。代码段是可共享的，相同的代码在内存中只会有一个拷贝，同时这个段是只读的，防止程序由于错误而修改自身的指令。</li>
<li>初始化数据段（<code>.data</code>）: 这里存放的是程序中需要明确赋初始值的变量，例如位于所有函数之外的全局变量：<code>int val=&quot;100</code>。需要强调的是，以上两段都是位于程序的可执行文件中，内核在调用<code>exec</code>函数启动该程序时从源程序文件中读入。</li>
<li>未初始化数据段（<code>.bss</code>）: 位于这一段中的数据，内核在执行该程序前，将其初始化为0或者<code>null</code>。例如出现在任何函数之外的全局变量：int sum;</li>
<li>堆（<code>Heap</code>）: 这个段用于在程序中进行动态内存申请，例如经常用到的<code>malloc</code>，<code>new</code>系列函数就是从这个段中申请内存。</li>
<li>共享库(<code>Shared Library</code>): 用来存放像C标准库和数学哭这样的共享库的代码和数据的区域。</li>
<li>栈（<code>Stack</code>）: 函数中的局部变量以及在函数调用过程中产生的临时变量都保存在此段中，具体见下面一节。</li>
<li>内核虚拟内存：包含内核中的代码和数据结构。</li>
</ul>

<p><img src="media/15089188725996/linux_virtual_memory.png" alt="linux_virtual_memory"/></p>

<h3 id="toc_6">3.1 Linux是如何组织虚拟内存的</h3>

<p>那么Linux具体是怎么组织虚拟内存的呢？Linux内核为系统中的每个进程维护一个单独的任务结构体(<code>task_struct</code>, 在<code>sched.h</code>头文件中)。<code>task_struct</code>中的元素包含运行该进程所需要的所有信息(PID、指向用户栈的指针、可执行目标文件的名字、以及程序计数器)。</p>

<p><img src="media/15164033620970/vm_linux.png" alt="vm_linux"/></p>

<p><code>task_struct</code>中的一个元素指向<code>mm_struct</code>，它描述了虚拟内存的当前状态。<code>pgd</code>指向第一级页表的基址，而<code>mmap</code>指向一个<code>vm_area_struct</code>(区域结构, 定义在<code>mm_types.h</code>)的链表。每个区域结构链表都描述了虚拟地址空间的一个区域，包含以下字段：</p>

<ul>
<li><code>vm_start</code>: 指向区域的起始处</li>
<li><code>vm_end</code>: 指向区域的结束处</li>
<li><code>vm_prot</code>: 描述着区域内包含的所有页的读写许可权限</li>
<li><code>vm_flags</code>: 描述进程共享/私有</li>
<li><code>vm_next</code>: 下一个区域结构</li>
</ul>

<h3 id="toc_7">3.2 Linux 缺页异常处理</h3>

<p>内存管理单元MMU在试图翻译某个虚拟地址A时，触发了一个缺页异常，引起缺页异常处理程序：</p>

<ul>
<li>虚拟地址A是合法的吗？-&gt; 段错误(segment fault)</li>
<li>试图进行的内存访问是合法的吗？ -&gt; 保护异常(也引发段错误)</li>
</ul>

<p><img src="media/15164033620970/linux_page_fault.png" alt="linux_page_fault"/></p>

<h2 id="toc_8">4 动态内存分配</h2>

<p>程序使用动态内存分配的最重要的原因是经常直到程序实际运行时，才知道某些数据结构的大小。一般使用动态内存分配器(dynamic memeory allocator)来分配动态内存。</p>

<p>分配器根据哪个实体来负责释放已分配的块，分为两种：</p>

<ul>
<li>显示分配器(explicit allocator)：要求程序显示地释放任何已分配的块。例如C中的malloc/free，C++中的new/delete。</li>
<li>隐式分配器(implicit allocator): 除此之外，自动释放未使用的已分配块(垃圾收集，garbage collection)。</li>
</ul>

<h3 id="toc_9">4.2 显式分配器的要求和目标</h3>

<h4 id="toc_10">4.2.1 分配器的要求</h4>

<p>分配器有如下的要求：</p>

<ul>
<li>处理任意请求序列</li>
<li>立即相应请求</li>
<li>只使用堆</li>
<li>对齐块(对齐要求)</li>
<li>不修改已分配的块</li>
</ul>

<h4 id="toc_11">4.2.2 分配器的目标</h4>

<p>分配器试图最大化吞吐率和内存利用率</p>

<ul>
<li>最大化吞吐率(吞吐率：每个单位时间里完成的请求数)</li>
<li>最大化内存利用率</li>
</ul>

<p>最大化吞吐率和最大化利用率之间是相互 <u>牵制</u> 的，分配器设计的目标是在这两者之间找到一个适当的平衡。</p>

<p>造成利用率很低的主要原因是<strong>碎片</strong>(fragmentation)现象。当有效载荷比块要小时，发生<strong>内部碎片</strong>(Internal fragmentation)，引起的原因有：对齐等。</p>

<p><img src="media/15164033620970/internal_fragmentation.png" alt="internal_fragmentation"/></p>

<p>当即使有足够的累积的块内存，但是没有单一块能够满足需求时，发生<strong>外部碎片</strong>(external fragmentation)：</p>

<p><img src="media/15164033620970/external_fragmentation.png" alt="external_fragmentation"/></p>

<p>外部碎片还取决于将来的请求，例如上图，如果最后的p4请求4个字节呢？也就不会发生碎片。正因为外部碎片难以量化且不可能预测，所以分配器通常采用启发式策略来试图维持少量的大空闲块，而不是维持大量的小空闲块。</p>

<h3 id="toc_12">4.3 实现方法</h3>

<ul>
<li>隐式空闲列表 Implicit Free List</li>
<li>显式空闲列表 Explicit Free List</li>
<li>分离式空闲列表 Segregated Free List</li>
</ul>

<h4 id="toc_13">4.3.1 隐式空闲列表</h4>

<p><img src="media/15164033620970/implicit_list.png" alt="implicit_list"/></p>

<p>隐式空闲链表优点是简单，缺点是操作开销大。因为无论是分配还是释放块，都需要对隐式空闲列表进行搜索，复杂度是\(O(n)\)，\(n\)是已分配块和空闲块的总数。</p>

<h4 id="toc_14">4.3.1 显式空闲列表</h4>

<p><img src="media/15164033620970/explict_list.png" alt="explict_list"/></p>

<h4 id="toc_15">4.3.1 分离式空闲列表</h4>

<h2 id="toc_16">5 C程序中常见的与内存有关的错误</h2>

<h4 id="toc_17">5.1 间接引用坏指针</h4>

<p>这是非常常见的例子，没有引用对应的地址，少了 &amp;</p>

<pre><code class="language-c">int val;
scanf(&quot;%d&quot;, val); // 正确应该是scanf(&quot;%d, &amp;val);
</code></pre>

<h4 id="toc_18">5.2 读未初始化的内存</h4>

<p><strong>堆内存是没有被初始化为0的</strong>：</p>

<pre><code class="language-c">/* return y = Ax */
int *matvec(int **A, int *x) {
    int *y = malloc(N * sizeof(int));
    int i, j;
    
    for (i = 0; i &lt; N; i++)
        for (j = 0; j &lt; N; j++)
            y[i] += A[i][j] * x[j];
    return y;
}
</code></pre>

<p>正确的方法是显式地将y[i]设置为0，或者使用<code>calloc</code>。</p>

<h4 id="toc_19">5.3 允许栈缓冲区溢出</h4>

<p>没有检查字符串的长度（经典的缓冲区溢出攻击也是利用相同的机制）</p>

<pre><code class="language-c">char s[8];
int i;
gets(s); /* stack buffer overflow, reads &quot;123456789&quot; from stdin */
</code></pre>

<h4 id="toc_20">5.4 引用不存在的变量</h4>

<p>尽管指针仍然指向一个合法的内存地址，但是已经不再指向一个合法的变量了。以后在程序中调用其他函数时，内存将重用它们的栈针。</p>

<pre><code class="language-c">int *foo() {
    int val;
    
    return &amp;val;
}
</code></pre>

<h4 id="toc_21">5.5 多次释放</h4>

<p>这个不用多说，不能重复搞两次</p>

<pre><code class="language-c">x = malloc(N * sizeof(int));
//  &lt;manipulate x&gt;
free(x);
y = malloc(M * sizeof(int));
//  &lt;manipulate y&gt;
free(x);
</code></pre>

<h4 id="toc_22">5.6 引用已经被释放的堆块中的数据</h4>

<p>同样是很明显的错误，不要犯</p>

<pre><code class="language-c">x = malloc(N * sizeof(int));
//  &lt;manipulate x&gt;
free(x);
//  ....
y = malloc(M * sizeof(int));
for (i = 0; i &lt; M; i++)
    y[i] = x[i]++;
</code></pre>

<h4 id="toc_23">内存泄漏</h4>

<p>5.7忘记释放已分配块：</p>

<pre><code class="language-c">foo() {
    int *x = malloc(N * sizeof(int));
    // ...
    return ;
}
</code></pre>

<p>或者只释放了数据结构的一部分：</p>

<pre><code class="language-c">struct list {
    int val;
    struct list *next;
};
foo() {
    struct list *head = malloc(sizeof(struct list));
    head-&gt;val = 0;
    head-&gt;next = NULL;
    //...
    free(head);
    return;
}
</code></pre>

<h2 id="toc_24">6 core i7内存系统</h2>

<p>Core i7在2008年冬季发布，基于全新Nehalem架构，它的芯片结构如下所示：</p>

<p><img src="media/15164033620970/15312857062358.png" alt=""/></p>

<p>抽象的内存系统：</p>

<p><img src="media/15164033620970/corei7.png" alt="corei7"/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/1/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Computer%20System.html'>Computer System</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="Computer System_1.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="Computer System_3.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="http://or9a8nskt.bkt.clouddn.com/figure.jpeg" /></div>
            
                <h1>techlarry</h1>
                <div class="site-des">他山之石，可以攻玉</div>
                <div class="social">









<a target="_blank" class="github" target="_blank" href="https://github.com/techlarry" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:wang.zhen.hua.larry@gmail.com" title="Email">Email</a>
  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Leetcode.html"><strong>Leetcode</strong></a>
        
            <a href="programming_language.html"><strong>编程语言</strong></a>
        
            <a href="data_structure_and_algorithm.html"><strong>数据结构和算法</strong></a>
        
            <a href="Python%E7%89%B9%E6%80%A7.html"><strong>Python特性</strong></a>
        
            <a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html"><strong>机器学习</strong></a>
        
            <a href="Python%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96.html"><strong>Python科学计算三维可视化</strong></a>
        
            <a href="English.html"><strong>English</strong></a>
        
            <a href="Computer%20System.html"><strong>Computer System</strong></a>
        
            <a href="Deep%20Learning.html"><strong>Deep Learning</strong></a>
        
            <a href="Linux%20%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html"><strong>Linux 系统编程</strong></a>
        
            <a href="%E6%95%B0%E6%8D%AE%E5%BA%93.html"><strong>数据库</strong></a>
        
            <a href="Tensorflow.html"><strong>Tensorflow</strong></a>
        
            <a href="Big%20Data.html"><strong>Big Data</strong></a>
        
            <a href="%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB.html"><strong>文献阅读</strong></a>
        
            <a href="Tools.html"><strong>Tools</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="os_concepts_synchronization_tools.html">Operating System Concepts 6 - Synchronization Tools</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="os_concepts_synchronization_examples.html">Operating System Concepts 7 - Synchronization Examples</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="os-concets-processes.html">Operating System Concepts 3 - Processes</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="diagrammatize_TCP_IP.html">图解TCP/IP</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="csapp-internet-programming.html">CSAPP - 网络编程</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
