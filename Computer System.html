<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Computer System - techlarry
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="techlarry" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:larryim.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">HomePage</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        <li id=""><a target="_blank" href="wiki">WIKI</a></li>
        
        <li id=""><a target="_self" href="notebook.html">NOTEBOOK</a></li>
        
        <li id=""><a target="_self" href="about.html">About</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="http://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; techlarry</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">HomePage</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        
        <li><a target="_blank" href="wiki">WIKI</a></li>
        
        <li><a target="_self" href="notebook.html">NOTEBOOK</a></li>
        
        <li><a target="_self" href="about.html">About</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Leetcode.html">Leetcode</a></li>
        
            <li><a href="C/C++.html">C/C++</a></li>
        
            <li><a href="Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html">Python数据结构与算法</a></li>
        
            <li><a href="Course.html">Course</a></li>
        
            <li><a href="Python%E7%89%B9%E6%80%A7.html">Python特性</a></li>
        
            <li><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html">机器学习</a></li>
        
            <li><a href="Python%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96.html">Python科学计算三维可视化</a></li>
        
            <li><a href="English.html">English</a></li>
        
            <li><a href="Computer%20System.html">Computer System</a></li>
        
            <li><a href="Deep%20Learning.html">Deep Learning</a></li>
        
            <li><a href="Linux%20%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html">Linux 系统编程</a></li>
        
            <li><a href="%E6%95%B0%E6%8D%AE%E5%BA%93.html">数据库</a></li>
        
            <li><a href="Tensorflow.html">Tensorflow</a></li>
        
            <li><a href="Big%20Data.html">Big Data</a></li>
        
            <li><a href="%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB.html">文献阅读</a></li>
        
            <li><a href="Tools.html">Tools</a></li>
        
            <li><a href="%E5%A4%A7%E6%95%B0%E6%8D%AE.html">大数据</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="os-concets-processes.html">
                
                  <h1>Operating System Concepts 3 - Processes</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">1 Process concept</a>
<ul>
<li>
<a href="#toc_1">1.1 The process</a>
</li>
<li>
<a href="#toc_2">1.2 Process state 进程状态</a>
</li>
<li>
<a href="#toc_3">1.3 Process control block</a>
</li>
</ul>
</li>
<li>
<a href="#toc_4">2 Process scheduling 进程调度</a>
<ul>
<li>
<a href="#toc_5">2.1 Scheduling Queues</a>
</li>
<li>
<a href="#toc_6">2.2 context switch</a>
</li>
</ul>
</li>
<li>
<a href="#toc_7">3 Operating on Processes</a>
<ul>
<li>
<a href="#toc_8">3.1 Process creation</a>
</li>
<li>
<a href="#toc_9">3.2 Process termintation</a>
</li>
</ul>
</li>
<li>
<a href="#toc_10">4 Interprocess communication</a>
</li>
<li>
<a href="#toc_11">5 IPC in shared-memory system</a>
</li>
<li>
<a href="#toc_12">6 IPC in message-passing system</a>
<ul>
<li>
<a href="#toc_13">6.1 Direct/Indirect communication</a>
<ul>
<li>
<a href="#toc_14"><strong>Direct Communication</strong></a>
</li>
<li>
<a href="#toc_15"><strong>Indirect Communication</strong></a>
</li>
</ul>
</li>
<li>
<a href="#toc_16">6.2 Synchronization</a>
</li>
<li>
<a href="#toc_17">6.3 Buffering</a>
</li>
</ul>
</li>
<li>
<a href="#toc_18">7 Examples of IPC</a>
<ul>
<li>
<a href="#toc_19">7.1 Mach Message Passing</a>
</li>
<li>
<a href="#toc_20">7.2 Pipes</a>
<ul>
<li>
<a href="#toc_21">(1) Ordinary pipes</a>
</li>
<li>
<a href="#toc_22">(2) Named pipes</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_23">8 Communication in Client-server system</a>
</li>
<li>
<a href="#toc_24">8.1 sockets</a>
</li>
<li>
<a href="#toc_25">8.2 Remote procedure calls</a>
</li>
</ul>


<p><strong>Process</strong> (进程) is a program in execution.</p>

<ul>
<li>the unit of work in a modern computing system</li>
</ul>

<h2 id="toc_0">1 Process concept</h2>

<h3 id="toc_1">1.1 The process</h3>

<p>The status of the <strong>current</strong> activity of a process is represented by the value of the <strong>program counter</strong> and the contents of the processor&#39;s <strong>registers</strong>.</p>

<p>A program by itself is not a process.</p>

<ul>
<li>A program is a <strong>passive</strong> entity, such as a file containing a list of instructions stored on disk</li>
<li>A process is an <strong>active</strong> entity, with a program counter specifying the next instruction to execute</li>
</ul>

<h3 id="toc_2">1.2 Process state 进程状态</h3>

<p>A process may be in one of the following states:</p>

<ul>
<li><strong>New</strong>(新建). The process is being created. 进程正在被创建</li>
<li><strong>Running</strong>(运行). Instructions are being executed.指令正在被执行</li>
<li><strong>Waiting</strong>(等待). The process is waiting for some event to occur(such as an I/O completion or reception of a signal). 进程等待某些事件发生</li>
<li><strong>Ready</strong>(就绪). The process is waiting to be assigned to a processor.进程等待分配处理器</li>
<li><strong>Terminated</strong>(终止). The process has finished execution.进程执行完毕</li>
</ul>

<p>Diagram of process state:<br/>
<img src="media/15317585001692/diagramofprocessstate.png" alt="Diagram of process state"/></p>

<h3 id="toc_3">1.3 Process control block</h3>

<p>Each process is represented by a <strong>process control block</strong>(PCB, 进程控制块), it contains</p>

<ul>
<li><strong>Process state</strong>(进程状态)</li>
<li><strong>Program counter</strong>(程序计数器)</li>
<li><strong>CPU registers</strong>(CPU寄存器)</li>
<li><strong>CPU-scheduling information</strong>(CPU调度信息): a process priority, pointers to scheduling queues, and any other scheduling parameters.</li>
<li><strong>Memory-management information</strong>(内存管理信息)</li>
<li><strong>Accounting information</strong>(记账信息): the amount of CPU and real time used, time limits, account numbers, process numbers and so on.</li>
<li><strong>I/O status information</strong>(I/O状态信息): the list of I/O devices allocated to the process, a list of open files</li>
</ul>

<p>Process Control Block:<br/>
<img src="media/15317585001692/processcontrolblock.png" alt="process control block"/></p>

<p>The process control block in Linux is represented by the C structure <code>task_struct</code> (&#39;include/linux/sched.h&#39;)， <a href="https://elixir.bootlin.com/linux/latest/source/include/linux/sched.h#L592">CODE LINK</a></p>

<ul>
<li>Within the Linux kernel, all active processes are represented using a <strong>doubly linked list</strong> of task struct.</li>
</ul>

<p>Task_strut:<br/>
<img src="media/15317585001692/task_strcut%20in%20Linux.png" alt="task_strcut in Linux"/></p>

<h2 id="toc_4">2 Process scheduling 进程调度</h2>

<p>The <strong>process scheduler</strong>(进程调度程序) selects an available process for program execution on a core.</p>

<ul>
<li>Each CPU core can run one process at a time.</li>
<li>The number of processes currently in memory is known as the <strong>degree of multiprogramming</strong>.</li>
</ul>

<h3 id="toc_5">2.1 Scheduling Queues</h3>

<p><strong>Ready queue</strong>(就绪队列): the status of processes are ready.</p>

<ul>
<li>generally stored as a linked list, its header contains pointers to the first PCB in the list, each PCB includes a pointer field that points to next PCB in the ready queue.</li>
</ul>

<p><strong>Wait Queue</strong>(等待队列): the status of processes are waiting.</p>

<p>Queueing-diagram representation of process scheduling: <br/>
<img src="media/15317585001692/Queueing-diagram%20representation%20of%20process%20scheduling.png" alt="Queueing-diagram representation of process scheduling"/></p>

<h3 id="toc_6">2.2 context switch</h3>

<p>Here the <strong><em>context</em></strong> of a process is represented in the PCB of the process, including the value of the CPU registers, the process state, and memory-management information.</p>

<p>An operating system performs a <strong>context switch</strong>（上下文切换) when it switches from running one process to running another.</p>

<ul>
<li>The kernel <strong>saves</strong> the context of the old process into its PCB and <strong>restore</strong> the saved context of the new process scheduled to run.</li>
<li>Context-switch time is overhead; the system does no useful work while switching. 
<ul>
<li>A typical speed is a several microseconds. </li>
</ul></li>
<li>Context-switch times are <strong>highly</strong> dependent on hardware support.</li>
</ul>

<p>Context switch from an old process to a new process:<br/>
<img src="media/15317585001692/context%20switch%20from%20process%20to%20process.png" alt="context switch from process to process"/></p>

<h2 id="toc_7">3 Operating on Processes</h2>

<h3 id="toc_8">3.1 Process creation</h3>

<p>A process may <strong>create</strong> several new processes.</p>

<ul>
<li>the creating process is called a <strong>parent process</strong>.</li>
<li>the new process is called a <strong>child process</strong> .</li>
</ul>

<p><img src="media/15317585001692/process%20creating%20using%20the%20fork--%20system%20call.png" alt="process creating using the fork-- system cal"/></p>

<h3 id="toc_9">3.2 Process termintation</h3>

<p>A process <strong>terminates</strong> when it finishes executing its final statement and asks the operating system to delete it by using the <code>exit()</code> system call.</p>

<ul>
<li><strong>cascading termination</strong>(级联终止):  if a process terminates (either normally or abnormally), then all its children must also be terminated. </li>
<li>A process that has terminated, but whose parent has not yet called <code>wait()</code>, is known as a <strong>zombie process</strong>(僵尸进程).</li>
<li>if a parent did not invoke <code>wait()</code> and instead terminated, then leaving its child processes as <strong>orphan processes</strong>(孤儿进程).
<ul>
<li>Unix system may assign the <code>init</code> process as the new parent to orphan processes, and the <code>init</code> process periodically invokes <code>wait()</code>.</li>
</ul></li>
</ul>

<h2 id="toc_10">4 Interprocess communication</h2>

<p>Processes may be either <strong>independent processes</strong>(独立进程) or <strong>cooperating processes</strong>(协同进程).</p>

<ul>
<li>A process is <strong><em>independent</em></strong> if it does not share data with any other processes executing in the system.</li>
<li>A process is <strong><em>cooperating</em></strong> if it can affect or be affected by the other processes executing in the system.</li>
</ul>

<p>Advantages of  process cooperation:</p>

<ul>
<li>Information sharing 信息共享</li>
<li>Computation speedup 加速运算</li>
<li>Modularity 模块化</li>
</ul>

<p>Cooperating process require an <strong>interprocess communication</strong> (IPC，进程间通信) mechanism that will allow them to <strong>exchange</strong> data. There are two fundamental models of IPC:</p>

<ul>
<li><strong>shared memory</strong>（共享内存）: a region of memory is shared by cooperating process. Process can exchange information by reading and writing data to the shared region.
<ul>
<li>Shared memory can be <strong>faster</strong> than message passing.</li>
</ul></li>
<li><strong>message passing</strong>(消息传递)： communication takes place by means of messages exchanged between the cooperating processes.
<ul>
<li>Message passing is useful for exchanging <strong>smaller</strong> amounts of data, because no conflicts need be avoided.</li>
<li>Message passing is easier to implement in a distributed system than shared memory.</li>
</ul></li>
</ul>

<p><img src="media/15317585001692/sharedmemory%20and%20message%20passing.png" alt="sharedmemory and message passing"/></p>

<h2 id="toc_11">5 IPC in shared-memory system</h2>

<p>Here, we explore the POSIX API for shared memory. POSIX shared memory is organized using <strong>memory-mapped files</strong> (内存映射文件), which associate the region of shared memory with a file. A process must first create a shared-memory object using the <code>shm_open()</code> system call, as follows:</p>

<pre><code class="language-c">fd = shm_open(name, O_CREAT | O_RDWR, 0666);
ftruncate(fd, 4096);
mmap(0, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
</code></pre>

<ul>
<li>A successful call to <code>shm_open()</code> returns an integer file descriptor for the shared-memory object.</li>
<li>Once the object is established, the <code>ftruncate</code> function is used to configure the size of the object in bytes.</li>
<li>Finally, the <code>mmap()</code> function establishes a memory-mapped file containing the shared-memory object. It returns a pointer to the shared</li>
</ul>

<h2 id="toc_12">6 IPC in message-passing system</h2>

<p>A message-passing facility provides at least two operations:</p>

<ul>
<li>send(message)</li>
<li>receive(message)</li>
</ul>

<p>If P and Q wish to communicate, they need to</p>

<ul>
<li>establish a <strong>communication link</strong>(通信连接) between them</li>
<li>exchange messages via send/receive </li>
</ul>

<p>Here are several methods for logically implementing a <em>communication link</em> between processes:</p>

<ul>
<li>Direct or indirect communication 直接/间接通信</li>
<li>Synchronous or asynchronous communication 同步/异步同步</li>
<li>Automatic or explicit buffering 自动/显式缓冲</li>
</ul>

<h3 id="toc_13">6.1 Direct/Indirect communication</h3>

<h4 id="toc_14"><strong>Direct Communication</strong></h4>

<p>Under <strong>direct communication</strong>, each process that wants to communicate must explicitly name the recipient or sender of the communication.</p>

<ul>
<li>send(P, message) - send a message to process P.</li>
<li>receive(Q, message) - receive a message from process Q</li>
</ul>

<p>A communication link in this scheme has the following properties:</p>

<ul>
<li>A link is established <strong>automatically</strong> between every pair of processes that want to communicate.</li>
<li>A link is associated with <strong>exactly two</strong> processes.</li>
<li>Between each pair of processes, there exists exactly one link.</li>
</ul>

<p>Cons:</p>

<ul>
<li>limited modularity of the resulting process definitions. Changing the identifier of a process may necessiate examining all other process definitions.</li>
<li>any such hard-coding techniques, are less desirable.</li>
</ul>

<h4 id="toc_15"><strong>Indirect Communication</strong></h4>

<p>With <strong>indirect communication</strong>, the message are sent to and receive from <strong>mailboxes</strong>, or <strong>ports</strong>.</p>

<ul>
<li>send(A, message) - send a message to mailbox A</li>
<li>receive(A, message) - receive a message from mailbox A</li>
</ul>

<p>A mailbox can be viewed abstractly as an object into which messages can be placed by processes and from which messages can be removed.</p>

<ul>
<li>Each mailbox has an <strong>unique</strong> identification.</li>
<li>Two processes can communicate only if they have a shared mailbox.</li>
</ul>

<p>In this scheme, a communication link has the following properties:</p>

<ul>
<li>A link is established between a pair of processes only if both members of the pair have a shared mailbox.</li>
<li>A link may be associated with more than two processes.</li>
<li>Between each pair of communicating processes, a number of different links may exist, with each link corresponding to one mailbox.</li>
</ul>

<p>A mailbox may be owned either by a process or by the operating system.</p>

<p>If the mailbox is owned by a process</p>

<ul>
<li>We distinguish between the <strong>owner</strong> (which can only receive messages through his mailbox) and the <strong>user</strong> (which can only send messages to the mailbox)</li>
<li>Each mailbox has a unique owner.</li>
<li>When a process that owns a mailbox terminates, the mailbox disappears.</li>
<li>The process that creates a new mailbox is that mailbox&#39;s owner by default.</li>
</ul>

<h3 id="toc_16">6.2 Synchronization</h3>

<p>Message passing may be either <strong>blocking</strong> or <strong>nonblocking</strong> - also known as <strong>synchronous</strong> and <strong>asynchronous</strong>.</p>

<h3 id="toc_17">6.3 Buffering</h3>

<p>Messages exchanged by communicating processes reside in a temporary queue, whether communication is direct or indirect. Basically, it can be implemented in three ways:</p>

<ul>
<li>Zero capacity（零容量）-- no buffering
<ul>
<li>The link cannot have any messages waiting in it.</li>
<li>The sender must block until the recipient receives the message. </li>
</ul></li>
<li>Bounded capacity（有界容量）-- automatic buffering
<ul>
<li>The queue has finite length n, at most n message can reside in it.<br/></li>
<li>The sender must block until space is available in the queue if the link is full.<br/></li>
</ul></li>
<li>Unbounded capacity （无界容量） -- automatic buffering
<ul>
<li>Any number of messages can wait in it.</li>
<li>The sender never blocks. </li>
</ul></li>
</ul>

<h2 id="toc_18">7 Examples of IPC</h2>

<h3 id="toc_19">7.1 Mach Message Passing</h3>

<p>Mach was especially designed for distributed systems. Its kernel supports the creation and destruction of multiple <strong>tasks</strong>, which are similar to processes but have multiple threads of control and fewer associated resources.  </p>

<p>Messages are sent to, and received from, mailboxes, which are called <strong>ports</strong> in Mach. </p>

<ul>
<li>Ports are finite in size and unidirectional.</li>
<li>for two-way communication, a message is sent to one port, and a response is sent to a separate <strong>reply</strong> port.</li>
<li>Associated with each port is a collection of <strong>port rights</strong>, which  identify the capabilities necessary for a task to interact with the port.</li>
</ul>

<p>Functions:</p>

<ul>
<li><code>mach_port_allocate()</code> creates a new port and allocates space for its queue of messages.</li>
<li><code>mach_msg()</code> is the standard API for both sending and receiving messages.</li>
</ul>

<pre><code class="language-c">#include &lt;mach/mach.h&gt;

struct message {
    mach_msg_header_t header;
    int data;
};

mach_port_t client;
mach_port_t server;

/* Client Code */

struct message message;

// construct the header
message.header.msgh_size = sizeof(message);
message.header.msgh_remote_port = server;
message.header.msgh_local_port = client;

// send the message
mach msg(&amp;message.header, // message header
         MACH_SEND_MSG, // sending a message
         sizeof(message), // size of message sent
         0, // maximum size of received message - unnecessary
         MACH_PORT_NULL, // name of receive port - unnecessary
         MACH_MSG_TIMEOUT_NONE, // no time outs MACH PORT NULL // no notify port
);

/* Server Code */

struct message message;

// receive the message
mach_msg(&amp;message.header, // message header
  MACH_RCV_MSG, // sending a message  0, // size of message sent
  sizeof(message), // maximum size of received message
  server, // name of receive port
  MACH_MSG_TIMEOUT_NONE, // no time outs
  MACH_PORT_NULL // no notify port
);
</code></pre>

<h3 id="toc_20">7.2 Pipes</h3>

<p>A <strong>pipe</strong> acts as a conduit allowing two processes to communicate. There are two common types of pipes used on both UNIX and Windows systems: <strong>ordinary pipes</strong> and <strong>named pipes</strong>.</p>

<h4 id="toc_21">(1) Ordinary pipes</h4>

<p><strong>Ordinary pipes</strong> allow two processes to communicate in standard producer-consumer fashion: the producer writes to one end of the pipe (the <strong>write end</strong>) and the consumer reads from the other end (the <strong>read end</strong>).</p>

<ul>
<li>Ordinary pipes are <strong>unidirectional</strong>, allowing only one-way communication.</li>
<li>Function <code>pipe(int fd[])</code> constructs an ordinary pipe, where <code>fd</code> is a file descriptor.</li>
<li>UNIX treats a pipe as <em>a special type of file</em>. Pipes can be accessed using ordinary <code>read()</code> and <code>write()</code> system calls.</li>
<li>Ordinary pipes <strong>exit only</strong> while the processes are communicating with each other.</li>
</ul>

<p><img src="media/15317585001692/file%20descriptors%20for%20an%20ordinary%20pipes.png" alt="file descriptors for an ordinary pipes"/></p>

<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;

#define BUFFER_SIZE 25
#define READ_END 0
#define WRITE_END 1

int main(void)
{
        char write_msg[BUFFER_SIZE] = &quot;Greetings&quot;;
        char read_msg[BUFFER_SIZE];
        int fd[2];
        pid_t pid;

        /* create the pipe */
        if (pipe(fd) == -1){
                fprintf(stderr, &quot;Pipe failed&quot;);
                return 1;
        }

        /* fork a child process */
        pid = fork();

        if (pid&gt;0){ /* parent process */
                close(fd[READ_END]);/* close the unused end of the pipe */
                write(fd[WRITE_END], write_msg, strlen(write_msg)+1); /* write to the pipe */
                close(fd[WRITE_END]);  /* close the write end of the pipe */
        }
        else if (pid==0){ /* child process */
                close(fd[WRITE_END]); /* close the unused end of the pipe */
                read(fd[READ_END], read_msg, BUFFER_SIZE); /* read from the pipe */
                printf(&quot;read: %s\n&quot;, read_msg);
                close(fd[READ_END]); /* close the read end of the pipe */
        }
        return 0;

}
</code></pre>

<h4 id="toc_22">(2) Named pipes</h4>

<p>Named pipes can be bidirectional, and no parent-child relationship is required.</p>

<ul>
<li>Named pipes are referred to as FIFOs in UNIX system.</li>
<li>The communicating processes for named pipes must reside on the same machine.</li>
</ul>

<h2 id="toc_23">8 Communication in Client-server system</h2>

<p>In this section, we explore two other strategies for communication in client-server system: <strong>sockets</strong> and <strong>remote procedure calls</strong>(RPCs)</p>

<h2 id="toc_24">8.1 sockets</h2>

<p>A socket（套接字）is defined as an endpoint for communication. A socket is identified by an IP address concatenated with a port number.</p>

<p>Communication using sockets<br/>
<img src="media/15317585001692/communication%20using%20sockets.png" alt="communication using sockets"/></p>

<h2 id="toc_25">8.2 Remote procedure calls</h2>

<p>Remote Procedure Call（远程过程调用）allows programs on different machines to interact using simple procedure call/return semantics, just as if the two programs were in the same computer。</p>

<p>RPC between a client and a serve：<br/>
<img src="media/15317585001692/RPC%20between%20a%20client%20and%20a%20server.png" alt="RPC between a client and a serve"/></p>

<p>RPC hides all the network code into the stub procedures. This prevents the application programs, the client and the server, from having to worry about details such as sockets, network byte order, and the like.</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/2/25</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Computer%20System.html'>Computer System</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="os-concepts-introduction.html">
                
                  <h1>Operating System Concepts 1 - Introduction</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">what operating system do</a>
</li>
<li>
<a href="#toc_1">Computer-system organisation</a>
</li>
<li>
<a href="#toc_2">Interrupt</a>
<ul>
<li>
<a href="#toc_3">interrupt, exception, trap</a>
</li>
</ul>
</li>
<li>
<a href="#toc_4">multiprogramming and multitasking</a>
</li>
<li>
<a href="#toc_5">dual-mode</a>
</li>
<li>
<a href="#toc_6">timer</a>
</li>
<li>
<a href="#toc_7">virtualization</a>
</li>
<li>
<a href="#toc_8">Free and Open-Source OS</a>
</li>
</ul>


<h2 id="toc_0">what operating system do</h2>

<p>There is no completely adequate definition of operating system. A simple viewpoint is that it includes everything a vendor ships. A more common definition is that the <u>operating system is the one program running at all times on computer - usually  called <strong>kernel</strong></u> . </p>

<p>Three main <strong>purposes</strong> of an operating system are,</p>

<ul>
<li>manages a computer&#39;s hardware</li>
<li>provides a basis for application programs</li>
<li>acts as an intermediary between the user and hardware</li>
</ul>

<p>The operating system includes the always running <strong>kernel</strong>, <strong>middleware</strong> frameworks that ease application development and provide features, and <strong>system programs</strong> that aid in managing the system while it is running.</p>

<p>Anything between the kernel and user applications is considered <strong>middleware</strong>(中间件) [<a href="https://en.wikipedia.org/wiki/Middleware">1</a>].</p>

<h2 id="toc_1">Computer-system organisation</h2>

<p>A computer system can be divided roughly into four components: the <strong>hardware</strong>, the <strong>operating system</strong>, the <strong>application programs</strong>, and a <strong>user</strong>.</p>

<p><img src="http://or9a8nskt.bkt.clouddn.com/abstractviewofcomputersytem.png" alt="Abstract view of the components of a computer system"/></p>

<p>A <strong>computer system</strong>(计算机系统) consists of one or more <strong>CPUs</strong> and a number of <strong>device controllers</strong>(设备控制器) connected through a common <strong>bus</strong>(总线) that provides access between components and shared <strong>memory</strong>.</p>

<p>A <strong>device controller</strong> maintains some <strong>local buffer storage</strong>(局部缓冲存储) and a set of special-purpose <strong>registers</strong>.</p>

<hr/>

<p>Typically, operating systems have a <strong>device driver</strong>(设备驱动) for each device controller. This device driver understands the device controller and provides the rest of the operating system with a uniform interface to the device</p>

<p><img src="http://or9a8nskt.bkt.clouddn.com/AtypicalPCcomputerSystem.png" alt="一个典型的PC计算机系统"/></p>

<h2 id="toc_2">Interrupt</h2>

<p>When the CPU is <strong>interrupted</strong>, it stops what it is doing and immediately transfers execution to a fixed location. The fixed location usually contains the starting address where the service routine for the interrupt is located.</p>

<p>The <strong>interrupt routine</strong>(中断程序) is called indirectly through the interrupt vector table（中断向量表).</p>

<ul>
<li>Generally, the table of pointers is stored in low memory (the first hundred or so locations).</li>
<li>These locations hold the addresses of the interrupt service routines for the various devices.</li>
<li>Interrupt vector is then indexed by a unique number(interrupt vector number, 中断向量号)</li>
<li>interrupt priority levels(中断优先级)</li>
</ul>

<p><img src="http://or9a8nskt.bkt.clouddn.com/interruptvectortable.png" alt="中断向量号"/></p>

<p>Some <strong>services</strong> are provided outside of the kernel by system programs that are loaded into memory at boot time to become system <strong>daemons</strong>, which run the entire time the kernel is running.</p>

<p><img src="http://or9a8nskt.bkt.clouddn.com/interrupt-driven%20I:O%20cycle.png" alt="interrupt-driven I:O cycle"/></p>

<h3 id="toc_3">interrupt, exception, trap</h3>

<p>Unfortunately, there is no clear consensus as to the exact meaning of these terms(exceptions, faults, aborts, traps, and interrupts). Different authors adopt different terms to their own use [<a href="http://www.plantation-productions.com/Webster/www.artofasm.com/DOS/pdf/ch17.pdf">ref</a>].</p>

<p><strong>trap</strong>(陷阱) or <strong>exception</strong>(异常): a software-generated interrupt either by an error（e.g. division by zero, or invalid memory access or by a system call.</p>

<ul>
<li>usual way to invoke a kernel routine (a system call) </li>
</ul>

<p><strong>interrupt</strong>(中断):  generated by the hardware (devices like the hard disk, graphics card, I/O ports, etc).</p>

<h2 id="toc_4">multiprogramming and multitasking</h2>

<p><strong>Multiprogramming</strong>(多道程序) explained:</p>

<ul>
<li>The operating system <strong>keeps several processes in memory</strong> simultaneously. </li>
<li>The operating system picks and begins to execute one of these processes.</li>
<li>Eventually, the process may have to wait for some task, such as an I/O operation, to complete.</li>
<li>When that process needs to wait, the CPU <strong>switches</strong> to another process, and so on.</li>
<li> Eventually, the first process finishes waiting and gets the CPU back. As long as at least one process needs to execute, the <strong>CPU is never idle</strong>.</li>
</ul>

<p><strong>Multitasking</strong>(多任务) is a logical <strong>extension</strong> of multiprogramming. In multitasking systems, the CPU executes multiple processes by switching among them, but the switches occur <strong>frequently</strong>, providing the user with a <strong>fast</strong> response time.</p>

<h2 id="toc_5">dual-mode</h2>

<p>In order to ensure the proper execution of the system, we must be able to distinguish between the execution of operating-system code（<strong>kernel mode</strong>）and user-defined code (<strong>user mode</strong>).</p>

<p><img src="http://or9a8nskt.bkt.clouddn.com/transitionfromusermodetokernelmode.png" alt="Transition from user mode to kernel mode"/></p>

<p><strong>Mode bit</strong>(模式位), is added to the hardware of the computer to indicate the current mode: kernel (0) or user (1).</p>

<p>The concept of modes can be <strong>extended</strong> beyond two modes. </p>

<ul>
<li><p><strong>protection rings</strong>（保护环) are mechanisms to protect data and functionality from faults (by improving fault tolerance) and malicious behavior (by providing computer security). </p></li>
<li><p>For intel processors, ring 0 is kernel mode and ring 3 is user mode</p></li>
</ul>

<p><img src="http://or9a8nskt.bkt.clouddn.com/15317318589869.jpg" alt=""/></p>

<h2 id="toc_6">timer</h2>

<p>A timer (定时器) can  be set to interrupt the computer after a specified period( usually, 100s hz)</p>

<ul>
<li>A variable timer is generally implemented by a fixed-rate clock and a counter. </li>
<li>The operating system sets the counter. Every time the clock ticks, the counter is decremented. </li>
<li>When the counter reaches 0, an interrupt occurs.</li>
</ul>

<h2 id="toc_7">virtualization</h2>

<p><strong>virtualization</strong>(虚拟化) is a technology that allows us to abstract the hardware of a single computer into several different execution environments, thereby creating the illusion that <u><em>each separate environment is running on its own private computer</em></u> .</p>

<ul>
<li>v.s. [different] Emulation involves simulating computer handware in software.</li>
</ul>

<p><img src="http://or9a8nskt.bkt.clouddn.com/virtualmachines.png" alt="A computer running (a) a single operating system and (b) three virtual machines"/></p>

<h2 id="toc_8">Free and Open-Source OS</h2>

<p>Open-source OS</p>

<ul>
<li>source code available</li>
<li>opposite: closed-source OS</li>
</ul>

<p>Free OS</p>

<ul>
<li>source code available</li>
<li>allow no-cost use, redistribution, and modification</li>
</ul>

<p>Arguably, open-source code is <strong>more secure</strong> than closed-source code because many more eyes are viewing the code.</p>

<p>e.g. OS</p>

<ul>
<li> GNU/Linux</li>
<li> FreeBSD</li>
<li> Solaris</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/2/16</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Computer%20System.html'>Computer System</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="os-concepts-os-structures.html">
                
                  <h1>Operating System Concepts 2 - Operating System structures</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">Operating system service</a>
</li>
<li>
<a href="#toc_1">User Interface</a>
</li>
<li>
<a href="#toc_2">System call</a>
<ul>
<li>
<a href="#toc_3">API</a>
</li>
<li>
<a href="#toc_4">Types of system calls</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">System Service</a>
</li>
<li>
<a href="#toc_6">OS Design and Implementation</a>
</li>
<li>
<a href="#toc_7">Operating system structure</a>
<ul>
<li>
<a href="#toc_8">Monolithic structure</a>
</li>
<li>
<a href="#toc_9">Layered</a>
</li>
<li>
<a href="#toc_10">Microkernel</a>
</li>
<li>
<a href="#toc_11">Modules</a>
</li>
<li>
<a href="#toc_12">Hybrid systems</a>
</li>
</ul>
</li>
<li>
<a href="#toc_13">System boot</a>
</li>
</ul>


<h2 id="toc_0">Operating system service</h2>

<p>The figure below is a view of the various operating-system services and how they interrelate.</p>

<p><img src="media/15317361625058/A%20view%20of%20operating%20system%20services.png" alt="A view of operating system services"/></p>

<h2 id="toc_1">User Interface</h2>

<p>There&#39;re mainly three ways for users to interface with the operating system:</p>

<ul>
<li>command interpreter</li>
<li>graphical user interface</li>
<li>touch-screen interface</li>
</ul>

<h2 id="toc_2">System call</h2>

<p>Purpose of System Call: System calls provide an <strong>interface to the services</strong> made available by an operating system.</p>

<h3 id="toc_3">API</h3>

<p>Typically, application developers design programs according to an application programming interface(<strong>API</strong>, 应用程序编程接口) rather than invoking <strong>actual system call</strong>.</p>

<ul>
<li>because even simple program may make heavy use of system call.</li>
<li><strong>program portabilit</strong>y: expect programs to compile and run other system that supports the same API</li>
<li><strong>run-time environment</strong>(RTE, 运行时环境) - the full suit of software needed to execute applications, including its compilers, interpreters, libraries, loaders.</li>
</ul>

<h3 id="toc_4">Types of system calls</h3>

<p>System calls can be grouped roughly into six major categories:<br/>
系统调用可分成六大类：进程控制，文件管理，设备管理，信息维护，通信和保护。</p>

<ul>
<li>process control</li>
<li>file management</li>
<li>device management</li>
<li>information maintenance</li>
<li>communications</li>
<li>protection</li>
</ul>

<p><img src="media/15317361625058/examplesofunixandlinuxsystemcalls.png" alt="Examples of Windows and Unix systemcalls"/></p>

<p>Three ways to pass parameters to the operating system:</p>

<ul>
<li>when less than five parameters, passing the parameters in registers</li>
<li>when more than five parameters, parameters are stored in a block, passing the address of the block in a register</li>
<li>using stack</li>
</ul>

<h2 id="toc_5">System Service</h2>

<p><strong>System services</strong>, also known as <strong>system utilities</strong>, provide a convenient environment for program development and execution.</p>

<h2 id="toc_6">OS Design and Implementation</h2>

<p>One important principle of OS design is <u>the separation of <strong>policy</strong> from <strong>mechanism</strong></u> . Mechanisms determine <strong>how</strong> to do something; policies determine <strong>what</strong> will be done.<br/>
操作系统设计的一个重要原则是策略（policy）和机制（mechanism）的分离。机制决定如何做，策略决定做什么。</p>

<ul>
<li>The separation of policy and mechanism is important for <strong>flexibility</strong>.</li>
</ul>

<h2 id="toc_7">Operating system structure</h2>

<h3 id="toc_8">Monolithic structure</h3>

<p>Operating systems with <strong>monolithic structure</strong> (单体结构) place all of the functionality of kernel into a <strong>single</strong>, <strong>static</strong> binary file that runs in a <strong>single</strong> address space.</p>

<ul>
<li>a common technique for designing operating system</li>
<li>e.g. original Unix operating system ( figure below)</li>
</ul>

<p><img src="media/15317361625058/traditional%20unix%20system%20structure.png" alt="Traditional Unix system structure"/></p>

<ul>
<li>e.g. Linux is based on Unix and is structured similarly, as shown in figure below.</li>
</ul>

<p><img src="media/15317361625058/linux%20system%20structure.png" alt="linux system structure"/></p>

<p>pros</p>

<ul>
<li>simplicity of kernels</li>
<li>a distinct performance advantage</li>
<li>very little overhead in the system-call interface</li>
<li>fast communication within the kernel</li>
</ul>

<p>cons</p>

<ul>
<li>difficult to implement and extend</li>
</ul>

<h3 id="toc_9">Layered</h3>

<p>A <strong>loosely coupled</strong> (松耦合) system is divided into separate, smaller components that have specific and limited functionality (<strong>modular</strong> approach). All these components together comprise the kernel .</p>

<ul>
<li>changes in one component affect only that component</li>
</ul>

<p>A system can be made modular in many ways.</p>

<ul>
<li>one way is the layered approach.</li>
</ul>

<p>For the <strong>layered operating system</strong> (层次式操作系统), it is broken into a number of layers.</p>

<ul>
<li>The bottom layer is the hardware; the highest is the user interface.</li>
<li>low-level layers can be invoked by higher-level layers</li>
</ul>

<p>pros</p>

<ul>
<li>simplicity of construction and debugging
<ul>
<li>each layer is implemented only with operations provided by lower-level layers. </li>
<li>higher-level layers can be debugged without any concern for the lower-level layers</li>
</ul></li>
</ul>

<p>cons</p>

<ul>
<li>difficulty of defining the functionality of each layer</li>
<li>poor performance
<ul>
<li>overhead of requiring a user program to traverse through multiple layers to obtain an operating-system service </li>
</ul></li>
</ul>

<p>Used in computer networks and web applications</p>

<p><img src="media/15317361625058/alayeredoperatingsystem.png" alt="A layered operating system"/></p>

<h3 id="toc_10">Microkernel</h3>

<p>Another way to modularized the kernel is using microkernel approach (微内核)。</p>

<ul>
<li><strong>removing all nonessential</strong> components from the kernel and implementing them as <strong>user-level</strong> programs the reside in <strong>separate</strong> address spaces.</li>
<li>smaller kernel</li>
</ul>

<p>A typical microkernel shown below.<br/>
<img src="media/15317361625058/a%20typical%20microkernel.png" alt="A typical microkernel"/></p>

<p>pros</p>

<ul>
<li>easy to extend the os
<ul>
<li>all new services added to user space do not require modification of the kernel.</li>
<li>when modification of kernel needed, changes tend to be fewer because of small kernel</li>
</ul></li>
<li>more security and reliability
<ul>
<li>since most services are running as user</li>
</ul></li>
</ul>

<p>cons</p>

<ul>
<li>performance may suffer due to increased system function overhead.
<ul>
<li>messages of user-level services to communicate must be copied between the services. </li>
</ul></li>
</ul>

<p>Best-known microkernel os is <strong>Darwin</strong>, the kernel component of the macOS and iOS.  </p>

<h3 id="toc_11">Modules</h3>

<p>Perhaps the best current methodology for operating system design involves using <strong>loadable kernel modules</strong>(LVMs, 可装载内核模块). Here, the kernel has a set of core components and can link in additional services via modules, either at boot time or during run time.</p>

<ul>
<li>design purpose: for the kernel to provide core services, while other services are implemented <strong>dynamically</strong>, as the kernel is running</li>
</ul>

<h3 id="toc_12">Hybrid systems</h3>

<p>In practice, <strong>very few</strong> operating system adopt a single, strictly defined structure. Instead, they <strong>combine different structures</strong><br/>
, resulting in <strong>hybrid systems</strong> that address performance, security, and usability issues.</p>

<p>Architecture of Apple’s macOS and iOS operating systems:<br/>
<img src="media/15317361625058/Architecture%20of%20Apple%E2%80%99s%20macOS%20and%20iOS%20operating%20systems.png" alt="Architecture of Apple’s macOS and iOS operating systems"/></p>

<p>Darwin provides two system-call interfaces: Mach system calls and BSD system calls.</p>

<p>The structure of Darwin:<br/>
<img src="media/15317361625058/The%20structure%20of%20Darwin..png" alt="The structure of Darwin."/></p>

<p>To address such performance problems, Darwin combines Mach, BSD, the I/O kit, and any kernel extensions into a <strong>single</strong> address space.</p>

<p><a href="https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/Architecture/Architecture.html#//apple_ref/doc/uid/TP30000905-CH1g-CACDAEDC">detailed documents for Darwin kernel</a></p>

<h2 id="toc_13">System boot</h2>

<p>The process of starting a computer by loading the kernel is known as <strong>booting</strong> the system.</p>

<ol>
<li>A small piece of code known as the <strong>bootstrap program</strong>（引导程序） or boot loader locates the kernel.</li>
<li>The kernel is loaded into memory and started.</li>
<li>The kernel initializes hardware.</li>
<li>The root file system is mounted.</li>
</ol>

<p>bootstrap program:</p>

<ul>
<li>usually, bootstrap program located in BIOS( nonvolatile firmware(固件) on motherboard, <a href="https://en.wikipedia.org/wiki/BIOS">wiki</a>)</li>
<li><strong>GRUB</strong> is an open-source bootstrap program for Linux and Unix systems <a href="https://en.wikipedia.org/wiki/GNU_GRUB">wiki</a>.</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/2/18</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Computer%20System.html'>Computer System</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15317613286610.html">
                
                  <h1>Operating System - History</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">reference</h2>

<ul>
<li>modern operating system 4th</li>
<li>operating system concepts 10th</li>
<li>图解TCP/IP协议</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/7/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Computer%20System.html'>Computer System</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="Hadoop%20_the_definitive_guide_1-Hadoop_fundamentals.html">
                
                  <h1>Hadoop the definitive guide 1 - Hadoop fundamentals</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/7/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Computer%20System.html'>Computer System</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="Computer System_1.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="http://or9a8nskt.bkt.clouddn.com/figure.jpeg" /></div>
            
                <h1>techlarry</h1>
                <div class="site-des">他山之石，可以攻玉</div>
                <div class="social">









<a target="_blank" class="github" target="_blank" href="https://github.com/techlarry" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:wang.zhen.hua.larry@gmail.com" title="Email">Email</a>
  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Leetcode.html"><strong>Leetcode</strong></a>
        
            <a href="C/C++.html"><strong>C/C++</strong></a>
        
            <a href="Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html"><strong>Python数据结构与算法</strong></a>
        
            <a href="Course.html"><strong>Course</strong></a>
        
            <a href="Python%E7%89%B9%E6%80%A7.html"><strong>Python特性</strong></a>
        
            <a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html"><strong>机器学习</strong></a>
        
            <a href="Python%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96.html"><strong>Python科学计算三维可视化</strong></a>
        
            <a href="English.html"><strong>English</strong></a>
        
            <a href="Computer%20System.html"><strong>Computer System</strong></a>
        
            <a href="Deep%20Learning.html"><strong>Deep Learning</strong></a>
        
            <a href="Linux%20%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html"><strong>Linux 系统编程</strong></a>
        
            <a href="%E6%95%B0%E6%8D%AE%E5%BA%93.html"><strong>数据库</strong></a>
        
            <a href="Tensorflow.html"><strong>Tensorflow</strong></a>
        
            <a href="Big%20Data.html"><strong>Big Data</strong></a>
        
            <a href="%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB.html"><strong>文献阅读</strong></a>
        
            <a href="Tools.html"><strong>Tools</strong></a>
        
            <a href="%E5%A4%A7%E6%95%B0%E6%8D%AE.html"><strong>大数据</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="os-concets-processes.html">Operating System Concepts 3 - Processes</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="os-concepts-introduction.html">Operating System Concepts 1 - Introduction</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="os-concepts-os-structures.html">Operating System Concepts 2 - Operating System structures</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15317613286610.html">Operating System - History</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="Hadoop%20_the_definitive_guide_1-Hadoop_fundamentals.html">Hadoop the definitive guide 1 - Hadoop fundamentals</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
